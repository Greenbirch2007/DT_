Python测试（总分：120）

选择题（每题2分，共20分）
1．下列哪个语句在Python中是非法的？ （B）

A、x = y = z = 1 B、x = (y = z + 1)

C、x, y = y, x D、x += y x=x+y

2．关于Python内存管理，下列说法错误的是 （B）

A、变量不必事先声明 B、变量无须先创建和赋值而直接使用

C、变量无须指定类型 D、可以使用del释放资源

3.print 100 - 25 * 3 % 4 应该输出什么? (B)
A.1 B.97
C.25 D.0

4、下面哪个不是Python合法的标识符 （B）

A、int32 B、40XL C、self D、name

5、下列哪种说法是错误的 （A）

A、除字典类型外，所有标准对象均可以用于布尔测试

B、空字符串的布尔值是False

C、空列表对象的布尔值是False

D、值为0的任何数字对象的布尔值是False

6、下列表达式的值为True的是 （C）

A、5+4j > 2-3j B、3>2>2

11and2!=1 D、not(11and 0!=1)
7、Python不支持的数据类型有 （A）

A、char B、int C、float D、list

8、以下不能创建一个字典的语句是 （C）

A、dict1 = {} B、dict2 = { 3 : 5 }

C、dict3 = dict( [2 , 5] ,[ 3 , 4 ] )

D、dict4 = dict( ( [1,2],[3,4] ) )

9、下面不能创建一个集合的语句是 （C）

A、s1 = set () B、s2 = set (“abcd”)

C、s3 = (1, 2, 3, 4) D、s4 = frozenset( (3,2,1) )

10、下列Python语句正确的是 （D）

A、min = x if x < y else y B、max = x > y and x : y

C、if (x > y) print x D、while True : pass

二．填空(每空一分，共10分)

设L=[‘a’,’b’,’c’,’d’,’e’,’f’,’g’],则L[3]值是_d___ L[3:5]值是__[‘d’,’e’]_ L[:5]值是__[‘a’,’b’,’c’,’d’,’e’]_ L[3:]值是__[’d’,’e’,’f’,’g’]_ L[-5:-2]值是__[’c’,’d’,’e’]_ L[::2]值是__[‘a’,’c’,’e’,’g’]_

Python中可变数据类型有__list___和___dict__，不可变数据类型有___int___和__str___

三、简答题(每题5分，共45分)

1 声明变量注意事项有那些?

答：

1.以字母、数字、下划线组成，不能以数字开头；

2.不能用关键字。

2 简述 对象和 类的关系？

答：

类：抽象的，只有一个，一类事物的总称；

对象：实体的，可以有多个，是类的具体实现。

3 Python里面如何实现tuple和list的转换？

答：tuple(list)

list(tuple)

介绍一下except的用法和作用？
答：

与try语句连用，如果try语句正确，则不会执行except语句；

如果try语句错误，则跳转到except语句，和except语句后的错误类型进行匹配，错误类型一致，则输出相应except语句下的内容。如果都不匹配，则再一次执行try语句，并且报错；

如果后面有else语句，在try语句正确的情况下执行；

如果后面有finally语句，一定执行；

5 Dict特点?

答：

1.key不重复，不可变；

数据无序排放；
数据无序排放；
3.可变数据类型。

6 List 和tuple 区别

答：

相同点：都是有序集合

异同点：1. list是可变数据类型,tuple是不可变数据类型；

2.定义方式：list[] tuple()

3.list 有append(),insert（）等方法；tuple没有

7 定义函数的规则是？

答：

以def开头，后接函数名和 ’()：’,有参数写在()中，下一行缩进，如果有返回值则写在return后面。

8 面向对象语言都有封装，继承，多态，分别描述 封装，继承，多态的含义和作用？

答：

封装：把类的属性赋予给对象 作用：方便调用

继承：子类继承父类的属性和方法 作用：减少代码量

多态：一类事物的多种表现形式，父类的实现指向子类的引用，需要利用继承，方法重写，重载等方法 作用：减少代码量

9 在python中f = open(‘d:/a.txt’, ‘r’)读取文件需要注意哪些

答：

f是变量。open是打开文件，如果文件不存在，则创建后再打开。‘d:/a.txt’是文件路劲，代表d盘中一个名为‘a.txt’的文件，’r’是以读的方式打开。

三 编程题（每题5分，共25分）

1 .实现登录功能（一个需求2分 ，共4分）

需求 1 实现用户输入用户名和密码，当用户名为 admin且 密码为 123 时，显示登陆成功，否则登陆失败!

答：

name = input(‘请输入用户名：’)

pw = input(‘请输入用户密码：’)

if (name == ‘admin’)and (pw == ‘123’):

print(‘登录成功’)

else:

Print(‘登录失败’)

需求2 实现用户输入用户名和密码，当用户名为 seven 且 密码为 123 时，显示登陆成功，否则登陆失败，失败时允许重复输入三次

答：

for i in range(3):

name = input(‘请输入用户名：’)

pw = input(‘请输入用户密码：’)

f (name == ‘admin’)and (pw == ‘123’):

print(‘登录成功’)

break

else:

print(‘登录失败’)

2 写代码，有如下变量，请按照要求实现每个功能（0.5分一个，共4分）

name = " aleX is a man"

移除 name 变量对应的值两边的空格，并输出移除后的内容
print(name.strip(‘ ’))

判断 name 变量对应的值a出现次数，并输出结果
print(name.count(‘a’))

判断 name 变量对应的值以a进行分割，并输出结果
print(name.split(‘a’))

将 name 变量对应的值a替换成w，并输出结果
print(name.replace(‘a’,’w’))

将 name 变量对应的值变小写，并输出结果
print(name.lower())

请输出 name 变量对应的值的第 2 个字符?
print(name[1])

请输出 name 变量对应的值的前 3 个字符?
print(name[:3])

请输出 name 变量对应的值的后 2 个字符?
print(name[-2:])

从键盘输入一个字符串，将小写字母全部转换成大写字母，然后输出到一个磁盘文件"test"中保存。
答：

a = input(‘请输入一个字符串：’)

b = a.upper()

f = open(‘d:/test/b.txt’,’w+’)

f.write(b)

4 请用循环的方式输出九九乘法表

答:

for i in range(1,10):

for j in range(1,10):

if j <= i:

print(j,’’,i,’=’,(ij))

5.输入一个六位数，求各位数之和，如果各位数之和为36-45，则此数字为幸运数字。

答：

a = int(input(‘请输入一个六位数：’))

if len(str(a)) == 6:

ge == a%10

ten == a%100//10

hu == a%1000//100

th == a%10000//1000

wan == a//10000%10

tw == a//100000

if (ge+ten+hu+th+wan+tw) >= 36 and (ge+ten+hu+th+wan+tw)<= 45:

Print(a,‘为幸运数字’)

else:

print(‘您输入的位数有误，请重新输入。。。’)

6 某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5,然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。试输入一个数，并求出对应的数字。（8分）

答：

num = int(input(‘请输入一个四位数：’))

if len(str(num)) == 4:

ge = num % 10

ten = num%100//10

hu = num//100%10

th = num // 1000

ge1 = ge + 5

ge2 = ge1 % 10

ten1 = ten + 5

ten2 = ten1 % 10

hu1 = hu + 5

hu2 = hu1 % 10

th1 = th + 5

th2 = th1 % 10

print(‘加密后的数为：’,int((str(ge2)+str(ten2)+str(hu2)+str(hu2))))

else:

print(‘您输入的位数有误，请重新输入’)

7.一：定义一个学生类。有下面的类属性：（12分）

1 姓名

2 年龄

3 成绩（语文，数学，英语)[每课成绩的类型为整数]

类方法：

1 获取学生的姓名：get_name() 返回类型:str

2 获取学生的年龄：get_age() 返回类型:int

3 返回3门科目中最高的分数。get_course() 返回类型:int

写好类以后，可以定义2个同学测试下:

zm = Student(‘zhangming’,20,[69,88,100])

返回结果：

Zhangming 20 100

答：

class Student（）：

def init(self,name,age,score):

self.name = name

self.age = age

self.score = score

def get_name(self):

print(‘学生姓名:’,self.name)

def get_age(self):

print(‘学生年龄:’，self.age)

def get_course(self):

print(‘最高的分数:’,max(self.score))

zm = Student(‘张明’,20,[69,88,100])

zm.get_name()

zm.get_age()



Python基础篇

1：为什么学习Python
家里有在这个IT圈子里面，也想让我接触这个圈子，然后给我建议学的Python，
然后自己通过百度和向有学过Python的同学了解了Python，Python这门语言，入门比较简单，
它简单易学，生态圈比较强大，涉及的地方比较多，特别是在人工智能，和数据分析这方面。在未来我觉得是往自动化，
人工智能这方面发展的，所以学习了Python

2：通过什么途径学习Python
刚开始接触Python的时候，到网上里面跟着视频学基础，再后来网上到看技术贴，然后看到有人推荐廖雪峰的Python教程，
练项目到GitHub上面找一些小项目学习。

3：谈谈对Python和其他语言的区别
复制代码
复制代码
复制代码
Python属于解释型语言，当程序运行时，是一行一行的解释，并运行，所以调式代码很方便，开发效率高，
还有龟叔给Python定位是任其自由发展、优雅、明确、简单，所以在每个领域都有建树，所有它有着非常强大的第三方库，
特点：
语法简洁优美，功能强大，标准库与第三方库都非常强大，而且应用领域也非常广
可移植性，可扩展性，可嵌入性
缺点：
　　运行速度慢，

- 解释型
    - python/php
- 编译型
    - c/java/c#
        
- Python弱类型
复制代码
复制代码
复制代码
 （1）与java相比：在很多方面，Python比Java要简单，比如java中所有变量必须声明才能使用，而Python不需要声明,用少量的代码构建出很多功能;（高效的高级数据结构）

（2）与php相比：python标准包直接提供了工具，并且相对于PHP代码更易于维护;

（3）Python与c相比：

Python 和 C Python这门语言是由C开发而来

　　对于使用：Python的类库齐全并且使用简洁，如果要实现同样的功能，Python 10行代码可以解决，C可能就需要100行甚至更多.
　　对于速度：Python的运行速度相较与C，绝逼是慢了


Python的优势：
1、Python 易于学习;

2、用少量的代码构建出很多功能;（高效的高级数据结构）

3、Python 拥有最成熟的程序包资源库之一;

4、Python完全支持面向对象;

5、Python 是跨平台且开源的。

6、动态类型:


4：简述解释型和编译型编程语言
解释型：就是边解释边执行（Python，php）
编译型：编译后再执行（c、java、c#）

5：Python的解释器种类以及相关特点？
复制代码
复制代码
CPython

是官方版本的解释器：CPython。是使用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。
CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。

IPython
IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。CPython用>>>作为提示符，而IPython用In [序号]:作为提示符。
复制代码
复制代码
复制代码
复制代码

PyPy

由Python写的解释器，它的执行速度是最快。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），
绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。

Jython
Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。

IronPython
IronPython和Jython类似，只不过IronPython是运行在.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。

小结：
　　Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。

复制代码
复制代码

6：位和字节的关系
1字节 = 8 位
位（bit），数据存储是以“字节”（Byte）为单位，数据传输是以大多是以“位”（bit，又名“比特”）为单位，
一个位就代表一个0或1（即一个二进制），二进制是构成存储器的最小单位，每8个位（bit，简写为b）组成一个字节（Byte，简写为B），
字节是最小一级的信息单位

7：b、B、KB、MB、GB的关系
b --->位(bit)    

B --->字节      一个字节等于8位

1B = 8 bit

1kb = 1024 B

1 MB = 1024 KB

1 GB = 1024 MB


8:PE8规范
复制代码
复制代码
1、使用4个空格而不是tab键进行缩进。
2、每行长度不能超过79
3、使用空行来间隔函数和类，以及函数内部的大块代码
4、必要时候，在每一行下写注释
5、使用文档注释，写出函数注释
6、在操作符和逗号之后使用空格，但是不要在括号内部使用
7、命名类和函数的时候使用一致的方式，比如使用CamelCase来命名类，
           使用lower_case_with_underscores来命名函数和方法
8、在类中总是使用self来作为默认
 9、尽量不要使用魔法方法
10、默认使用UTF-8，甚至ASCII作为编码方式
11、换行可以使用反斜杠，最好使用圆括号。
12、不要在一句import中多个库，
空格的使用
各种右括号前不要加空格。
逗号、冒号、分号前不要加空格。
函数的左括号前不要加空格。如Func(1)
序列的左括号前不要加空格。如list[2]
操作符左右各加一个空格，不要为了对齐增加空格
函数默认参数使用的赋值符左右省略空格
不要将多句语句写在同一行，尽管使用‘；’允许
if/for/while语句中，即使执行语句只有一句，也必须另起一行
 函数命名使用全部小写的方式，常量命名使用大写，类属性（方法和变量）使用小写
类的命名首字母大写

复制代码
复制代码

9：通过代码实现如下转换(进制之间转换）
复制代码
复制代码
# 二进制转换成十进制-->int
v = "0b1111011"
b = int(v,2)
print(b)  # 123


# 十进制转换成二进制--->bin
v2 = 18
print(bin(int(v2)))
# 0b10010

# 八进制转换成十进制
v3 = "011"
print(int(v3))
# 11

# 十进制转换成八进制：---> oct
v4 = 30
print(oct(int(v4)))
# 0o36

# 十六进制转换成十进制：
v5 = "0x12"
print(int(v5,16))
# 18

# 十进制转换成十六进制：---> hex
v6 = 87
print(hex(int(v6)))
# 0x57
复制代码
复制代码

10:请编写一个函数实现将IP地址转换成一个整数
复制代码
复制代码
请编写一个函数实现将IP地址转换成一个整数。
如 10.3.9.12 转换规则为：
        10            00001010
          3            00000011 
         9            00001001
         12            00001100 
再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？


def v1(addr):
    # 取每个数
    id = [int(x) for x in addr.split(".")]
    print(id)
    return sum(id[i] << [24, 16, 8, 0][i] for i in range(4))

print(v1("127.0.0.1"))

# [127, 0, 0, 1]
# 2130706433
复制代码
复制代码
------------------------------------------------


11、python递归的最大层数？998

12：求结果(and or or)
复制代码
复制代码
1. 求结果：1 or 3
print(1 or 3)  # 1

2. 求结果：1 and 3
print(1 and 3)  # 3

3. 求结果：0 and 2 and 1
print(0 and 2 and 1)  # 0

4. 求结果：0 and 2 or 1
print(0 and 2 or 1)  # 1

5. 求结果：0 and 2 or 1 or 4
print(0 and 2 or 1 or 4)  # 1

6. 求结果：0 or Flase and 1
print(0 or False and 1)  # Flase

总结：
　　# x or y 如果 x为真，则值为x，   否则为y
　　# x and y 如果 x 为真，则值为 y，否则为 x
复制代码
复制代码

运算符
1. 求结果：2 & 5

print(2 & 5)  # 10 & 101 => 000 => 0
2. 求结果：2 ^ 5

print(2 ^ 5)  # 10 ^ 101 => 111 => 1*2**0+1*2**1+1*2**2=1+2+4=7

13 ：ascii、unicode、utf-8、gbk 区别
复制代码
复制代码
python2内容进行编码（默认ascii）,而python3对内容进行编码的默认为utf-8。
ascii   最多只能用8位来表示（一个字节），即：2**8 = 256，所以，ASCII码最多只能表示 256 个符号。
unicode  万国码，任何一个字符==两个字节
utf-8     万国码的升级版  一个中文字符==三个字节   英文是一个字节  欧洲的是 2个字节
gbk       国内版本  一个中文字符==2个字节   英文是一个字节
gbk 转 utf-8  需通过媒介 unicode
复制代码
复制代码

14:字节码和机器码的区别
机器码，学名机器语言指令，有时也被称为原生码，是电脑的CPU可直接解读的数据。

字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。

复制代码
复制代码
什么是机器码

机器码(machine code)，学名机器语言指令，有时也被称为原生码（Native Code），是电脑的CPU可直接解读的数据。
通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。

总结：机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写

什么是字节码
字节码（Bytecode）是一种包含执行程序、由一序列 op 代码/数据对 组成的二进制文件。
字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。

总结：字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。
复制代码
复制代码
-----------

复制代码
复制代码
#is  比较的是内存地址
#== 比较的是值
# int     具有范围：-5---256
#对于int 小数据池
 范围：-5----256 创建的相间的数字，都指向同一个内存地址

#对于字符串 （面试）
1、小数据池 如果有空格，那指向两个内存地址，
2、长度不能超过 20
3、不能用特殊字符

i = 'a'*20
j = 'a'*20
print(i is j)   # True

i = "a"*21
j = "a"*21
print(i is j)   # False

关于编码所占字节
unicode： 所有字符（无论英文、中文等）   1个字符：2个字节
gbk：一个字符，英文1个字节，中文两个字节
utf-8：英文1个字节、 欧洲：2个字节， 亚洲：3个字节


在utf-8中，一个中文字符占用3个字节
在gbk中一个汉字占用2个字节
黎诗 = utf-8(6字节)=48
黎诗 = gbk(4字节)=32

字节和位的关系。
　　#一个字节(byte) = 8 位(bit)
　　# 位为最小的单位

简述变量命名规范
　　#1、以字母，数字，下划线任由结合
　　#2、不能以命名太长，不使用拼音，中文
　　#3、不能以数字开头
　　#4、不能用关键词
复制代码
复制代码

15:三元运算写法和应用场景？
复制代码
复制代码
应用场景：简化if语句
# 关于三元运算
# 结果+　if  + 条件  + else + 结果
result='gt' if 1>3 else 'lt'
print(result)       # lt
# 理解：如果条件为真，把if前面的值赋值给变量，否则把else后面的值赋值给变量。


lambda 表达式
temp = lambda x,y:x+y
print(temp(4,10))   # 14

可替代：
def foo(x,y):
    return x+y
print(foo(4,10))    # 14
复制代码
复制代码

16:Python3和Python2的区别？
复制代码
复制代码
1：打印时，py2需要可以不需要加括号，py3 需要
python 2 ：print ('lili')   ,   print 'lili'
python 3 : print ('lili')   
python3 必须加括号

exec语句被python3废弃，统一使用exec函数

2：内涵
Python2：1，臃肿，源码的重复量很多。
          　  2，语法不清晰，掺杂着C，php，Java，的一些陋习。
Python3：几乎是重构后的源码，规范，清晰，优美。

3、输出中文的区别
python2：要输出中文 需加 # -*- encoding:utf-8 -*-
Python3 ： 直接搞

4：input不同
python2 ：raw_input
python3 ：input 统一使用input函数

5：指定字节
python2在编译安装时，可以通过参数-----enable-unicode=ucs2 或-----enable-unicode=ucs4分别用于指定使用2个字节、4个字节表示一个unicode；
python3无法进行选择，默认使用 ucs4
查看当前python中表示unicode字符串时占用的空间：

impor sys
print（sys.maxunicode）
#如果值是65535，则表示使用usc2标准，即：2个字节表示
#如果值是1114111，则表示使用usc4标准，即：4个字节表示

6：
py2：xrange
　　　　range
py3：range  统一使用range，Python3中range的机制也进行修改并提高了大数据集生成效率

7：在包的知识点里
包：一群模块文件的集合 + __init__
区别：py2 ： 必须有__init__
　　　py3：不是必须的了

8：不相等操作符"<>"被Python3废弃，统一使用"!="

9：long整数类型被Python3废弃，统一使用int

10：迭代器iterator的next()函数被Python3废弃，统一使用next(iterator)

11：异常StandardError 被Python3废弃，统一使用Exception

12：字典变量的has_key函数被Python废弃，统一使用in关键词

13：file函数被Python3废弃，统一使用open来处理文件，可以通过io.IOBase检查文件类型
复制代码
复制代码

17：用一行代码实现数值交换
a = 1 
b = 2

a, b = b, a

18：Python3和Python2中int和long区别
在python3里，只有一种整数类型int,大多数情况下，和python２中的长整型类似。


19：xrange和range的区别
都在循环时使用，xrange内存性能更好，xrange用法与range完全相同，range一个生成list对象，xrange是生成器

要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。

在python2中：

range([start,] stop[, step])，根据start与stop指定的范围以及step设定的步长，生成一个序列

xrange用法与range完全相同，所不同的是生成的不是一个数组，而是一个生成器。

 

xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间，这两个基本上都是在循环的时候用。

在 Python 3 中，range() 是像 xrange() 那样实现，xrange()被抛弃。


20：文件操作时：xreadlines和readlines的区别？
readlines     返回一个列表

xreadlines   返回一个生成器


21： 列列举布尔值为False的常见值？
0，“”，{}，[],（），set（）
0 Flask 负数 不成立的表达式  None 等

22. 字符串、列表、元组、字典每个常用的5个方法？
复制代码
复制代码
字符串：
字符串用单引号(')或双引号(")括起来，不可变
1，find通过元素找索引，可切片，找不到返回-1
2，index，找不到报错。
3，split 由字符串分割成列表，默认按空格。
4，captalize 首字母大写，其他字母小写。
5，upper 全大写。
6，lower 全小写。
7，title，每个单词的首字母大写。
8，startswith 判断以什么为开头，可以切片，整体概念。
9，endswith 判断以什么为结尾，可以切片，整体概念。
10，format格式化输出
#format的三种玩法 格式化输出
res='{} {} {}'.format('egon',18,'male')  ==>  egon 18 male
res='{1} {0} {1}'.format('egon',18,'male')  ==> 18 egon 18
res='{name} {age} {sex}'.format(sex='male',name='egon',age=18)
11,strip 默认去掉两侧空格，有条件， 12，lstrip,rstrip 14,center 居中，默认空格。 
15，count查找元素的个数，可以切片，若没有返回0 
16，expandtabs 将一个tab键变成8个空格，如果tab前面的字符长度不足8个，则补全8个，
 17，replace（old，new,次数） 
18，isdigit 字符串由字母或数字组成 isalpha, 字符串只由字母组成 isalnum 字符串只由数字组成 
19,swapcase 大小写翻转 
20，for i in 可迭代对象。 
字典：
1无序（不能索引）2：数据关联性强3:键值对，键值对。唯一一个映射数据类型。
#字典的键必须是可哈希的   不可变类型。
在同一个字典中，键(key)必须是唯一的。


列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取
key： 输出所有的键
clear：清空                       
dic：删除的键如果没有则报错
pop：键值对删，有返回，没有原来的键会报错（自行设置返回键就不会报错）
popitem：随机删键值对
del：删除的键如果没有则报错
改 update
查  用get时。不会报错# 没有可以返回设定的返回值
    注意：
1、字典是一种映射类型，它的元素是键值对。
2、字典的关键字必须为不可变类型，且不能重复。
3、创建空字典使用 { }。

列表：
索引，切片，加，乘，检查成员。
增加：有三种，
append：在后面添加。
Insert按照索引添加，
expend：迭代着添加。
list.extend(seq) - 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
pop 删除   (pop 有返回值)
remove 可以按照元素去删
clear  清空列表
del 1、可以按照索引去删除 2、切片 3、步长（隔着删）
改  1、索引  2、切片：先删除，再迭代着添加
list.count(obj) - 统计某个元素在列表中出现的次数
list.index(obj) - 从列表中找出某个值第一个匹配项的索引位置
list.reverse() - 反向列表中元素
list.sort([func]) - 对原列表进行排序
注意：
1、List写在方括号之间，元素用逗号隔开。
2、和字符串一样，list可以被索引和切片。
3、List可以使用+操作符进行拼接。
4、List中的元素是可以改变的。

元组：
（）元组的元素不能修改
1、cmp(tuple1, tuple2)：比较两个元组元素。
2、len(tuple)：计算元组元素个数。
3、max(tuple)：返回元组中元素最大值。
4、min(tuple)：返回元组中元素最小值。
5、tuple(seq)：将列表转换为元组。
注意
1、与字符串一样，元组的元素不能修改。
2、元组也可以被索引和切片，方法一样。
3、注意构造包含0或1个元素的元组的特殊语法规则。
4、元组也可以使用+操作符进行拼接。


Set（集合）
：集合（set）是一个无序不重复元素的序列。
可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。
复制代码
复制代码

23、 lambda表达式格式以及应用场景？
复制代码
复制代码
匿名函数：为了解决那些功能很简单的需求而设计的一句话函数
函数名 = lambda 参数 ：返回值

#参数可以有多个，用逗号隔开
#匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值
#返回值和正常的函数一样可以是任意数据类型

lambda 表达式
temp = lambda x,y:x+y
print(temp(4,10))   # 14

可替代：
def foo(x,y):
    return x+y
print(foo(4,10))    # 14
复制代码
复制代码

24. pass的作用
pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。


25. *arg和**kwarg作用
 *args代表位置参数，它会接收任意多个参数并把这些参数作为元祖传递给函数。
**kwargs代表的关键字参数，返回的是字典，位置参数一定要放在关键字前面

26. is和==的区别
复制代码
复制代码
a = 'lishi'
str1 = "li"
str2 = "shi"
str3 = str1 + str2
print("a == str3",a == str3)
print("a is str3",a is str3)
print("id(a)",id(a))
print("id(str3)",id(str3))
# a == str3 True    ==  ---> 只需要内容相等
# a is str3 False   is  ---> 只需要内存地址相等
# id(a) 38565848
# id(str3) 39110280
复制代码
复制代码
is 比较的是两个实例对象是不是完全相同，它们是不是同一个对象，占用的内存地址是否相同。

== 比较的是两个对象的内容是否相等，即内存地址可以不一样，内容一样就可以了。默认会调用对象的 __eq__()方法。

27：谈谈Python的深浅拷贝？以及实现方法和应用场景。
浅拷贝只是增加了一个指针指向一个存在的地址，

而深拷贝是增加一个指针并且开辟了新的内存，这个增加的指针指向这个新的内存，
采用浅拷贝的情况，释放内存，会释放同一内存，深拷贝就不会出现释放同一内存的错误

一层的情况：

复制代码
复制代码
import copy
 
# 浅拷贝
li1 = [1, 2, 3]
li2 = li1.copy()
li1.append(4)
print(li1, li2)  # [1, 2, 3, 4] [1, 2, 3]
 
# 深拷贝
li1 = [1, 2, 3]
li2 = copy.deepcopy(li1)
li1.append(4)
print(li1, li2)  # [1, 2, 3, 4] [1, 2, 3]
复制代码
复制代码
多层的情况：

复制代码
复制代码
import copy
 
# 浅拷贝 指向共有的地址
li1 = [1, 2, 3,[4,5],6]
li2 = li1.copy()
li1[3].append(7)
print(li1, li2)  # [1, 2, 3, [4, 5, 7], 6] [1, 2, 3, [4, 5, 7], 6]
 
# 深拷贝 重指向
li1 = [1, 2, 3,[4,5],6]
li2 = copy.deepcopy(li1)
li1[3].append(7)
print(li1, li2)  # [1, 2, 3, [4, 5, 7], 6] [1, 2, 3, [4, 5], 6]
复制代码
复制代码

28. Python垃圾回收机制？
引用计数

标记清除

分代回收


29. Python的可变类型和不可变类型？
可变数据类型：列表、字典、可变集合

不可变数据类型：数字、字符串、元组、不可变集合


30、求结果
def multipliers():
    return [lambda x:i*x for i in range(4)]
print([m(2) for m in multipliers()])
复制代码
复制代码
def a():
    return [lambda x:i*x for i in range(4)]
b=a()   #返回个列表函数
# b[2](1)

print(b[1](1))
# print(type(b),b)
print([m(1) for m in a()])
print([i*i for i in [1,2,3]])
[3, 3, 3, 3]
[1, 4, 9]


'''
def multipliers():
    return [lambda x:i*x for i in range(4)]
print([m(2) for m in multipliers()])
#解释：
　　函数返回值为一个列表表达式，经过4次循环结果为包含四个lambda函数的列表，
由于函数未被调用，循环中的i值未被写入函数，经过多次替代，循环结束后i值为3，
故结果为：6,6,6,6



func=lambda x:x+1
print(func(1))
#2
print(func(2))
#3

#以上lambda等同于以下函数
def func(x):
    return(x+1)
'''
复制代码
复制代码
请修改multipliers的定义来产生期望的结果（0,2,4,6）。
def multipliers():
    return （lambda x:i*x for i in range(4)）         #返回一个生成器表达式
print([m(2) for m in multipliers()])
复制代码
复制代码
-面试题2：
现有两个元组(('a'),('b')),(('c'),('d'))，请使用python中匿名函数生成列表[{'a':'c'},{'b':'d'}]

#匿名函数形式：
l1=(('a'),('b'))
l2=(('c'),('d'))
ret=map(lambda n:{n[0]:n[1]},zip(l1,l2))
print(list(ret))
#列表表达式形式：
l1=(('a'),('b'))
l2=(('c'),('d'))
print([{n[0]:n[1]} for n in zip(l1,l2)])
复制代码
复制代码

31、求结果
复制代码
复制代码
v = dict.fromkeys(['k1', 'k2'], [])
v['k1'].append(666)
print(v)
v['k1'] = 777
print(v)

结果：
{'k1': [666], 'k2': [666]}
{'k1': 777, 'k2': [666]}

解释：
Python 字典(Dictionary) fromkeys() 函数用于创建一个新字典，以序列seq中元素做字典的键，value为字典所有键对应的初始值，默认为None。

v1 = dict.fromkeys(['k1', 'k2'])
print(v1)  # {'k1': None, 'k2': None}
 
v2 = dict.fromkeys(['k1', 'k2'], [])
print(v2)  # {'k1': [], 'k2': []}
复制代码
复制代码

32、列举常见的内置函数

abs（）
返回数字的绝对值

map
复制代码
复制代码
根据函数对指定序列做映射
map()函数接收两个参数，一个是函数，一个是可迭代对象，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。

返回值：
　　Python2  返回列表
　　Python3  返回迭代器

例子1：
def mul(x):
    return x*x
n=[1,2,3,4,5]
res=list(map(mul,n))
print(res)  #[1, 4, 9, 16, 25]

例子2：abs()  返回数字的绝对值
ret = map(abs,[-1,-5,6,-7])
print(list(ret))
# [1, 5, 6, 7]
复制代码
复制代码

filter
复制代码
复制代码
filter()函数接收一个函数 f(函数)和一个list（可迭代对象），这个函数 f的作用是对每个元素进行判断，返回 True或 False，
filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。
def is_odd(x):
    return x % 2 == 1

v=list(filter(is_odd, [1, 4, 6, 7, 9, 12, 17]))
print(v)  #[1, 7, 9, 17]
复制代码
复制代码

map与filter总结
复制代码
复制代码
# filter 与 map 总结
# 参数: 都是一个函数名 + 可迭代对象
# 返回值: 都是返回可迭代对象
# 区别:
# filter 是做筛选的，结果还是原来就在可迭代对象中的项
# map 是对可迭代对象中每一项做操作的，结果不一定是原来就在可迭代对象中的项
复制代码
复制代码

isinstance\type
复制代码
复制代码
isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。
isinstance() 与 type() 区别：
type() 不会认为子类是一种父类类型，不考虑继承关系。
isinstance() 会认为子类是一种父类类型，考虑继承关系。
如果要判断两个类型是否相同推荐使用 isinstance()。
# 例一
a = 2
print(isinstance(a,int))   # True
print(isinstance(a,str))   # False

# type() 与 isinstance() 区别
class A:
    pass

class B(A):
    pass

print("isinstance",isinstance(A(),A))   # isinstance True
print("type",type(A())  == A)    # type True

print('isinstance',isinstance(B(),A) )   # isinstance True
print('type',type(B()) == A)     #  type False
复制代码
复制代码

zip 拉链函数
复制代码
复制代码
# zip 拉链函数，
# 将对象中对应的元素打包成一个个元组，
# 然后返回由这些元组组成的列表迭代器。
# 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。
print(list(zip([0,1,3],[5,6,7],['a','b'])))
# [(0, 5, 'a'), (1, 6, 'b')]
复制代码
复制代码
复制代码
复制代码
zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。
>>>a = [1,2,3]
>>> b = [4,5,6]
>>> c = [4,5,6,7,8]
>>> zipped = zip(a,b)     # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]
>>> zip(a,c)              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
>>> zip(*zipped)          # 与 zip 相反，可理解为解压，返回二维矩阵式
[(1, 2, 3), (4, 5, 6)]
复制代码
复制代码
reduce

复制代码
复制代码
'''
reduce()  函数
reduce() 函数会对参数序列中元素进行累积
函数将一个数据集合(链表、元组等)中的所有数据进行下列操作
'''

注意：
Python3已经将reduce() 函数从全局名字空间里移除了，它现在被放置在 fucntools 模块里，如果想要使用它，则需要通过引入 functools 模块来调用 reduce() 函数：

from functools import reduce
def add(x,y):
    return x + y

print(reduce(add,[1,2,3,4,5]))
#  15

print(reduce(lambda x, y: x+y, [1,2,3,4,5]))  # 15

print(reduce(add,range(1,101)))
#  5050
复制代码
复制代码

33. filter、map、reduce的作用？

内置函数：map、reduce、filter的用法和区别
map:根据函数对指定序列做映射

复制代码
复制代码
map
参数
接收两个参数：一个是函数，一个是序列（可迭代对象）
返回值
Python2 返回列表
Python3 返回迭代器

# 例子：
# abs() 函数返回数字的绝对值
# 新的内容的个数等于原内容的个数
# ret = map(abs,[-1,-5,6,-7])
# print(list(ret))
# [1, 5, 6, 7]
复制代码
复制代码
filter:过滤函数 新的内容少于等于原内容的时候。才能使用filter

复制代码
复制代码
filter() 函数用于过滤序列，过滤不符合条件的元素，返回由符合条件元素组成的心列表

参数：
function  函数
iterable  可迭代对象
返回值:
返回列表

# 筛选大于10的数
def is_odd(x):
    if x>10:
        return True

ret = filter(is_odd,[1,4,5,7,8,9,76])  # 为迭代器
print(list(ret))
# [76]
复制代码
复制代码
reduce:对于序列内所有元素进行累计操作

复制代码
复制代码
'''
reduce()  函数
reduce() 函数会对参数序列中元素进行累积
函数将一个数据集合(链表、元组等)中的所有数据进行下列操作
'''

from functools import reduce
def add(x,y):
    return x + y

print(reduce(add,[1,2,3,4,5]))
#  15

print(reduce(lambda x, y: x+y, [1,2,3,4,5]))  # 15

print(reduce(add,range(1,101)))
#  5050
复制代码
复制代码

34、 一行代码实现9*9乘法表
print('\n'.join([' '.join(['%s*%s=%-2s' % (j, i, i * j) for j in range(1, i + 1)]) for i in range(1, 10)]))

35. 如何安装第三方模块？以及用过哪些第三方模块？
复制代码
复制代码
1：pip包管理器
2：源码下载
    -下载
    -解压
-python setup.py build
-python setup.py install
复制代码
复制代码
用过的第三方模块：requests,pymysql,DbUtils,SQLAlchemy等


36、 常用模块都有那些？
re模块，os模块，json模块，time模块，

爬虫里面的requests/beautifulsoup4（bs4）


37. re的match和search区别？
re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。

re.search 扫描整个字符串并返回第一个成功的匹配。


38. 什么是正则的贪婪匹配？
匹配一个字符串没有节制，能匹配多少就去匹配多少，知道没有匹配的为止


39. 求结果：
a. [ i % 2 for i in range(10) ]

print([ i % 2 for i in range(10) ])  # [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
print([ i  for i in range(10) ])     # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print([ 10 % 2])   # [0]
# %是个运算符。
b. ( i % 2 for i in range(10) )

复制代码
复制代码
print(( i % 2 for i in range(10) ))
#  <generator object <genexpr> at 0x00000000020CEEB8> 生成器
# 在Python中，有一种自定义迭代器的方式，称为生成器（Generator）。
# 定义生成器的两种方式：
# 1.创建一个generator，只要把一个列表生成式的[]改成()，就创建了一个generator：
# generator保存的是算法，每次调用next()，就计算出下一个元素的值，直到计算到最后一个元素，
没有更多的元素时，抛出StopIteration的错误。
# 2.定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，
而是一个generator
复制代码
复制代码

40. 求结果：
a. 1 or 2
b. 1 and 2
c. 1 < (2==2)
d. 1 < 2 == 2

复制代码
复制代码
>>> 1 or 2
1
>>> 1 and 2
2
>>> 1 < (2==2)
False
>>> 1 < 2 == 2
True
复制代码
复制代码

 41、def func(a,b=[]) 这种写法有什什么坑？
复制代码
复制代码
def func(a,b = []):
    b.append(1)
    print(a,b)

func(a=2)
func(2)
func(2)


'''
    2 [1]
    2 [1, 1]
    2 [1, 1, 1]
    函数的默认参数是一个list 当第一次执行的时候实例化了一个list 
    第二次执行还是用第一次执行的时候实例化的地址存储 
    所以三次执行的结果就是 [1, 1, 1] 想每次执行只输出[1] ，默认参数应该设置为None
'''
复制代码
复制代码

42、如何实现 “1,2,3” 变成 [‘1’,’2’,’3’]
list("1,2,3".split(','))

43. 如何实现[‘1’,’2’,’3’]变成[1,2,3]
复制代码
复制代码
[int(x) for x in ['1','2','3']]


python 里如何把['1','2','3'] 变成[1,2,3]

a = ['1','2','3']
b = [int(i) for i in a]
print(b)
# [1, 2, 3]
复制代码
复制代码

44. a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 b = [(1,),(2,),(3,) ] 的区别？
 补充：

复制代码
复制代码
a=[1,2,3,4,5]，b=a和b=a[:]，有区别么？


a = [1,2,3,4,5]
b = a
b1 = a[:]
print(b)    #  [1, 2, 3, 4, 5]
# print(b)   #  [1, 2, 3, 4, 5]

b.append(6)
print("a",a)  # a [1, 2, 3, 4, 5, 6]
print("b",b)  # b [1, 2, 3, 4, 5, 6]  传递引用
print("b1",b1) # b1 [1, 2, 3, 4, 5]   拷贝
复制代码
复制代码
# 一个列表A=[2，3，4]，Python如何将其转换成B=[(2,3),(3,4),(4,2)]？
# B = zip(A, A[1:]+A[:1])
# B = [(j,A[i+1]) if i < len(A) - 1 else (j,A[0]) for i, j in enumerate(A)]

45. 如何用一行代码生成[1,4,9,16,25,36,49,64,81,100]
[i*i for i in range(1,11)]

46. 一行代码实现删除列表中重复的值
list(set([1, 2, 3, 4, 45, 1, 2, 343, 2, 2]))

47. 如何在函数中设置一个全局变量
python中的global语句是被用来声明全局变量的。

复制代码
复制代码
x = 2
def func():
    global x
    x = 1
    return x
func()
print(x)  # 1
复制代码
复制代码

48. logging模块的作用？以及应用场景？
复制代码
复制代码
logging 
模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统

作用：可以了解程序运行情况，是否正常
　　　　在程序的出现故障快速定位出错地方及故障分析
 
复制代码
复制代码

49. 请用代码简答实现stack
Stack() 创建一个新的空栈
push(item) 添加一个新的元素item到栈顶
pop() 弹出栈顶元素
peek() 返回栈顶元素
is_empty() 判断栈是否为空
size() 返回栈的元素个数
复制代码
复制代码
# 实现一个栈stack,后进先出

'''
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        # 判断是否为空
        return self.items == []

    def push(self,item):
        # 加入元素
        self.items.append(item)

    def pop(self):
        # 弹出元素
        return self.items.pop()

    def peek(self):
        # 返回栈顶元素
        return self.items[len(self.items)-1]

    def size(self):
        # 返回栈的大小
        return len(self.items)

if __name__ == "__main__":
    stack = Stack()
    stack.push("H")
    stack.push("E")
    stack.push("L")
    print(stack.size())  # 3
    print(stack.peek())  # L 
    print(stack.pop())   # L
    print(stack.pop())   # E
    print(stack.pop())   # H
'''
复制代码
复制代码

50. 常用字符串格式化哪几种？
1.占位符%

%d 表示那个位置是整数；%f 表示浮点数；%s 表示字符串。

print('Hello,%s' % 'Python')
print('Hello,%d%s%.2f' % (666, 'Python', 9.99)) # 打印：Hello,666Python10.00
2.format

print('{k} is {v}'.format(k='python', v='easy'))  # 通过关键字
print('{0} is {1}'.format('python', 'easy'))      # 通过关键字

51. 简述 生成器、迭代器、可迭代对象 以及应用场景？

迭代器
含有__iter__和__next__方法 (包含__next__方法的可迭代对象就是迭代器)


生成器
：包括含有yield这个关键字，生成器也是迭代器，调动next把函数变成迭代器。

复制代码
复制代码
应用场景：
range/xrange
    - py2： range(1000000)  ,会立即创建，xrange(1000000)生成器
    - py3：range（10000000）生成器 
- redis获取值
conn = Redis(...)

　　　　def hscan_iter(self, name, match=None, count=None):
　　　　　　"""
　　　　　　Make an iterator using the HSCAN command so that the client doesn't
　　　　　　need to remember the cursor position.

　　　　　　``match`` allows for filtering the keys by pattern

　　　　　　``count`` allows for hint the minimum number of returns
　　　　　　"""
　　　　　　cursor = '0'
　　　　　　while cursor != 0:
　　　　　　　　# 去redis中获取数据：12
　　　　　　　　# cursor，下一次取的位置
　　　　　　　　# data：本地获取的12条数数据
　　　　　　　　cursor, data = self.hscan(name, cursor=cursor,match=match, count=count)
　　　　　　　　for item in data.items():
　　　　　　　　　　yield item

stark组件

def index(request):
　　　　data = [
　　　　　　{'k1':1,'name':'alex'},
　　　　　　{'k1':2,'name':'老男孩'},
　　　　　　{'k1':3,'name':'小男孩'},
　　　　]
　　　　new_data = []
　　　　for item in data:
　　　　　　item['email'] = "xxx@qq.com"
　　　　　　new_data.append(item)

　　　　return render(request,'xx.html',{'data':new_data})

 
复制代码
复制代码

可迭代对象
 一个类内部实现__iter__方法且返回一个迭代器。

复制代码
复制代码
应用场景： 
    - wtforms中对form对象进行循环时候，显示form中包含的所有字段。
        class LoginForm(Form):
            name = simple.StringField(
                label='用户名',
                validators=[
                    validators.DataRequired(message='用户名不能为空.'),
                    validators.Length(min=6, max=18, message='用户名长度必须大于%(min)d且小于%(max)d')
                ],
                widget=widgets.TextInput(),
                render_kw={'class': 'form-control'}
            )
            pwd = simple.PasswordField(
                label='密码',
                validators=[
                    validators.DataRequired(message='密码不能为空.'),
                    validators.Length(min=8, message='用户名长度必须大于%(min)d'),
                    validators.Regexp(regex="^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[$@$!%*?&])[A-Za-z\d$@$!%*?&]{8,}",
                                      message='密码至少8个字符，至少1个大写字母，1个小写字母，1个数字和1个特殊字符')

                ],
                widget=widgets.PasswordInput(),
                render_kw={'class': 'form-control'}
            )

        
        form = LoginForm()
        for item in form:
            print(item)
            
    - 列表、字典、元组
复制代码
复制代码

装饰器
复制代码
复制代码
 装饰器：
能够在不修改原函数代码的基础上，在执行前后进行定制操作，闭包函数的一种应用
场景：
   - flask路由系统
   - flask before_request
   - csrf
   - django内置认证
   - django缓存
# 手写装饰器；
import functools
def wrapper(func):
   @functools.wraps(func)  #不改变原函数属性
   def inner(*args, **kwargs):
      执行函数前
      return func(*args, **kwargs)
      执行函数后
   return inner
1. 执行wapper函数，并将被装饰的函数当做参数。 wapper(index)
2. 将第一步的返回值，重新赋值给  新index =  wapper(老index)
@wrapper    #index=wrapper(index)
def index(x):
   return x+100
复制代码
复制代码
调用装饰器其实是一个闭包函数，为其他函数添加附加功能，不修改被修改的源代码和不修改被修饰的方式，装饰器的返回值也是一个函数对象。
比如：插入日志、性能测试、事物处理、缓存、权限验证等，有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。


 52. 用Python实现一个二分查找的函数。
二分查找算法：简单的说，就是将一个列表先排序好，比如按照从小到大的顺序排列好，当给定一个数据，比如3，查找3在列表中的位置时，可以先找到列表中间的数li[middle]和3进行比较，当它比3小时，那么3一定是在列表的右边，反之，则3在列表的左边，比如它比3小，则下次就可以只比较[middle+1, end]的数，继续使用二分法，将它一分为二，直到找到3这个数返回或者列表全部遍历完成（3不在列表中） 

优点：效率高，时间复杂度为O(logN)； 
缺点：数据要是有序的，顺序存储。

复制代码
复制代码
li = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 
 
def search(someone, li):
    l = -1
    h = len(li)
 
    while l + 1 != h:
        m = int((l + h) / 2)
        if li[m] < someone:
            l = m
        else:
            h = m
    p = h
    if p >= len(li) or li[p] != someone:
        print("元素不存在")
    else:
        str = "元素索引为%d" % p
        print(str)
 
 
search(3, li)  # 元素索引为2
复制代码
复制代码

53. 谈谈你对闭包的理解？
复制代码
复制代码
ef foo():
    m=3
    n=5
    def bar():
        a=4
        return m+n+a
    return bar
  
>>>bar =  foo()
>>>bar()
12
复制代码
复制代码
说明：
bar在foo函数的代码块中定义。我们称bar是foo的内部函数。
在bar的局部作用域中可以直接访问foo局部作用域中定义的m、n变量。
简单的说，这种内部函数可以使用外部函数变量的行为，就叫闭包。

闭包的意义与应用


54. os和sys模块的作用？
os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;
sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。

复制代码
复制代码
os与sys模块的官方解释如下：
os: This module provides a portable way of using operating system dependent functionality.
这个模块提供了一种方便的使用操作系统函数的方法。
sys: This module provides access to some variables used or maintained by the interpreter and to 
functions that interact strongly with the interpreter.
这个模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。
os 常用方法
os.remove() 删除文件
os.rename() 重命名文件
os.walk() 生成目录树下的所有文件名
os.chdir() 改变目录
os.mkdir/makedirs 创建目录/多层目录
os.rmdir/removedirs 删除目录/多层目录
os.listdir() 列出指定目录的文件
os.getcwd() 取得当前工作目录
os.chmod() 改变目录权限
os.path.basename() 去掉目录路径，返回文件名
os.path.dirname() 去掉文件名，返回目录路径
os.path.join() 将分离的各部分组合成一个路径名
os.path.split() 返回( dirname(), basename())元组
os.path.splitext() 返回 (filename, extension) 元组
os.path.getatime\ctime\mtime 分别返回最近访问、创建、修改时间
os.path.getsize() 返回文件大小
os.path.exists() 是否存在
os.path.isabs() 是否为绝对路径
os.path.isdir() 是否为目录
os.path.isfile() 是否为文件
sys 常用方法
sys.argv 命令行参数List，第一个元素是程序本身路径
sys.modules.keys() 返回所有已经导入的模块列表
sys.exc_info() 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息
sys.exit(n) 退出程序，正常退出时exit(0)
sys.hexversion 获取Python解释程序的版本值，16进制格式如：0x020403F0
sys.version 获取Python解释程序的版本信息
sys.maxint 最大的Int值
sys.maxunicode 最大的Unicode值
sys.modules 返回系统导入的模块字段，key是模块名，value是模块
sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
sys.platform 返回操作系统平台名称
sys.stdout 标准输出
sys.stdin 标准输入
sys.stderr 错误输出
sys.exc_clear() 用来清除当前线程所出现的当前的或最近的错误信息
sys.exec_prefix 返回平台独立的python文件安装的位置
sys.byteorder 本地字节规则的指示器，big-endian平台的值是'big',little-endian平台的值是'little'
sys.copyright 记录python版权相关的东西
sys.api_version 解释器的C的API版本
总结：
os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;
sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。
复制代码
复制代码

55. 如何生成一个随机数？
import random
 
print(random.random())          # 用于生成一个0到1的随机符点数: 0 <= n < 1.0
print(random.randint(1, 1000))  # 用于生成一个指定范围内的整数

56. 如何使用python删除一个文件？
复制代码
复制代码
import os
file = r'D:\test.txt'
if os.path.exists(file):
    os.remove(file)
    print('delete success')
else:
    print('no such file:%s' % file)
复制代码
复制代码

57. 谈谈你对面向对象的理解
三大特性以及解释？
面对对象是一种编程思想，以类的眼光来来看待事物的一种方式。将有共同的属性和方法的事物封装到同一个类下面。

继承：将多个类的共同属性和方法封装到一个父类下面，然后在用这些类来继承这个类的属性和方法

封装：将有共同的属性和方法封装到同一个类下面

第一层面：创建类和对象会分别创建二者的名称空间，我们只能用类名.或者obj.的方式去访问里面的名字，这本身就是一种封装
第二层面：类中把某些属性和方法隐藏起来(或者说定义成私有的)，只在类的内部使用、外部无法访问，或者留下少量接口（函数）供外部访问。
多态：Python天生是支持多态的。指的是基类的同一个方法在不同的派生类中有着不同的功能


58. Python面向对象中的继承有什么特点
复制代码
复制代码
继承概念的实现方式主要有2类：实现继承、接口继承。

         实现继承是指使用基类的属性和方法而无需额外编码的能力；
         接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力(子类重构爹类方法)；
python 两种类：经典类 新式类
python3 新式类 —— 都默认继承object class Animal(object): == class Animal:
python2 经典类和新式类 并存
        class Animal:  经典类 —— 继承顺序 个别使用方法
        class Animal(object):  新式类

继承分为单继承和多继承
Python是支持多继承的
如果没有指定基类，python的类会默认继承object类，object是所有python类的基类，它提供了一些常见方法（如__str__）的实现。
复制代码
复制代码
补充继承的应用（面试题）

复制代码
复制代码
1、对象可以调用自己本类和父类的所有方法和属性， 先调用自己的 自己没有才调父类的。谁（对象）调用方法，方法中的self就指向谁

class Foo:
    def __init__(self):
        self.func()

    def func(self):
        print('Foo.func')

class Son(Foo):
    def func(self):
        print('Son.func')

s = Son()
 # Son.func

========================================================
class A:
    def get(self):
        self.say()

    def say(self):
        print('AAAAA')

class B(A):
    def say(self):
        print('BBBBB')

b = B()
b.get()   #输出结果为：BBBBB
复制代码
复制代码

59. 面向对象深度优先和广度优先是什么？
Python的类可以继承多个类，Python的类如果继承了多个类，那么其寻找方法的方式有两种
当类是经典类时，多继承情况下，会按照深度优先方式查找  py3
当类是新式类时，多继承情况下，会按照广度优先方式查找  py2
简单点说就是：经典类是纵向查找，新式类是横向查找
经典类和新式类的区别就是，在声明类的时候，新式类需要加上object关键字。在python3中默认全是新式类

60. 面向对象中super的作用？
用于子类继承基类的方法
复制代码
复制代码
复制代码
class FooParent(object):
    def __init__(self):
        self.parent = 'I\'m the parent.'
        print('Parent')
        print('1111')

    def bar(self, message):
        print("%s from Parent" % message)


class FooChild(FooParent):
    def __init__(self):
        # super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类B的对象 FooChild 转换为类 FooParent 的对象
        super(FooChild, self).__init__()
        print('Child')

    # def bar(self, message):
    #     # super(FooChild, self).bar(message)
    #     print('Child bar fuction')
    #     print(self.parent)


if __name__ == '__main__':
    fooChild = FooChild()
    fooChild.bar('HelloWorld')
复制代码
复制代码
复制代码

61. 是否使用过functools中的函数？其作用是什么？
用于修复装饰器

复制代码
复制代码
复制代码
import functools
 
def deco(func):
    @functools.wraps(func)  # 加在最内层函数正上方
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
 
    return wrapper
 
 
@deco
def index():
    '''哈哈哈哈'''
    x = 10
    print('from index')
 
 
print(index.__name__)
print(index.__doc__)
 
# 加@functools.wraps
# index
# 哈哈哈哈
 
# 不加@functools.wraps
# wrapper
# None
复制代码
复制代码
复制代码

62. 列举面向对象中带双下划线的特殊方法，如：__new__、__init__
__new__：生成实例
__init__：生成实例的属性
__call__：实例对象加( )会执行def __call__:... 方法里边的内容。

__del__：析构方法，当对象在内存中被释放时，自动触发执行。如当 del obj 或者应用程序运行完毕时，执行该方法里边的内容。

__enter__和__exit__：出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量；with中代码块执行完毕时执行__exit__里边的内容。

__module__：表示当前操作的对象在那个模块   obj.__module__
__class__ ：表示当前操作的对象的类是什么     obj.__class__

__doc__：类的描述信息，该描述信息无法被继承

__str__：改变对象的字符串显示 print函数 --->obj.__str__()
__repr__：改变对象的字符串显示 交互式解释器 --->obj.__repr__()
__format__：自定制格式化字符串

__slots__:一个类变量 用来限制实例可以添加的属性的数量和类型  

__setitem__,__getitem,__delitem__:

复制代码
复制代码
复制代码
class Foo:
    def __init__(self,name):
        self.name=name

    def __getitem__(self, item):
        print(self.__dict__[item])

    def __setitem__(self, key, value):
        self.__dict__[key]=value
    def __delitem__(self, key):
        print('del obj[key]时,我执行')
        self.__dict__.pop(key)
    def __delattr__(self, item):
        print('del obj.key时,我执行')
        self.__dict__.pop(item)

f1=Foo('sb')
f1['age']=18
f1['age1']=19
del f1.age1
del f1['age']
f1['name']='alex'
print(f1.__dict__)
复制代码
复制代码
复制代码
__get__():调用一个属性时,触发
__set__():为一个属性赋值时,触发
__delete__():采用del删除属性时,触发

__setattr__,__delattr__,__getattr__ :


63. 如何判断是函数还是方法？
看他的调用者是谁，如果是类，就需要传入一个参数self的值，这时他就是一个函数，

如果调用者是对象，就不需要给self传入参数值，这时他就是一个方法

print(isinstance(obj.func, FunctionType))   # False

print(isinstance(obj.func, MethodType))    # True

复制代码
复制代码
复制代码
class Foo(object):
    def __init__(self):
        self.name = 'lcg'
 
    def func(self):
        print(self.name)
 
 
obj = Foo()
print(obj.func)  # <bound method Foo.func of <__main__.Foo object at 0x000001ABC0F15F98>>
 
print(Foo.func)  # <function Foo.func at 0x000001ABC1F45BF8>
 
# ------------------------FunctionType, MethodType------------#
 
 
from types import FunctionType, MethodType
 
obj = Foo()
print(isinstance(obj.func, FunctionType))  # False
print(isinstance(obj.func, MethodType))  # True
 
print(isinstance(Foo.func, FunctionType))  # True
print(isinstance(Foo.func, MethodType))  # False
 
# ------------------------------------------------------------#
obj = Foo()
Foo.func(obj)  # lcg
 
obj = Foo()
obj.func()  # lcg
 
"""
注意：
    方法，无需传入self参数
    函数，必须手动传入self参数
"""
复制代码
复制代码
复制代码

64. 静态方法和类方法区别？
尽管 classmethod 和 staticmethod 非常相似，但在用法上依然有一些明显的区别。classmethod 必须有一个指向类对象的引用作为第一个参数，而 staticmethod 可以没有任何参数。

举个栗子:

复制代码
复制代码
复制代码
class Num:
    # 普通方法：能用Num调用而不能用实例化对象调用   
    def one():  
        print ('1')
 
    # 实例方法：能用实例化对象调用而不能用Num调用
    def two(self):
        print ('2')
 
    # 静态方法：能用Num和实例化对象调用
    @staticmethod 
    def three():  
        print ('3')
 
    # 类方法：第一个参数cls长什么样不重要，都是指Num类本身，调用时将Num类作为对象隐式地传入方法   
    @classmethod 
    def go(cls): 
        cls.three() 
 
Num.one()          #1
#Num.two()         #TypeError: two() missing 1 required positional argument: 'self'
Num.three()        #3
Num.go()           #3
 
i=Num()                
#i.one()           #TypeError: one() takes 0 positional arguments but 1 was given         
i.two()            #2      
i.three()          #3
i.go()             #3 
复制代码
复制代码
复制代码

65. 列举面向对象中的特殊成员以及应用场景
复制代码
复制代码
复制代码
__call__

__new__

__init__

__doc__

__class__

__del__

__dict__

__str__

在falsk源码用到......
复制代码
复制代码
复制代码

66. 1、2、3、4、5 能组成多少个互不相同且无重复的三位数
60个

题意理解：组成后的数值不相同，且组合的三个位数之间数字不重复。

使用python内置的排列组合函数（不放回抽样排列）

product 笛卡尔积　　（有放回抽样排列）

permutations 排列　　（不放回抽样排列）

combinations 组合,没有重复　　（不放回抽样组合）

combinations_with_replacement 组合,有重复　　（有放回抽样组合）

import itertools
 
print(len(list(itertools.permutations('12345', 3))))  # 60

67. 什么是反射？以及应⽤用场景？
反射的核心本质就是以字符串的形式去导入个模块，利用字符串的形式去执行函数。

Django中的 CBV就是基于反射实现的。

68. metaclass作用？以及应用场景？
metaclass用来指定类是由谁创建的。

类的metaclass 默认是type。我们也可以指定类的metaclass值。在python3中：

复制代码
复制代码
复制代码
class MyType(type):
    def __call__(self, *args, **kwargs):
        return 'MyType'
  
  
class Foo(object, metaclass=MyType):
    def __init__(self):
        return 'init'
  
    def __new__(cls, *args, **kwargs):
        return cls.__init__(cls)
  
    def __call__(self, *args, **kwargs):
        return 'call'
  
  
obj = Foo()
print(obj)  # MyType
复制代码
复制代码
复制代码
 


69. 用尽量多的方法实现单例模式。
复制代码
复制代码
复制代码
1：使用模块
Python的模块就是天然的单例模式。
因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。
因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。
例如：
class V1(object):
    def foo(self)
        pass
V1 = V1()
将上面代码保存在文件test.py,要使用时，直接在其他文件中导入此文件中的对象，这个对象既是单例模式的对象

如：from a import V1

2：使用装饰器
def Singleton(cls):
    _instance = {}
    def _singleton(*args, **kargs):
        if cls not in _instance:
            _instance[cls] = cls(*args, **kargs)
        return _instance[cls]
    return _singleton
@Singleton
class A(object):
    a = 1
    def __init__(self, x=0):
        self.x = x
a1 = A(2)
a2 = A(3)


3：使用类

4：基于__new__方法实现
当我们实例化一个对象时，是先执行了类的__new__方法
当：（我们没写时，默认调用object.__new__），实例化对象；然后再执行类的__init__方法，对这个对象进行初始化，所有我们可以基于这个，实现单例模式
复制代码
复制代码
复制代码

70. 装饰器器的写法以及应用场景。
含义：装饰器本质就是函数，为其他函数添加附加功能

原则：

不修改被修饰函数的代码

不修改被修饰函数的调用方式

应用场景：

无参装饰器在用户登录 认证中常见

有参装饰器在flask的路由系统中见到过

复制代码
复制代码
复制代码
import functools
def wrapper(func):
    @functools.wraps(func)
    def inner(*args, **kwargs):
        print('我是装饰器')
        return func
return inner

@wrapper
def index():
    print('我是被装饰函数')
    return None
index()

# 应用场景
    - 高阶函数
    - 闭包
    - 装饰器 
    - functools.wraps(func)
复制代码
复制代码
复制代码

71. 异常处理写法以及如何主动跑出异常（应用场景）
复制代码
复制代码
复制代码
# 触发异常
def temp_convert(var):
    try:
        return int(var)
    except ValueError as Argument:
        print ("参数没有包含数字%s"%Argument)

# 调用函数
temp_convert("xyz")
# 以10为基数的int()的无效文字:“xyz”

----------------------------------------------------------------------------
# raise语法
#raise [Exception [, args [, traceback]]]
# 语句中 Exception 是异常的类型，args 是自已提供的异常参数。

class Networkerror(RuntimeError):
    def __init__(self, arg):
        self.args = arg
try:
    raise Networkerror("Bad hostname")
except Networkerror as e:
    print(e.args)
复制代码
复制代码
复制代码

72、什么是面向对象的mro
mro就是方法解析顺序


73. isinstance作用以及应用场景？
isinstance(对象，类)  判断这个对象是不是这个类或者这个类的子类的实例化

复制代码
复制代码
复制代码
# # 判断a 属不属于A这个类（可以判断到祖宗类）
class A:
    pass

class B(A):
    pass
a = A()
b = B()
print(isinstance(b,A)) # ===> True  判断到祖宗类

# 任何与object都是True,内部都继承object
class A:pass
a = A()  # 实例化
print(isinstance(a,object))  #  True
复制代码
复制代码
复制代码
应用场景：rest framework 认证的流程

scrapy-redis


74. 写代码并实现
Given an array of integers, return indices of the two numbers such that they add up to a
specific target.You may assume that each input would have exactly one solution, and you may
not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1]


75. json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？


76. json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？
 在序列化时，中文汉字总是被转换为unicode码，在dumps函数中添加参数ensure_ascii=False即可解决。

77. 什么是断言？应用场景？
复制代码
复制代码
复制代码
assert 是的作用？断言
条件成立（布尔值为True）则继续往下，否则跑出异常，一般用于：满足某个条件之后，才能执行，否则应该跑出异常。

写API的时候，继承GenericAPIView

class GenericAPIView(views.APIView):
                    """
                    Base class for all other generic views.
                    """
                    # You'll need to either set these attributes,
                    # or override `get_queryset()`/`get_serializer_class()`.
                    # If you are overriding a view method, it is important that you call
                    # `get_queryset()` instead of accessing the `queryset` property directly,
                    # as `queryset` will get evaluated only once, and those results are cached
                    # for all subsequent requests.
                    queryset = None
                    serializer_class = None

                    # If you want to use object lookups other than pk, set 'lookup_field'.
                    # For more complex lookup requirements override `get_object()`.
                    lookup_field = 'pk'
                    lookup_url_kwarg = None

                    # The filter backend classes to use for queryset filtering
                    filter_backends = api_settings.DEFAULT_FILTER_BACKENDS

                    # The style to use for queryset pagination.
                    pagination_class = api_settings.DEFAULT_PAGINATION_CLASS

                    def get_queryset(self):

                        assert self.queryset is not None, (
                            "'%s' should either include a `queryset` attribute, "
                            "or override the `get_queryset()` method."
                            % self.__class__.__name__
                        )

                        queryset = self.queryset
                        if isinstance(queryset, QuerySet):
                            # Ensure queryset is re-evaluated on each request.
                            queryset = queryset.all()
                        return queryset
复制代码
复制代码
复制代码

78. 有用过with statement吗？它的好处是什么？


79. 使用代码实现查看列举目录下的所有文件。


80. 简述 yield和yield from关键字
回到顶部
第二部分 网络编程和并发

81. 简述 OSI 七层协议。
 

物理层：主要是基于电器特性发送高低电压（电信号），高电压对应数字1，低电压对应数字0

数据链路层：定义了电信号的分组方式

网路层：引入一套新的地址用来区分不同的广播域/子网，这套地址即网络地址

传输层：建立端口到端口的通信

会话层：建立客户端与服务端连接

表示层：对来自应用层的命令和数据进行解释，按照一定格式传给会话层。如编码、数据格式转换、加密解密、压缩解压
应用层：规定应用程序的数据格式


82. 什么是C/S和B/S架构？
c/s架构，就是client（客户端）与server（服务端）即：客户端与服务端的架构。

b/s架构，就是brosver（浏览器端）与sever（服务端）即：浏览器端与服务端架构

优点：统一了所有应用程序的入口、方便、轻量级


83. 简述 三次握手、四次挥手的流程。
复制代码
复制代码
复制代码
三次握手：
    第一次握手
1：客户端先向服务端发起一次询问建立连接的请求，并随机生成一个值作为标识
    第二次握手
2：服务端向客户端先回应第一个标识，再重新发一个确认标识
    第三次握手
3：客户端确认标识，建立连接，开始传输数据
    
复制代码
复制代码
复制代码
复制代码
复制代码
复制代码
四次挥手 ---> 断开连接
第一次挥手
    客户端向服务端发起请求断开连接的请求
第二次挥手
    服务端向客户端确认请求
第三次挥手
    服务端向客户端发起断开连接请求
第四次挥手
    客户端向服务端确认断开请求
复制代码
复制代码
复制代码

84. TCP和UDP的区别？
TCP/UDP区别
 TCP协议是面向连接，保证高可靠性传输层协议
 UDP：数据丢失，无秩序的传输层协议（qq基于udp协议）

85. 为何基于tcp协议的通信比基于udp协议的通信更可靠？
tcp：可靠，因为只要对方回了确认收到信息，才发下一个，如果没收到确认信息就重发
UDP：不可靠，它是一直发数据，不需要对方回应
流式协议： TCP协议，可靠传输
数据报协议: UDP协议，不可传输

86. 什么是socket？简述基于tcp协议的套接字通信流程。
复制代码
复制代码
复制代码
Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。
在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，
对用户来说，一组简单的接口就是全部。

服务端：
创建socket对象，
绑定ip端口bind(), 
设置最大链接数listen(),  
accept()与客户端的connect()创建双向管道，等到联接， 
send(), recv(), 收发数据
close()

客户端：
创建socket对象，
connect()与服务端accept()创建双向管道 , 
 send(),
 recv(),
close()
复制代码
复制代码
复制代码

87. 什么是粘包？ socket 中造成粘包的原因是什什么？ 哪些情况会发生粘包现象？
复制代码
复制代码
复制代码
只有TCP有粘包现象，UDP永远不会粘包
粘包：在获取数据时,出现数据的内容不是本应该接收的数据,如:对方第一次发送hello,第二次发送world,
　　我方接收时,应该收两次,一次是hello,一次是world,但事实上是一次收到helloworld,一次收到空,这种现象叫粘包

原因
粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。

什么情况会发生：
1、发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包）

2、接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，
服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）
复制代码
复制代码
复制代码

88. IO多路复的作用？
socketserver，多个客户端连接，单线程下实现并发效果，就叫多路复用。

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。


89.select、poll、epoll 模型的区别？（属于多路复用IO的模型）
复制代码
复制代码
复制代码
都是i/o多路复用的机制，监视多个socket是否发生变化，本质上都是同步i/o
    select,poll实现需要自己不断轮询所有监测对象，直到对象发生变化，在这个阶段中，
可能要睡眠和唤醒多次交替，而epoll也需要调用epoll_wait不断轮询就绪链表，但是当对象发生变化时，
会调用回调函数，将变化的对象放入就绪链接表中，并唤醒在epoll_wait中进入睡眠的进程。
虽然都会睡眠和唤醒，但是select和poll在被唤醒的时候要遍历整个监测对象集合，
而epoll只要判断就绪链表是否为空即可，节省了大量cpu的时间
复制代码
复制代码
复制代码
复制代码
复制代码
复制代码
 select、poll、epoll都是IO多路复用的机制，但select，poll，epoll本质上都是同步I/O，
 因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的.

FD(文件描述符)
select模型
优点：
    1：可移植性好，在某些Unix系统不支持poll()
    2：对于超时值提供了更好的精度：微妙，而poll是毫秒
缺点：
    1:最大并发数限制，因为一个进程所打开的 FD （文件描述符）是有限制的，由 FD_SETSIZE 设置，默认值是 1024/2048 ，因此 Select 模型的最大并发数就被相应限制了。
    2：效率问题，select每次调用都会线性扫描全部的FD集合，所以将FD_SETSIZE 改大，会越慢
    3：需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。 

poll本质上和select 没有区别，它将用户传入的数组拷贝到内核空间，
它没有最大连接数的限制，原因是它基于链表来存储的但是同样有一个缺点：
大量的fd的数组被整体复制于用户态和内核地址空间，而不管这样的复制是不是有意义
复制代码
复制代码
复制代码

90. 什么是防火墙以及作用？
复制代码
复制代码
复制代码
防火墙是一个分离器、一个限制器，也是一个分析器，有效地监控了内部网和Internet之间的任何活动，保证了内部网络的安全

作用
防火墙是网络安全的屏障
可以强化网络安全策略
对网络存取和访问进行监控审计
防止内部信息的外泄
除了安全作用，防火墙还支持具有Internet服务特性的企业内部网络技术体系VPN（虚拟专用网）。
复制代码
复制代码
复制代码

91. 简述 进程、线程、协程的区别 以及应用场景？
复制代码
复制代码
复制代码
线程是指进程内的一个执行单元，
# 进程
进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
# 线程
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度
# 协程和线程
协程避免了无意义的调度，由此可以提高性能；但同时协程也失去了线程使用多CPU的能力

进程与线程的区别
（1）地址空间：线程是进程内的一个执行单位，进程内至少有一个线程，他们共享进程的地址空间，而进程有自己独立的地址空间
（2）资源拥有：进程是资源分配和拥有的单位，同一个进程内线程共享进程的资源
（3）线程是处理器调度的基本单位，但进程不是
（4）二者均可并发执行
（5）每个独立的线程有一个程序运行的入口

协程与线程
（1）一个线程可以有多个协程，一个进程也可以单独拥有多个协程，这样Python中则能使用多核CPU
（2）线程进程都是同步机制，而协程是异步
（3）协程能保留上一次调用时的状态
复制代码
复制代码
复制代码

92. GIL锁是什么？
GIL本质就是一把互斥锁，既然是互斥锁，所有互斥锁的本质都一样，都是将并发运行变成串行，以此来控制同一时间内共享数据只能被一个任务所修改，进而保证数据安全。

GIL保护的是解释器级的数据，保护用户自己的数据则需要自己加锁处理

复制代码
复制代码
复制代码
应用（总结）：
多线程用于IO密集型，如socket，爬虫，web
多进程用于计算密集型，如金融分析
  1. 每个cpython进程内都有一个GIL
  2. GIL导致同一进程内多个进程同一时间只能有一个运行
  3. 之所以有GIL，是因为Cpython的内存管理不是线程安全的
  4. 对于计算密集型用多进程，多IO密集型用多线程
复制代码
复制代码
复制代码

93. Python中如何使用线程池和进程池？


94. threading.local的作用？
实现线程局部变量的传递。

ThreadLocal 最常用的地方：
为每个线程绑定一个资源（数据库连接，HTTP请求，用户身份信息等），这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。

95. 进程之间如何进行通信？


96. 什么是并发和并行？
# 并发：同一时刻只能处理一个任务，但一个时段内可以对多个任务进行交替处理(一个处理器同时处理多个任务)
# 并行：同一时刻可以处理多个任务(多个处理器或者是多核的处理器同时处理多个不同的任务)
# 类比：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。 

97. 进程锁和线程锁的作用？


98. 解释什么是异步非阻塞？
复制代码
复制代码
复制代码
非阻塞：不等待
即：遇到IO阻塞不等待(setblooking=False),（可能会报错->捕捉异常）
        - sk=socket.socket()
        - sk.setblooking(False)
异步：回调，当达到某个指定的状态之后，自动调用特定函数

实例
nb_async.py   实现异步非阻塞的模块
复制代码
复制代码
复制代码
异步体现在回调上，回调就是有消息返回时告知一声儿进程进行处理。非阻塞就是不等待，不需要进程等待下去，继续执行其他操作，不管其他进程的状态。

99. 路由器和交换机的区别
复制代码
复制代码
复制代码
1：交换机：是负责内网里面的数据传递（arp协议）根据MAC地址寻址
   路由器：在网络层，路由器根据路由表，寻找该ip的网段
2：路由器可以处理TCP/IP协议
3：路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP。
   交换机可以把很多主机连起来，这些主机对外各有各的IP。
4：交换机是做端口扩展的，也就是让局域网可以连进来更多的电脑。
  路由器是用来做网络连接，也就是；连接不同的网络
复制代码
复制代码
复制代码

100.什么是域名解析？
在互联网上，所有的地址都是ip地址，现阶段主要是IPv4（比如：110.110.110.110）。
但是这些ip地址太难记了，所以就出现了域名（比如http://baidu.com）。
域名解析就是将域名，转换为ip地址的这样一种行为。

101.如何修改本地hosts件？
复制代码
复制代码
复制代码
Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，
当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，
一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。

浏览器访问网站，要首先通过DNS服务器把要访问的网站域名解析成一个唯一的IP地址，之后，浏览器才能对此网站进行定位并且访问其数据。

文件路径：C:\WINDOWS\system32\drivers\etc。
将127.0.0.1   www.163.com  添加在最下面
修改后用浏览器访问“www.163.com”会被解析到127.0.0.1，导致无法显示该网页。
复制代码
复制代码
复制代码

102.生产者消费者模型应用场景及优势？
复制代码
复制代码
复制代码
生产者与消费者模式是通过一个容器来解决生产者与消费者的强耦合关系，生产者与消费者之间不直接进行通讯，
而是利用阻塞队列来进行通讯，生产者生成数据后直接丢给阻塞队列，消费者需要数据则从阻塞队列获取，
实际应用中，生产者与消费者模式则主要解决生产者与消费者生产与消费的速率不一致的问题，达到平衡生产者与消费者的处理能力，而阻塞队列则相当于缓冲区。

应用场景：用户提交订单，订单进入引擎的阻塞队列中，由专门的线程从阻塞队列中获取数据并处理

优势：
1；解耦
假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。
将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。
2：支持并发
生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只能一直等着
而使用这个模型，生产者把制造出来的数据只需要放在缓冲区即可，不需要等待消费者来取

3：支持忙闲不均
缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。
当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。
复制代码
复制代码
复制代码

103.什么是cdn？
目的是使用户可以就近到服务器取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。

cdn 即内容分发网络

104.LVS是什么及作用？
复制代码
复制代码
复制代码
LVS ：Linux虚拟服务器
作用：LVS主要用于多服务器的负载均衡。
它工作在网络层，可以实现高性能，高可用的服务器集群技术。
它廉价，可把许多低性能的服务器组合在一起形成一个超级服务器。
它易用，配置非常简单，且有多种负载均衡的方法。
它稳定可靠，即使在集群的服务器中某台服务器无法正常工作，也不影响整体效果。另外可扩展性也非常好。
复制代码
复制代码
复制代码

105.Nginx是什么及作用？


106.keepalived是什么及作用?


107.haproxy是什么以及作用？

108.什么是负载均衡？


109.什么是rpc及应用场景？


110.简述 asynio模块的作用和应用场景。


111.简述 gevent模块的作用和应用场景。


112.twisted框架的使用和应用

回到顶部
数据库和缓存（46题）

113.列举常见的关系型数据库和非关系型都有那些？
复制代码
复制代码
复制代码
关系型数据库(需要有表结构)
    mysql、oracle 、 spl、server、db2、sybase

非关系型数据库（是以key-value存储的，没有表结构）（NoSQL）
 MongoDB
MongoDB 是一个高性能，开源，无模式的文档型数据库，开发语言是C++。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式。
 Redis
Redis 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。目前由VMware主持开发工作。
复制代码
复制代码
复制代码

114.MySQL常见数据库引擎及比较？
复制代码
复制代码
复制代码
InnoDB 
支持事务
支持表锁、行锁（for update）
表锁：select * from tb for update
行锁：select id,name from tb where id=2 for update

myisam
查询速度快
全文索引
支持表锁
表锁：select * from tb for update


NDB
高可用、 高性能、高可扩展性的数据库集群系统

Memory 
默认使用的是哈希索引
复制代码
复制代码
复制代码

115.简述数据库三大范式？
复制代码
复制代码
复制代码
 数据库的三大特性：
'实体':表
'属性'：表中的数据(字段)
'关系'：表与表之间的关系
----------------------------------------------------
# 数据库设计三大范式：
1：确保每列保持原子性（即数据库表中的所有字段值是不可分解的原子值）


2：确保表中的每列都是和主键相关（表中只能保存一种数据，不可以把多种数据保存在同一张表中）--->完全属于当前表的数据


3：确保每列都和主键直接相关，而不是间接相关（在一个数据库表中保存的数据只能与主键相关）----> 消除传递依赖（间接）
比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。
而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。
复制代码
复制代码
复制代码
复制代码
复制代码
复制代码
数据库五大约束'
    1.primary KEY:设置主键约束；
    2.UNIQUE：设置唯一性约束，不能有重复值；
3.DEFAULT 默认值约束    
4.NOT NULL：设置非空约束，该字段不能为空；
    5.FOREIGN key :设置外键约束。
复制代码
复制代码
复制代码

116、什么是事务？MySQL如何支持事务？
复制代码
复制代码
复制代码
事务用于将某些操作的多个SQL作为原子性操作，一旦有某一个出现错误，即可回滚到原来的状态，从而保证数据库数据完整性。


事务的特性： 
原子性: 确保工作单元内的所有操作都成功完成，否则事务将被中止在故障点，和以前的操作将回滚到以前的状态。
一致性: 确保数据库正确地改变状态后，成功提交的事务。
隔离性: 使事务操作彼此独立的和透明的。
持久性: 确保提交的事务的结果或效果的系统出现故障的情况下仍然存在。

Mysql实现事务
InnoDB支持事务，MyISAM不支持
    # 启动事务：
        # start transaction；
        # update from account set money=money-100 where name='a';
        # update from account set money=money+100 where name='b';
        # commit；
        'start transaction 手动开启事务，commit 手动关闭事务'
复制代码
复制代码
复制代码

117.简述数据库设计中一对多和多对多的应用场景？
FK(一对多)
下拉框里面的数据就需要用FK关联另一张表

M2M（多对多）
多选的下拉框，或者checkbox

118.如何基于数据库实现商城商品计数器？

119.常见SQL（必备）
复制代码
复制代码
复制代码
group by 分组对聚合的条件进行筛选需要通过havhing

SQL的left join 、right join、inner join之间的区别
left join (左连接) 返回包括左表中的所有记录和右表中联结字段相等的记录
right join(右连接) 返回包括右表中的所有记录1和左表中联结字段相等的记录
inner join（内连接）： 只返回两个表中联结字段相等的行
复制代码
复制代码
复制代码
https://www.cnblogs.com/wupeiqi/articles/5729934.html


120.简述触发器、函数、视图、存储过程？
复制代码
复制代码
复制代码
触发器：
对数据库某张表的增加、删除，修改前后定义一些操作

函数：(触发函数是通过select)
聚合函数：max/sum/min/avg
时间格式化：date_format
字符串拼接：concat

存储过程：
将SQL语句保存到数据库中，并命名，以后在代码调用时，直接调用名称即可
参数类型：
　　in    只将参数传进去
　　out   只拿结果
　　inout 既可以传，可以取

函数与存储过程区别：
本质上没区别。只是函数有如：只能返回一个变量的限制。而存储过程可以返回多个。而函数是可以嵌入在sql中使用的,可以在select中调用，而存储过程不行。

视图：
视图是一个虚拟表，不是真实存在的（只能查，不能改）
复制代码
复制代码
复制代码

121.MySQL索引种类
复制代码
复制代码
复制代码
单列
功能
   普通索引：加速查找
   唯一索引：加速查找 + 约束：不能重复（只能有一个空，不然就重复了）
   主键（primay key）：加速查找 + 约束：不能重复 +  不能为空
多列
　　联合索引（多个列创建索引）-----> 相当于单列的普通索引
　　联合唯一索引            -----> 相当于单列的唯一索引
　　ps：联合索引的特点：遵循最左前缀的规则
其他词语：
·· - 索引合并，利用多个单例索引查询；（例如在数据库查用户名和密码，分别给用户名和密码建立索引）
   - 覆盖索引，在索引表中就能将想要的数据查询到；
复制代码
复制代码
复制代码

122.索引在什么情况下遵循最左前缀的规则？
联合索引


123.主键和外键的区别？
主键是能确定一条记录的唯一标示。例如，身份证证号

外键：用于与另一张表的关联，是能确定另一张表记录的字段，用于保持数据的一致性
 	主键	外键
定义	唯一标识一条记录，不能有重复的，不允许为空	表的外键是另一张表的主键，外键可以有重复的，可以为空
作用	用来保证数据完整性	用来与其他表建立联系的
个数	主键只能有一个	一个表可以有多个外键
 

 

 

 

 


124.MySQL常见的函数？
复制代码
复制代码
复制代码
聚合函数
max/sum/min/avg

时间格式化
date_format

字符串拼接
concat（当拼接了null，则返回null）

截取字符串
substring

返回字节个数
length
复制代码
复制代码
复制代码

125.列举 创建索引但是无法命中索引的8种情况。
复制代码
复制代码
复制代码
1.- like '%xx'
    select * from tb1 where name like '%cn';
2.- 使用函数
    select * from tb1 where reverse(name) = 'wupeiqi';
3.- or
    select * from tb1 where nid = 1 or email = 'seven@live.com';
    特别的：当or条件中有未建立索引的列才失效，以下会走索引
            select * from tb1 where nid = 1 or name = 'seven';
            select * from tb1 where nid = 1 or email = 'seven@live.com' and name = 'alex'
4.- 类型不一致
    如果列是字符串类型，传入条件是必须用引号引起来，不然...
    select * from tb1 where name = 999;
5.- !=
    select * from tb1 where name != 'alex'
    特别的：如果是主键，则还是会走索引
        select * from tb1 where nid != 123
6.- >
    select * from tb1 where name > 'alex'
    特别的：如果是主键或索引是整数类型，则还是会走索引
        select * from tb1 where nid > 123
        select * from tb1 where num > 123
7.- order by
    select email from tb1 order by name desc;
    当根据索引排序时候，选择的映射如果不是索引，则不走索引
    特别的：如果对主键排序，则还是走索引：
        select * from tb1 order by nid desc;
 
8.- 组合索引最左前缀
    如果组合索引为：(name,email)
    name and email       -- 使用索引
    name                 -- 使用索引
    email                -- 不使用索引
复制代码
复制代码
复制代码

126.如何开启慢日志查询？
复制代码
复制代码
复制代码
修改配置文件
slow_query_log = OFF                            是否开启慢日志记录
long_query_time = 2                              时间限制，超过此时间，则记录
slow_query_log_file = /usr/slow.log        日志文件
log_queries_not_using_indexes = OFF     为使用索引的搜索是否记录

下面是开启
slow_query_log = ON
long_query_time = 2   
log_queries_not_using_indexes = OFF 
log_queries_not_using_indexes = ON

注：查看当前配置信息：
　　     show variables like '%query%'
     修改当前配置：
　　　　set global 变量名 = 值
复制代码
复制代码
复制代码

127.数据库导入导出命令（结构+数据）？
复制代码
复制代码
复制代码
导出现有数据库数据：（当有提示出入密码。-p就不用加密码）
  mysqldump -u用户名 -p密码 数据库名称 >导出文件路径           # 结构+数据
  mysqldump -u用户名 -p密码 -d 数据库名称 >导出文件    路径       # 结构 

导入现有数据库数据：
    mysqldump -uroot -p密码  数据库名称 < 文件路径  
复制代码
复制代码
复制代码

128.数据库优化方案？
复制代码
复制代码
复制代码
1、创建数据表时把固定长度的放在前面（）
2、将固定数据放入内存： 例如：choice字段 （django中有用到，数字1、2、3…… 对应相应内容）
3、char 和 varchar 的区别(char可变, varchar不可变 )
　　
4、联合索引遵循最左前缀(从最左侧开始检索)
5、避免使用 select * 
6、读写分离
　　　　- 实现：两台服务器同步数据
　　　　- 利用数据库的主从分离：主，用于删除、修改、更新；从，用于查；
读写分离:利用数据库的主从进行分离：主，用于删除、修改更新；从，用于查
7、分库
　　　　- 当数据库中的表太多，将某些表分到不同的数据库，例如：1W张表时
　　　　- 代价：连表查询
8、分表
　　　　- 水平分表：将某些列拆分到另外一张表，例如：博客+博客详情
　　　　- 垂直分表：讲些历史信息分到另外一张表中，例如：支付宝账单

9、加缓存
　　　　- 利用redis、memcache （常用数据放到缓存里，提高取数据速度）


如果只想获取一条数据
     - select * from tb where name=‘alex’ limit 1
复制代码
复制代码
复制代码

129.char和varchar的区别？
char 和 varchar 的区别(char可变, varchar不可变 )


130.简述MySQL的执行计划？
查看有没有命中索引，让数据库帮看看运行速度快不快
explain select * from table;


当type为all时，是为全表索引


131.在对name做了唯一索引前提下，简述以下区别：     
    select * from tb where name = ‘Oldboy-Wupeiqi’   
        select * from tb where name = ‘Oldboy-Wupeiqi’ limit 1

复制代码
复制代码
复制代码
是这样的的，用where条件过滤出符合条件的数据的同时，进行计数，
比如limit 1，那么在where过滤出第1条数据后，他就会直接把结果select出来返回给你，整个过程就结束了。

没做唯一索引的话,前者查询会全表扫描,效率低些
limit 1,只要找到对应一条数据,就不继续往下扫描.

然而 name 字段添加唯一索引了,加不加limit 1,意义都不大;

复制代码
复制代码
复制代码

132.1000w条数据，使用limit offset 分页时，为什么越往后翻越慢？如何解决？
复制代码
复制代码
复制代码
  答案一：
      先查主键，在分页。
      select * from tb where id in (
          select id from tb where limit 10 offset 30
      )
  答案二：
      按照也无需求是否可以设置只让用户看200页
      
  答案三：
      记录当前页  数据ID最大值和最小值
      在翻页时，根据条件先进行筛选；筛选完毕之后，再根据limit offset 查询。
      
      select * from (select * from tb where id > 22222222) as B limit 10 offset 0
      
      如果用户自己修改页码，也可能导致慢；此时对url种的页码进行加密（rest framework ）
复制代码
复制代码
复制代码

133.什么是索引合并？
复制代码
复制代码
复制代码
1、索引合并是把几个索引的范围扫描合并成一个索引。
2、索引合并的时候，会对索引进行并集，交集或者先交集再并集操作，以便合并成一个索引。
3、这些需要合并的索引只能是一个表的。不能对多表进行索引合并。

简单的说，索引合并，让一条sql可以使用多个索引。对这些索引取交集，并集，或者先取交集再取并集。
从而减少从数据表中取数据的次数，提高查询效率。
复制代码
复制代码
复制代码

134.什么是覆盖索引？
在索引表中就能将想要的数据查询到

135.简述数据库读写分离？
- 实现：两台服务器同步数据
　　　　- 利用数据库的主从分离：主，用于删除、修改、更新；从，用于查；
复制代码
复制代码
复制代码
方式一:是视图里面用using方式可以进行指定到哪个数据读写
from django.shortcuts import render,HttpResponse
from app01 import models
def index(request):

    models.UserType.objects.using('db1').create(title='普通用户')
　　# 手动指定去某个数据库取数据
    result = models.UserType.objects.all().using('db1')
    print(result)

    return HttpResponse('...')

方式二：写配置文件
class Router1:
　　#  指定到某个数据库取数据
    def db_for_read(self, model, **hints):
        """
        Attempts to read auth models go to auth_db.
        """
        if model._meta.model_name == 'usertype':
            return 'db1'
        else:
            return 'default'
　　　# 指定到某个数据库存数据
    def db_for_write(self, model, **hints):
        """
        Attempts to write auth models go to auth_db.
        """
        return 'default'
再写到配置
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    },
    'db1': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
DATABASE_ROUTERS = ['db_router.Router1',]
复制代码
复制代码
复制代码

136.简述数据库分库分表？（水平、垂直）
复制代码
复制代码
复制代码
 1、分库
    当数据库中的表太多，将某些表分到不同数据库，例如：1W张表时
    代价：连表查询跨数据库，代码变多
# 2、分表
    水平分表：将某些列拆分到另一张表，例如：博客+博客详情
    垂直分表：将某些历史信息，分到另外一张表中，例如：支付宝账单
复制代码
复制代码
复制代码

137.redis和memcached比较？
复制代码
复制代码
复制代码
区别
1：redis不仅支持简单的key_value类型，还支持字典，字符串，列表，集合，有序集合类型
2：内存使用效率对比，使用简单的key-value存储的话，
   Memcached的内存利用率更高而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。
3.性能对比：由于Redis只使用单核，而Memcached可以使用多核，.
   所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，
4.Redis虽然是基于内存的存储系统，但是它本身是支持内存数据的持久化的，而且提供两种主要的持久化策略：RDB快照和AOF日志。
   而memcached是不支持数据持久化操作的。
5.集群管理不同，Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。
复制代码
复制代码
复制代码

138.redis中数据库默认是多少个db 及作用？
Redis默认支持16个数据库，可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库
  
Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。

139.python操作redis的模块？
复制代码
复制代码
复制代码
- 连接
- 直接连接：
    import redis 
    r = redis.Redis(host='10.211.55.4', port=6379)
    r.set('foo', 'Bar')
    print r.get('foo')
- 连接池：
    import redis
    pool = redis.ConnectionPool(host='10.211.55.4', port=6379)
     
    r = redis.Redis(connection_pool=pool)
    r.set('foo', 'Bar')
    print r.get('foo')
复制代码
复制代码
复制代码

140.如果redis中的某个列表中的数据量非常大，如果实现循环显示每一个值？
复制代码
复制代码
复制代码
    - 如果一个列表在redis中保存了10w个值，我需要将所有值全部循环并显示，请问如何实现？
       一个一个取值，列表没有iter方法，但能自定义
　　　　 def list_scan_iter(name,count=3):
            start = 0
            while True:
                result = conn.lrange(name, start, start+count-1)
                start += count
                if not result:
                    break
                for item in result:
                    yield item

        for val in list_scan_iter('num_list'):
            print(val)
　　场景：投票系统，script-redis
复制代码
复制代码
复制代码

141.redis如何实现主从复制？以及数据同步机制？
复制代码
复制代码
复制代码
优势：
    - 高可用
    - 分担主压力
注意： 
    - slave设置只读


从的配置文件添加以下记录，即可：
    slaveof 1.1.1.1 3306 
复制代码
复制代码
复制代码

142.redis中的sentinel的作用？
复制代码
复制代码
复制代码
   帮助我们自动在主从之间进行切换
    检测主从中 主是否挂掉，且超过一半的sentinel检测到挂了之后才进行进行切换。
    如果主修复好了，再次启动时候，会变成从。

    启动主redis:
    redis-server /etc/redis-6379.conf  启动主redis
    redis-server /etc/redis-6380.conf  启动从redis
        
    在linux中：
        找到 /etc/redis-sentinel-8001.conf  配置文件，在内部：
            - 哨兵的端口 port = 8001
            - 主redis的IP，哨兵个数的一半/1
        
        找到 /etc/redis-sentinel-8002.conf  配置文件，在内部：
            - 哨兵的端口 port = 8002
            - 主redis的IP, 1 
    
        启动两个哨兵   
复制代码
复制代码
复制代码

143.如何实现redis集群？
复制代码
复制代码
复制代码
 redis集群、分片、分布式redis     
    redis-py-cluster
    集群方案：
        - redis cluster 官方提供的集群方案。
        - codis，豌豆荚技术团队。
        - tweproxy，Twiter技术团队。
    redis cluster的原理？
        - 基于分片来完成。
        - redis将所有能放置数据的地方创建了 16384 个哈希槽。
        - 如果设置集群的话，就可以为每个实例分配哈希槽：
            - 192.168.1.20【0-5000】
            - 192.168.1.21【5001-10000】
            - 192.168.1.22【10001-16384】
        - 以后想要在redis中写值时，
            set k1 123 
将k1通过crc16的算法，将k1转换成一个数字。然后再将该数字和16384求余，如果得到的余数 3000，那么就将该值写入到 192.168.1.20 实例中。
复制代码
复制代码
复制代码

144.redis中默认有多少个哈希槽？
16384


145.简述redis的有哪几种持久化策略及比较？
复制代码
复制代码
复制代码
RDB：每隔一段时间对redis进行一次持久化。
      - 缺点：数据不完整
      - 优点：速度快
AOF：把所有命令保存起来，如果想到重新生成到redis，那么就要把命令重新执行一次。
      - 缺点：速度慢，文件比较大
      - 优点：数据完整
复制代码
复制代码
复制代码

146.列举redis支持的过期策略。
复制代码
复制代码
复制代码
  voltile-lru：    从已设置过期时间的数据集（server.db[i].expires）中挑选最近频率最少数据淘汰
  volatile-ttl：   从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
  volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

  
  allkeys-lru：       从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
  allkeys-random：    从数据集（server.db[i].dict）中任意选择数据淘汰
  no-enviction（驱逐）：禁止驱逐数据
复制代码
复制代码
复制代码

147.MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中都是热点数据？ 
复制代码
复制代码
复制代码
  相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：

  volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
  volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
  volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
  allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
  allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
  no-enviction（驱逐）：禁止驱逐数据
复制代码
复制代码
复制代码

148.写代码，基于redis的列表实现 先进先出、后进先出队列、优先级队列。
复制代码
复制代码
复制代码
 参看script—redis源码
from scrapy.utils.reqser import request_to_dict, request_from_dict

  from . import picklecompat


  class Base(object):
      """Per-spider base queue class"""

      def __init__(self, server, spider, key, serializer=None):
          """Initialize per-spider redis queue.

          Parameters
          ----------
          server : StrictRedis
              Redis client instance.
          spider : Spider
              Scrapy spider instance.
          key: str
              Redis key where to put and get messages.
          serializer : object
              Serializer object with ``loads`` and ``dumps`` methods.

          """
          if serializer is None:
              # Backward compatibility.
              # TODO: deprecate pickle.
              serializer = picklecompat
          if not hasattr(serializer, 'loads'):
              raise TypeError("serializer does not implement 'loads' function: %r"
                              % serializer)
          if not hasattr(serializer, 'dumps'):
              raise TypeError("serializer '%s' does not implement 'dumps' function: %r"
                              % serializer)

          self.server = server
          self.spider = spider
          self.key = key % {'spider': spider.name}
          self.serializer = serializer

      def _encode_request(self, request):
          """Encode a request object"""
          obj = request_to_dict(request, self.spider)
          return self.serializer.dumps(obj)

      def _decode_request(self, encoded_request):
          """Decode an request previously encoded"""
          obj = self.serializer.loads(encoded_request)
          return request_from_dict(obj, self.spider)

      def __len__(self):
          """Return the length of the queue"""
          raise NotImplementedError

      def push(self, request):
          """Push a request"""
          raise NotImplementedError

      def pop(self, timeout=0):
          """Pop a request"""
          raise NotImplementedError

      def clear(self):
          """Clear queue/stack"""
          self.server.delete(self.key)


  class FifoQueue(Base):
      """Per-spider FIFO queue"""

      def __len__(self):
          """Return the length of the queue"""
          return self.server.llen(self.key)

      def push(self, request):
          """Push a request"""
          self.server.lpush(self.key, self._encode_request(request))

      def pop(self, timeout=0):
          """Pop a request"""
          if timeout > 0:
              data = self.server.brpop(self.key, timeout)
              if isinstance(data, tuple):
                  data = data[1]
          else:
              data = self.server.rpop(self.key)
          if data:
              return self._decode_request(data)


  class PriorityQueue(Base):
      """Per-spider priority queue abstraction using redis' sorted set"""

      def __len__(self):
          """Return the length of the queue"""
          return self.server.zcard(self.key)

      def push(self, request):
          """Push a request"""
          data = self._encode_request(request)
          score = -request.priority
          # We don't use zadd method as the order of arguments change depending on
          # whether the class is Redis or StrictRedis, and the option of using
          # kwargs only accepts strings, not bytes.
          self.server.execute_command('ZADD', self.key, score, data)

      def pop(self, timeout=0):
          """
          Pop a request
          timeout not support in this queue class
          """
          # use atomic range/remove using multi/exec
          pipe = self.server.pipeline()
          pipe.multi()
          pipe.zrange(self.key, 0, 0).zremrangebyrank(self.key, 0, 0)
          results, count = pipe.execute()
          if results:
              return self._decode_request(results[0])


  class LifoQueue(Base):
      """Per-spider LIFO queue."""

      def __len__(self):
          """Return the length of the stack"""
          return self.server.llen(self.key)

      def push(self, request):
          """Push a request"""
          self.server.lpush(self.key, self._encode_request(request))

      def pop(self, timeout=0):
          """Pop a request"""
          if timeout > 0:
              data = self.server.blpop(self.key, timeout)
              if isinstance(data, tuple):
                  data = data[1]
          else:
              data = self.server.lpop(self.key)

          if data:
              return self._decode_request(data)


  # TODO: Deprecate the use of these names.
  SpiderQueue = FifoQueue
  SpiderStack = LifoQueue
  SpiderPriorityQueue = PriorityQueue
复制代码
复制代码
复制代码

149.如何基于redis实现消息队列？
复制代码
复制代码
复制代码
# 通过发布订阅模式的PUB、SUB实现消息队列
# 发布者发布消息到频道了，频道就是一个消息队列。
# 发布者：
import redis
conn = redis.Redis(host='127.0.0.1',port=6379)
conn.publish('104.9MH', "hahahahahaha")
# 订阅者：
import redis
conn = redis.Redis(host='127.0.0.1',port=6379)
pub = conn.pubsub()
pub.subscribe('104.9MH')
while True:
    msg= pub.parse_response()
    print(msg)
对了，redis 做消息队列不合适
业务上避免过度复用一个redis，用它做缓存、做计算，还做任务队列，压力太大，不好。
复制代码
复制代码
复制代码

150.如何基于redis实现发布和订阅？以及发布订阅和消息队列的区别？
复制代码
复制代码
复制代码
   发布和订阅，只要有任务就给所有订阅者没人一份
  发布者：
      import redis

      conn = redis.Redis(host='127.0.0.1',port=6379)
      conn.publish('104.9MH', "hahaha")
  订阅者：
      import redis

      conn = redis.Redis(host='127.0.0.1',port=6379)
      pub = conn.pubsub()
      pub.subscribe('104.9MH')

      while True:
          msg= pub.parse_response()
          print(msg)
复制代码
复制代码
复制代码

151.什么是codis及作用？
 Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有明显的区别 
(不支持的命令列表), 上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作,
 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务.

152.什么是twemproxy及作用？
  是 Twtter 开源的一个 Redis 和 Memcache 代理服务器，主要用于管理 Redis 和 Memcached 集群，
减少与Cache 服务器直接连接的数量。

153.写代码实现redis事务操作。
复制代码
复制代码
复制代码
  import redis

  pool = redis.ConnectionPool(host='10.211.55.4', port=6379)

  conn = redis.Redis(connection_pool=pool)

  # pipe = r.pipeline(transaction=False)
  pipe = conn.pipeline(transaction=True)
  # 开始事务
  pipe.multi()

  pipe.set('name', 'bendere')
  pipe.set('role', 'sb')

  # 提交
  pipe.execute()
  
  注意：咨询是否当前分布式redis是否支持事务
复制代码
复制代码
复制代码

154.redis中的watch的命令的作用？
复制代码
复制代码
复制代码
  在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。
假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，
EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务执行失败。
  
  面试题：你如何控制剩余的数量不会出问题？
      方式一：- 通过redis的watch实现
          import redis
          conn = redis.Redis(host='127.0.0.1',port=6379)

          # conn.set('count',1000)
          val = conn.get('count')
          print(val)

          with conn.pipeline(transaction=True) as pipe:

              # 先监视，自己的值没有被修改过
              conn.watch('count')

              # 事务开始
              pipe.multi()
              old_count = conn.get('count')
              count = int(old_count)
              print('现在剩余的商品有:%s',count)
              input("问媳妇让不让买？")
              pipe.set('count', count - 1)

              # 执行，把所有命令一次性推送过去
              pipe.execute()
     方式二 - 数据库的锁 
复制代码
复制代码
复制代码

155.基于redis如何实现商城商品数量计数器？
复制代码
复制代码
复制代码
import redis

conn = redis.Redis(host='192.168.1.41',port=6379)

conn.set('count',1000)

with conn.pipeline() as pipe:

    # 先监视，自己的值没有被修改过
    conn.watch('count')

    # 事务开始
    pipe.multi()
    old_count = conn.get('count')
    count = int(old_count)
    if count > 0:  # 有库存
        pipe.set('count', count - 1)

    # 执行，把所有命令一次性推送过去
    pipe.execute()
复制代码
复制代码
复制代码

156.简述redis分布式锁和redlock的实现机制。
复制代码
复制代码
复制代码
在不同进程需要互斥地访问共享资源时，分布式锁是一种非常有用的技术手段。 
有很多三方库和文章描述如何用Redis实现一个分布式锁管理器，但是这些库实现的方式差别很大
，而且很多简单的实现其实只需采用稍微增加一点复杂的设计就可以获得更好的可靠性。 
用Redis实现分布式锁管理器的算法，我们把这个算法称为RedLock。

实现
- 写值并设置超时时间
- 超过一半的redis实例设置成功，就表示加锁完成。
- 使用：安装redlock-py 
from redlock import Redlock

dlm = Redlock(
    [
        {"host": "localhost", "port": 6379, "db": 0},
        {"host": "localhost", "port": 6379, "db": 0},
        {"host": "localhost", "port": 6379, "db": 0},
    ]
)

# 加锁，acquire
my_lock = dlm.lock("my_resource_name",10000)
if  my_lock:
    # J进行操作
    # 解锁,release
    dlm.unlock(my_lock)
else:
    print('获取锁失败')
复制代码
复制代码
复制代码
复制代码
复制代码
复制代码
 redis分布式锁？
# 不是单机操作，又多了一/多台机器
# redis内部是单进程、单线程，是数据安全的(只有自己的线程在操作数据)
----------------------------------------------------------------
\A、B、C，三个实例(主)
1、来了一个'隔壁老王'要操作，且不想让别人操作，so，加锁；
    加锁：'隔壁老王'自己生成一个随机字符串，设置到A、B、C里(xxx=666)
2、来了一个'邻居老李'要操作A、B、C，一读发现里面有字符串，擦，被加锁了，不能操作了，等着吧~
3、'隔壁老王'解决完问题，不用锁了，把A、B、C里的key：'xxx'删掉；完成解锁
4、'邻居老李'现在可以访问，可以加锁了
# 问题：
1、如果'隔壁老王'加锁后突然挂了，就没人解锁，就死锁了，其他人干看着没法用咋办？
2、如果'隔壁老王'去给A、B、C加锁的过程中，刚加到Ａ，'邻居老李'就去操作C了，加锁成功or失败？
3、如果'隔壁老王'去给A、B、C加锁时，C突然挂了，这次加锁是成功还是失败？
4、如果'隔壁老王'去给A、B、C加锁时，超时时间为5秒，加一个锁耗时3秒，此次加锁能成功吗？
# 解决
1、安全起见，让'隔壁老王'加锁时设置超时时间，超时的话就会自动解锁(删除key：'xxx')
2、加锁程度达到（1/2）+1个就表示加锁成功，即使没有给全部实例加锁；
3、加锁程度达到（1/2）+1个就表示加锁成功，即使没有给全部实例加锁；
4、不能成功，锁还没加完就过期，没有意义了，应该合理设置过期时间
# 注意
    使用需要安装redlock-py
----------------------------------------------------------------
from redlock import Redlock
dlm = Redlock(
    [
        {"host": "localhost", "port": 6379, "db": 0},
        {"host": "localhost", "port": 6379, "db": 0},
        {"host": "localhost", "port": 6379, "db": 0},
    ]
)
# 加锁，acquire
my_lock = dlm.lock("my_resource_name",10000)
if  my_lock:
    # 进行操作
    # 解锁,release
    dlm.unlock(my_lock)
else:
    print('获取锁失败')
\通过sever.eval(self.unlock_script)执行一个lua脚本，用来删除加锁时的key
复制代码
复制代码
复制代码

157.什么是一致性哈希？Python中是否有相应模块？
 一致性哈希
一致性hash算法（DHT）可以通过减少影响范围的方式，解决增减服务器导致的数据散列问题，从而解决了分布式环境下负载均衡问题；
如果存在热点数据，可以通过增添节点的方式，对热点区间进行划分，将压力分配至其他服务器，重新达到负载均衡的状态。
Python模块--hash_ring，即Python中的一致性hash

158.如何高效的找到redis中所有以aaa开头的key？
复制代码
复制代码
复制代码
redis 有一个keys命令。
# 语法：KEYS pattern
# 说明：返回与指定模式相匹配的所用的keys。
该命令所支持的匹配模式如下：
1、?：用于匹配单个字符。例如，h?llo可以匹配hello、hallo和hxllo等；
2、*：用于匹配零个或者多个字符。例如，h*llo可以匹配hllo和heeeello等；
2、[]：可以用来指定模式的选择区间。例如h[ae]llo可以匹配hello和hallo，但是不能匹配hillo。同时，可以使用“/”符号来转义特殊的字符
# 注意
KEYS 的速度非常快，但如果数据太大，内存可能会崩掉，
如果需要从一个数据集中查找特定的key，最好还是用Redis的集合结构(set)来代替。
复制代码
复制代码
复制代码
回到顶部
第四部分 前端、框架和其他（155题）

1.谈谈你对http协议的认识。
复制代码
复制代码
复制代码
　　浏览器本质,socket客户端遵循Http协议
　　HTTP协议本质：通过\r\n分割的规范+ 请求响应之后断开链接   ==  >  无状态、 短连接
具体：
　　Http协议是建立在tcp之上的，是一种规范，它规范定了发送的数据的数据格式，
然而这个数据格式是通过\r\n 进行分割的，请求头与请求体也是通过2个\r\n分割的，响应的时候，
响应头与响应体也是通过\r\n分割，并且还规定已请求已响应就会断开链接   
即--->  短连接、无状态
复制代码
复制代码
复制代码

2.谈谈你对websocket协议的认识。
复制代码
复制代码
复制代码
websocket是给浏览器新建的一套（类似与http）协议，协议规定：（\r\n分割）浏览器和服务器连接之后不断开，
　　　　以此完成：服务端向客户端主动推送消息。

websocket协议额外做的一些操作
握手  ---->  连接钱进行校验
加密  ----> payload_len=127/126/<=125   --> mask key 

复制代码
复制代码
复制代码
本质
创建一个连接后不断开的socket
当连接成功之后：
    客户端（浏览器）会自动向服务端发送消息，包含： Sec-WebSocket-Key: iyRe1KMHi4S4QXzcoboMmw==
    服务端接收之后，会对于该数据进行加密：base64(sha1(swk + magic_string))
    构造响应头：
            HTTP/1.1 101 Switching Protocols\r\n
            Upgrade:websocket\r\n
            Connection: Upgrade\r\n
            Sec-WebSocket-Accept: 加密后的值\r\n
            WebSocket-Location: ws://127.0.0.1:8002\r\n\r\n        
    发给客户端（浏览器）
建立：双工通道，接下来就可以进行收发数据
    发送数据是加密，解密，根据payload_len的值进行处理
        payload_len <= 125
        payload_len == 126
        payload_len == 127
    获取内容：
        mask_key
        数据
        根据mask_key和数据进行位运算，就可以把值解析出来。
复制代码
复制代码
复制代码
复制代码
复制代码
复制代码

 3.什么是magic string ？
 客户端向服务端发送消息时，会有一个'sec-websocket-key'和'magic string'的随机字符串(魔法字符串)
# 服务端接收到消息后会把他们连接成一个新的key串，进行编码、加密，确保信息的安全性

4.如何创建响应式布局？
复制代码
复制代码
复制代码
响应式布局是通过@media实现的
@media （min-width：768px）{
     .pg-header{
           background-color:green;
      }      
}
@media   (min-width:992px){
     .pg-header{
            background-color:pink;
     }
}    

代码
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Title</title>
    <style>
        body{
            margin: 0;
        }
        .pg-header{
            background-color: red;
            height: 48px;
        }

        @media (min-width: 768px) {
            .pg-header{
                background-color: aqua;
            }
        }
        @media (min-width: 992px) {
            .pg-header{
                background-color: blueviolet;
            }
        }
    </style>
</head>
<body>
    <div class="pg-header"></div>
</body>
</html>
复制代码
复制代码
复制代码

5.你曾经使用过哪些前端框架？
jQuery
- BootStrap
- Vue.js(与vue齐名的前端框架React和Angular)

6.什么是ajax请求？并使用jQuery和XMLHttpRequest对象实现一个ajax请求。
基于原生AJAX - Demo
基于jQueryAjax - Demo
http://www.cnblogs.com/wupeiqi/articles/5703697.html


7.如何在前端实现轮训？
复制代码
复制代码
复制代码
 轮询：通过定时器让程序每隔n秒执行一次操作。

复制代码
复制代码
复制代码
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Title</title>
</head>
<body>
    <h1>请选出最帅的男人</h1>
    <ul>
        {% for k,v in gg.items() %}
            <li>ID:{{ k }}, 姓名：{{ v.name }} ，票数：{{ v.count }}</li>
        {% endfor %}
    </ul>

    <script>
        setInterval(function () {
            location.reload();
        },2000)
    </script>
</body>
</html>
复制代码
复制代码
复制代码
复制代码
复制代码
复制代码

8.如何在前端实现长轮训？
复制代码
复制代码
复制代码
客户端向服务器发送请求，服务器接到请求后hang住连接，等待30秒，30s过后再重新发起请求，
直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。

复制代码
复制代码
复制代码
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Title</title>
</head>
<body>
    <h1>请选出最帅的男人</h1>
    <ul>
        {% for k,v in gg.items() %}
            <li style="cursor: pointer" id="user_{{ k }}" ondblclick="vote({{ k }});">ID:{{ k }}, 姓名：{{ v.name }} ，票数：<span>{{ v.count }}</span></li>
        {% endfor %}
    </ul>

    <script src="/static/jquery-3.3.1.min.js"></script>
    <script>
        $(function () {
            get_new_count();
        });
        
        function get_new_count() {
            $.ajax({
                url: '/get_new_count',
                type:'GET',
                dataType:'JSON',
                success:function (arg) {
                    if (arg.status){
                        // 更新票数
                        var gid = "#user_" + arg.data.gid;
                        $(gid).find('span').text(arg.data.count);
                    }else{
                        // 10s内没有人投票
                    }
                    get_new_count();

                }
            })
        }

        function vote(gid) {
            $.ajax({
                url: '/vote',
                type:'POST',
                data:{gid:gid},
                dataType:"JSON",
                success:function (arg) {

                }
            })
        }
    </script>
</body>
</html>
复制代码
复制代码
复制代码
复制代码
复制代码
复制代码

9.vuex的作用？
复制代码
复制代码
复制代码
多组件之间共享：vuex

补充luffyvue
1:router-link / router-view
2:双向绑定，用户绑定v-model
3：循环展示课程：v-for
4：路由系统，添加动态参数
5：cookie操作：vue-cookies
6：多组件之间共享：vuex
7：发送ajax请求：axios (js模块)
复制代码
复制代码
复制代码

10.vue中的路由的拦截器的作用？
 vue-resource的interceptors拦截器的作用正是解决此需求的妙方。
在每次http的请求响应之后，如果设置了拦截器如下，会优先执行拦截器函数，获取响应体，然后才会决定是否把response返回给then进行接收

11.axios的作用？
发送ajax请求：axios (js模块)

12.列举vue的常见指令。
复制代码
复制代码
复制代码
 1、v-if指令:判断指令，根据表达式值得真假来插入或删除相应的值。
  2、v-show指令:条件渲染指令，无论返回的布尔值是true还是false，元素都会存在在html中，只是false的元素会隐藏在html中，并不会删除.
  3、v-else指令:配合v-if或v-else使用。
  4、v-for指令:循环指令，相当于遍历。
  5、v-bind:给DOM绑定元素属性。
  6、v-on指令:监听DOM事件。
复制代码
复制代码
复制代码

13.简述jsonp及实现原理？
JSONP
jsonp是json用来跨域的一个东西。原理是通过script标签的跨域特性来绕过同源策略。
JSONP的简单实现模式，或者说是JSONP的原型：创建一个回调函数，然后在远程服务上调用这个函数并且将JSON 数据形式作为参数传递，
完成回调。 

14.什么是cors ？
复制代码
复制代码
复制代码
CORS
浏览器将CORS请求分成两类：简单请求和赋复杂请求

简单请求(同时满足以下两大条件)
（1）请求方法是以下三种方法之一:
HEAD
GET
POST
（2）HTTP的头信息不超出以下几种字段：
Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type  ：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

凡是不同时满足上面两个条件，就属于非简单请求
复制代码
复制代码
复制代码

15.列举Http请求中常见的请求方式？
复制代码
复制代码
复制代码
GET、POST、
PUT、patch（修改数据）
HEAD(类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头)
DELETE

传值代码f
Request.QueryString方法针对控件id
Request.Form方法针对控件名称name
复制代码
复制代码
复制代码

16.列举Http请求中的状态码？
复制代码
复制代码
复制代码
分类：
1**  信息，服务器收到请求，需要请求者继续执行操作
2**  成功，操作被成功接收并处理
3** 重定向，需要进一步的操作以完成请求
4** 客户端错误，请求包含语法错误或无法完成请求
5** 服务器错误，服务器在处理请求的过程中发生了错误

常见的状态码
200 -请求成功
202 -已接受请求，尚未处理
204 -请求成功，且不需返回内容
301 - 资源（网页等）被永久转移到其他url
400 - 请求的语义或是参数有错
403 - 服务器拒绝请求
404 - 请求资源（网页）不存在

500 - 内部服务器错误
502 - 网关错误，一般是服务器压力过大导致连接超时
503 - 由于超载或系统维护，服务器暂时的无法处理客户端的请求。
复制代码
复制代码
复制代码

17.列举Http请求中常见的请求头？
- user-agent
- host
- referer
- cookie 
- content-type 

18.看图写结果（js）：


 李杰


看图写结果（js）：


 武沛奇


看图写结果：（js）


 老男孩


看图写结果：（js）



 undefined


看图写结果：（js）


  武沛奇


看图写结果：（js）


 Alex


19.django、flask、tornado框架的比较？
复制代码
复制代码
复制代码
对于django，大而全的框架它的内部组件比较多，内部提供：ORM、Admin、中间件、Form、ModelForm、Session、
缓存、信号、CSRF；功能也都挺完善的

- flask，微型框架，内部组件就比较少了，但是有很多第三方组件来扩展它，
　　比如说有那个wtform（与django的modelform类似，表单验证）、flask-sqlalchemy（操作数据库的）、
　　flask-session、flask-migrate、flask-script、blinker可扩展强，第三方组件丰富。所以对他本身来说有那种短小精悍的感觉
- tornado，异步非阻塞。

django和flask的共同点就是，他们2个框架都没有写socket，所以他们都是利用第三方模块wsgi。
但是内部使用的wsgi也是有些不同的：django本身运行起来使用wsgiref，而flask使用werkzeug wsgi

还有一个区别就是他们的请求管理不太一样：django是通过将请求封装成request对象，再通过参数传递，而flask是通过上下文管理机制

Tornado

# 是一个轻量级的Web框架，异步非阻塞+内置WebSocket功能。

'目标'：通过一个线程处理N个并发请求(处理IO)。

'内部组件

    #内部自己实现socket

    #路由系统

    #视图

  #模板
　　 #cookie

    #csrf

复制代码
复制代码
复制代码

20.什么是wsgi？
复制代码
复制代码
复制代码
是web服务网关接口，是一套协议。
是通过以下模块实现了wsgi协议：
    - wsgiref
    - werkzurg
    - uwsgi   关于部署
以上模块本质：编写socket服务端，用于监听请求，当有请求到来，则将请求数据进行封装，然后交给web框架处理。
复制代码
复制代码
复制代码

21.django请求的生命周期？
用户请求进来先走到  wsgi   然后将请求交给  jango的中间件   穿过django中间件（方法是process_request）  
接着就是   路由匹配   路由匹配成功之后就执行相应的    视图函数   
在视图函数中可以调用orm做数据库操作  再从模板路径   将模板拿到   然后在后台进行模板渲染   
模板渲染完成之后就变成一个字符串     再把这个字符串经过所有中间件（方法：process_response）  和wsgi 返回给用户



22.列举django的内置组件？
复制代码
复制代码
复制代码
form 组件
- 对用户请求的数据进行校验
- 生成HTML标签

PS：
- form对象是一个可迭代对象。
- 问题：choice的数据如果从数据库获取可能会造成数据无法实时更新
        - 重写构造方法，在构造方法中重新去数据库获取值。
        - ModelChoiceField字段
            from django.forms import Form
            from django.forms import fields
            from django.forms.models import ModelChoiceField
            class UserForm(Form):
                name = fields.CharField(label='用户名',max_length=32)
                email = fields.EmailField(label='邮箱')
                ut_id = ModelChoiceField(queryset=models.UserType.objects.all())    
            
            依赖：
                class UserType(models.Model):
                    title = models.CharField(max_length=32)

                    def __str__(self):
                        return self.title
复制代码
复制代码
复制代码
复制代码
复制代码
复制代码
信号、
django的信号其实就是django内部为开发者预留的一些自定制功能的钩子。
只要在某个信号中注册了函数，那么django内部执行的过程中就会自动触发注册在信号中的函数。
如： 
pre_init # django的modal执行其构造方法前，自动触发
post_init # django的modal执行其构造方法后，自动触发
pre_save # django的modal对象保存前，自动触发
post_save # django的modal对象保存后，自动触发
场景:
在数据库某些表中添加数据时，可以进行日志记录。


CSRF、
目标：防止用户直接向服务端发起POST请求。
对所有的post请求做验证/ 将jango生成的一串字符串发送给我们，一种是从请求体发过来，一种是放在隐藏的标签里面用的是process_view　
方案：先发送GET请求时，将token保存到：cookie、Form表单中（隐藏的input标签），
以后再发送请求时只要携带过来即可。
 

ContentType 
contenttype是django的一个组件（app），
为我们找到django程序中所有app中的所有表并添加到记录中。
 可以使用他再加上表中的两个字段实现：一张表和N张表创建FK关系。 - 字段：表名称 - 字段：数据行ID 
应用：路飞表结构优惠券和专题课和学位课关联。
复制代码
复制代码
复制代码
中间件
对所有的请求进行批量处理，在视图函数执行前后进行自定义操作。
应用：用户登录校验
问题：为甚么不使用装饰器？
如果不使用中间件，就需要给每个视图函数添加装饰器，太繁琐
权限组件:
用户登录后，将权限放到session中，然后再每次请求进来在中间件里，根据当前的url去session中匹配，
判断当前用户是否有权限访问当前url,有权限就继续访问，没有就返回，
 （检查的东西就可以放到中间件中进行统一处理）在process_request方法里面做的，
　我们的中间件是放在session后面，因为中间件需要到session里面取数据
复制代码
复制代码
复制代码
session
cookie与session区别
（a）cookie是保存在浏览器端的键值对，而session是保存的服务器端的键值对，但是依赖cookie。
（也可以不依赖cookie，可以放在url，或请求头但是cookie比较方便）
（b）以登录为例，cookie为通过登录成功后，设置明文的键值对，并将键值对发送客户端存，明文信息可能存在泄漏，不安全；
　　session则是生成随机字符串，发给用户，并写到浏览器的cookie中，同时服务器自己也会保存一份。
（c）在登录验证时，cookie：根据浏览器发送请求时附带的cookie的键值对进行判断，如果存在，则验证通过；
　　session：在请求用户的cookie中获取随机字符串，根据随机字符串在session中获取其对应的值进行验证
复制代码
复制代码
复制代码
cors跨域（场景：前后端分离时，本地测试开发时使用）
如果网站之间存在跨域，域名不同，端口不同会导致出现跨域，但凡出现跨域，浏览器就会出现同源策略的限制
解决：在我们的服务端给我们响应数据，加上响应头---> 在中间件加的
复制代码
复制代码
复制代码
缓存/   
常用的数据放在缓存里面，就不用走视图函数，请求进来通过所有的process_request,会到缓存里面查数据，有就直接拿，
　　　　　　　　没有就走视图函数
　　　　　　关键点：1：执行完所有的process_request才去缓存取数据
　　　　　　　　　　2：执行完所有的process_response才将数据放到缓存

关于缓存问题
1:为什么放在最后一个process_request才去缓存
因为需要验证完用户的请求，才能返回数据

2:什么时候将数据放到缓存中
第一次走中间件，缓存没有数据，会走视图函数，取数据库里面取数据，
当走完process_response,才将数据放到缓存里，因为，走process_response的时候可能给我们的响应加处理

复制代码
复制代码
复制代码
为什么使用缓存
将常用且不太频繁修改的数据放入缓存。
以后用户再来访问，先去缓存查看是否存在，如果有就返回
否则，去数据库中获取并返回给用户（再加入到缓存，以便下次访问）

23.列举django中间件的5个方法？以及django中间件的应用场景？
process_request(self,request)  先走request 通过路由匹配返回
process_view(self, request, callback, callback_args, callback_kwargs) 再返回执行view
process_template_response(self,request,response)   当视图函数的返回值
process_exception(self, request, exception)  当视图函数的返回值对象中有render方法时，该方法才会被调用
process_response(self, request, response)
执行流程




24.简述什么是FBV和CBV？
复制代码
复制代码
复制代码
FBV 基于函数
# FBV 写法
# urls.py
 url(r'^login/$',views.login, name="login"),

# views.py
def login(request):
    if request.method == "POST":
        print(request.POST)

    return render(request,"login.html")

# HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>登录页面</title>
</head>
<body>
<form action="{% url 'login' %}" method="post" enctype="multipart/form-data">
    <input type="text" name="user2">
    <input type="file" name="file">
    <input type="submit" value="提交">


</form>
</body>
</html>

CBV 基于类
# urls.py    
url(r'^login/$',views.Login.as_view(), name="login"), 

# views.py
from django.views import View
class Login(View):   # 类首字母大写
    def get(self,request):
        return render(request,"login.html")
    def post(self,request):
        print(request.POST)
        return HttpResponse("OK")

加装饰器

=================================
class IndexView(View):
    
    # 如果是crsf相关，必须放在此处
    def dispach(self,request):
        # 通过反射执行post/get 
    
    @method_decoretor(装饰器函数)
    def get(self,request):
        pass
        
    def post(self,request):
        pass 
路由：IndexView.as_view()
复制代码
复制代码
复制代码

25.FBV与CBV的区别
- 没什么区别，因为他们的本质都是函数。CBV的.as_view()返回的view函数，view函数中调用类的dispatch方法，
在dispatch方法中通过反射执行get/post/delete/put等方法。D

非要说区别的话：
- CBV比较简洁，GET/POST等业务功能分别放在不同get/post函数中。FBV自己做判断进行区分。

26.django的request对象是在什么时候创建的？
当请求一个页面时, Django会建立一个包含请求元数据的 HttpRequest 对象. 
当Django 加载对应的视图时, HttpRequest对象将作为视图函数的第一个参数. 
每个视图会返回一个HttpResponse对象.

27.如何给CBV的程序添加装饰器？
复制代码
复制代码
复制代码
添加装饰器
方式一：
from django.views import View
from django.utils.decorators import method_decorator  ---> 需要引入memethod_decorator

def auth(func):
    def inner(*args,**kwargs):
        return func(*args,**kwargs)
    return inner

class UserView(View):
    @method_decorator(auth)
    def get(self,request,*args,**kwargs):
        return HttpResponse('...')    

方式二：
- csrf的装饰器要加到dispath前面
from django.views import View
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt,csrf_protect   ---> 需要引入 csrf_exempt


class UserView(View):
    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        return HttpResponse('...')

或者：
from django.views import View
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt,csrf_protect

@method_decorator(csrf_exempt,name='dispatch')  --->  指定名字
class UserView(View):
    def dispatch(self, request, *args, **kwargs):
        return HttpResponse('...')
复制代码
复制代码
复制代码

28.列举django orm 中所有的方法（QuerySet对象的所有方法）
复制代码
复制代码
复制代码
返回QuerySet对象的方法有：
      all()
      filter()
      exclude()
      order_by()
      reverse()
      distinct()
  特殊的QuerySet：
      values()       返回一个可迭代的字典序列
      values_list() 返回一个可迭代的元组序列
  返回具体对象的：
      get()
      first()
      last()
  返回布尔值的方法有：
      exists()
  返回数字的方法有：
      count() 
复制代码
复制代码
复制代码

29.only和defer的区别？
复制代码
复制代码
复制代码
 def defer(self, *fields):
    models.UserInfo.objects.defer('username','id')
    或
    models.UserInfo.objects.filter(...).defer('username','id')
    #映射中排除某列数据

 def only(self, *fields):
    #仅取某个表中的数据
     models.UserInfo.objects.only('username','id')
     或
     models.UserInfo.objects.filter(...).only('username','id')
复制代码
复制代码
复制代码

30.select_related和prefetch_related的区别？
复制代码
复制代码
复制代码
# 他俩都用于连表查询，减少SQL查询次数
\select_related
select_related主要针一对一和多对一关系进行优化，通过多表join关联查询，一次性获得所有数据，
存放在内存中，但如果关联的表太多，会严重影响数据库性能。
def index(request):
    obj = Book.objects.all().select_related("publisher")
    return render(request, "index.html", locals())
\prefetch_related
prefetch_related是通过分表，先获取各个表的数据，存放在内存中，然后通过Python处理他们之间的关联。
def index(request):
    obj = Book.objects.all().prefetch_related("publisher")
    return render(request, "index.html", locals())
复制代码
复制代码
复制代码
 

复制代码
复制代码
复制代码
def select_related(self, *fields)
     性能相关：表之间进行join连表操作，一次性获取关联的数据。
     model.tb.objects.all().select_related()
     model.tb.objects.all().select_related('外键字段')
     model.tb.objects.all().select_related('外键字段__外键字段')

def prefetch_related(self, *lookups)
    性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。
            # 获取所有用户表
            # 获取用户类型表where id in (用户表中的查到的所有用户ID)
            models.UserInfo.objects.prefetch_related('外键字段')

            from django.db.models import Count, Case, When, IntegerField
            Article.objects.annotate(
                numviews=Count(Case(
                    When(readership__what_time__lt=treshold, then=1),
                    output_field=CharField(),
                ))
            )

            students = Student.objects.all().annotate(num_excused_absences=models.Sum(
                models.Case(
                    models.When(absence__type='Excused', then=1),
                default=0,
                output_field=models.IntegerField()
            )))
复制代码
复制代码
复制代码
复制代码
复制代码
复制代码
# 1次SQL
# select * from userinfo
objs = UserInfo.obejcts.all()
for item in objs:
    print(item.name)
    
# n+1次SQL
# select * from userinfo
objs = UserInfo.obejcts.all()
for item in objs:
    # select * from usertype where id = item.id 
    print(item.name,item.ut.title)
    
select_related（）
# 1次SQL
# select * from userinfo inner join usertype on userinfo.ut_id = usertype.id 
objs = UserInfo.obejcts.all().select_related('ut')  连表查询
for item in objs:
    print(item.name,item.ut.title)
            
.prefetch_related()
    # select * from userinfo where id <= 8
    # 计算：[1,2]
    # select * from usertype where id in [1,2]
    objs = UserInfo.obejcts.filter(id__lte=8).prefetch_related('ut')
    for obj in objs:
        print(obj.name,obj.ut.title)
复制代码
复制代码
复制代码

31.filter和exclude的区别？
复制代码
复制代码
复制代码
  def filter(self, *args, **kwargs)
      # 条件查询(符合条件)
       # 查出符合条件
      # 条件可以是：参数，字典，Q

  def exclude(self, *args, **kwargs)
      # 条件查询(排除条件)
      # 排除不想要的
      # 条件可以是：参数，字典，Q
复制代码
复制代码
复制代码

32.列举django orm中三种能写sql语句的方法。
复制代码
复制代码
复制代码
原生SQL --->  connection
from django.db import connection, connections
cursor = connection.cursor()  # cursor = connections['default'].cursor()
cursor.execute("""SELECT * from auth_user where id = %s""", [1])
row = cursor.fetchone() # fetchall()/fetchmany(..)

靠近原生SQL-->extra\raw
extra
- extra
    def extra(self, select=None, where=None, params=None, tables=None, order_by=None, 
select_params=None)
        # 构造额外的查询条件或者映射，如：子查询
        Entry.objects.extra(select={'new_id': "select col from sometable where othercol > %s"},
 select_params=(1,))
        Entry.objects.extra(where=['headline=%s'], params=['Lennon'])
        Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])
        Entry.objects.extra(select={'new_id': "select id from tb where id > %s"}, s
elect_params=(1,), order_by=['-nid'])

- raw 
def raw(self, raw_query, params=None, translations=None, using=None):
    # 执行原生SQL
    models.UserInfo.objects.raw('select * from userinfo')
    # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名
    models.UserInfo.objects.raw('select id as nid,name as title  from 其他表')
    # 为原生SQL设置参数
    models.UserInfo.objects.raw('select id as nid from userinfo where nid>%s', params=[12,])
    # 将获取的到列名转换为指定列名
    name_map = {'first': 'first_name', 'last': 'last_name', 'bd': 'birth_date', 'pk': 'id'}
    Person.objects.raw('SELECT * FROM some_other_table', translations=name_map)
    # 指定数据库
    models.UserInfo.objects.raw('select * from userinfo', using="default")
复制代码
复制代码
复制代码

33.django orm 中如何设置读写分离？
复制代码
复制代码
复制代码
 方式一：手动使用queryset的using方法
from django.shortcuts import render,HttpResponse
from app01 import models
def index(request):

    models.UserType.objects.using('db1').create(title='普通用户')
　　# 手动指定去某个数据库取数据
    result = models.UserType.objects.all().using('db1')
    print(result)

    return HttpResponse('...')

方式二：写配置文件
class Router1:
　　#  指定到某个数据库取数据
    def db_for_read(self, model, **hints):
        """
        Attempts to read auth models go to auth_db.
        """
        if model._meta.model_name == 'usertype':
            return 'db1'
        else:
            return 'default'
　　　# 指定到某个数据库存数据
    def db_for_write(self, model, **hints):
        """
        Attempts to write auth models go to auth_db.
        """
        return 'default'
再写到配置
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    },
    'db1': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
DATABASE_ROUTERS = ['db_router.Router1',]
复制代码
复制代码
复制代码

34.F和Q的作用?
复制代码
复制代码
复制代码
  F:主要用来获取原数据进行计算。
  Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。
  修改操作也可以使用F函数,比如将每件商品的价格都在原价格的基础上增加10
from django.db.models import F
from app01.models import Goods
 
Goods.objects.update(price=F("price")+10)  # 对于goods表中每件商品的价格都在原价格的基础上增加10元
F查询专门对对象中某列值的操作，不可使用__双下划线！
Q:用来进行复杂查询
    Q查询可以组合使用 “&”, “|” 操作符，当一个操作符是用于两个Q的对象,它产生一个新的Q对象，
　　Q对象可以用 “~” 操作符放在前面表示否定，也可允许否定与不否定形式的组合。
　　Q对象可以与关键字参数查询一起使用，不过一定要把Q对象放在关键字参数查询的前面。

  Q(条件1) | Q(条件2) 或
  Q(条件1) & Q(条件2) 且
  Q(条件1) & ~Q(条件2) 非
复制代码
复制代码
复制代码

35.values和values_list的区别？
def values(self, *fields):
    # 获取每行数据为字典格式

def values_list(self, *fields, **kwargs):
    # 获取每行数据为元祖

36.如何使用django orm批量创建数据？
复制代码
复制代码
复制代码
def bulk_create(self, objs, batch_size=None):
    # 批量插入
    # batch_size表示一次插入的个数
    objs = [
        models.DDD(name='r11'),
        models.DDD(name='r22')
    ]
    models.DDD.objects.bulk_create(objs, 10)
复制代码
复制代码
复制代码

37.django的Form和ModeForm的作用？
复制代码
复制代码
复制代码
 - 作用：
      - 对用户请求数据格式进行校验
      - 自动生成HTML标签
  - 区别：
      - Form，字段需要自己手写。
          class Form(Form):
              xx = fields.CharField(.)
              xx = fields.CharField(.)
              xx = fields.CharField(.)
              xx = fields.CharField(.)
      - ModelForm，可以通过Meta进行定义
          class MForm(ModelForm):
              class Meta:
                  fields = "__all__"
                  model = UserInfo                            
  - 应用：只要是客户端向服务端发送表单数据时，都可以进行使用，如：用户登录注册
复制代码
复制代码
复制代码

38.django的Form组件中，如果字段中包含choices参数，请使用两种方式实现数据源实时更新。
复制代码
复制代码
复制代码
 方式一:重写构造方法，在构造方法中重新去数据库获取值
  class UserForm(Form):
      name = fields.CharField(label='用户名',max_length=32)
      email = fields.EmailField(label='邮箱')
      ut_id = fields.ChoiceField(
          # choices=[(1,'普通用户'),(2,'IP用户')]
          choices=[]
      )

      def __init__(self,*args,**kwargs):
          super(UserForm,self).__init__(*args,**kwargs)

          self.fields['ut_id'].choices = models.UserType.objects.all().values_list('id','title')
  
方式二: ModelChoiceField字段
  from django.forms import Form
  from django.forms import fields
  from django.forms.models import ModelChoiceField
  class UserForm(Form):
      name = fields.CharField(label='用户名',max_length=32)
      email = fields.EmailField(label='邮箱')
      ut_id = ModelChoiceField(queryset=models.UserType.objects.all())    

  依赖：
      class UserType(models.Model):
          title = models.CharField(max_length=32)

          def __str__(self):
              return self.title
复制代码
复制代码
复制代码

39.django的Model中的ForeignKey字段中的on_delete参数有什么作用？
复制代码
复制代码
复制代码
在django2.0后，定义外键和一对一关系的时候需要加on_delete选项，此参数为了避免两个表里的数据不一致问题，不然会报错：

TypeError: __init__() missing 1 required positional argument: 'on_delete'

 举例说明：

user=models.OneToOneField(User)

owner=models.ForeignKey(UserProfile)

需要改成：

user=models.OneToOneField(User,on_delete=models.CASCADE)          --在老版本这个参数（models.CASCADE）是默认值

owner=models.ForeignKey(UserProfile,on_delete=models.CASCADE)    --在老版本这个参数（models.CASCADE）是默认值
参数说明：

on_delete有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET()五个可选择的值

CASCADE：此值设置，是级联删除。
PROTECT：此值设置，是会报完整性错误。
SET_NULL：此值设置，会把外键设置为null，前提是允许为null。
SET_DEFAULT：此值设置，会把设置为外键的默认值。
SET()：此值设置，会调用外面的值，可以是一个函数。
一般情况下使用CASCADE就可以了。
复制代码
复制代码
复制代码

40.django中csrf的实现机制？
复制代码
复制代码
复制代码
目的：防止用户直接向服务端发起POST请求

- 用户先发送GET获取csrf token: Form表单中一个隐藏的标签 + token
- 发起POST请求时，需要携带之前发送给用户的csrf token；
- 在中间件的process_view方法中进行校验。

在html中添加{%csrf_token%}标签
复制代码
复制代码
复制代码

41.django如何实现websocket？
django中可以通过channel实现websocket

42.基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf token？
复制代码
复制代码
复制代码
//方式一给每个ajax都加上上请求头
    function Do1(){
        $.ajax({
            url:"/index/",
            data:{id:1},
            type:'POST',
　　　　　　　data:{csrfmiddlewaretoken:'{{ csrf_token }}',name:'alex'}
            success:function(data){
                console.log(data);
            }
        });
    }

方式二：需要先下载jQuery-cookie，才能去cookie中获取token
        function Do1(){
        $.ajax({
            url:"/index/",
            data:{id:1},
            type:'POST',
            headers:{
              'X-CSRFToken':$.cookie('csrftoken')  // 去cookie中获取
            },
            success:function(data){
                console.log(data);
            }
        });
    }

方式三：搞个函数ajaxSetup，当有多的ajax请求，即会执行这个函数
        $.ajaxSetup({
           beforeSend:function (xhr,settings) {
               xhr.setRequestHeader("X-CSRFToken",$.cookie('csrftoken'))
           } 
        });

函数版本
<body>
<input type="button" onclick="Do1();"  value="Do it"/>
<input type="button" onclick="Do2();"  value="Do it"/>
<input type="button" onclick="Do3();"  value="Do it"/>

<script src="/static/jquery-3.3.1.min.js"></script>
<script src="/static/jquery.cookie.js"></script>
<script>
    $.ajaxSetup({
        beforeSend: function(xhr, settings) {
            xhr.setRequestHeader("X-CSRFToken", $.cookie('csrftoken'));
        }
    });

     function Do1(){
        $.ajax({
            url:"/index/",
            data:{id:1},
            type:'POST',
            success:function(data){
                console.log(data);
            }
        });
    }

     function Do2(){
        $.ajax({
            url:"/index/",
            data:{id:1},
            type:'POST',
            success:function(data){
                console.log(data);
            }
        });
    }

     function Do3(){
        $.ajax({
            url:"/index/",
            data:{id:1},
            type:'POST',
            success:function(data){
                console.log(data);
            }
        });
    }
</script>
</body>
复制代码
复制代码
复制代码

43.django中如何实现orm表中添加数据时创建一条日志记录。
 给信号注册函数

复制代码
复制代码
复制代码
使用django的信号机制，可以在添加、删除数据前后设置日志记录
pre_init  # Django中的model对象执行其构造方法前,自动触发
post_init  # Django中的model对象执行其构造方法后,自动触发
pre_save  # Django中的model对象保存前,自动触发
post_save  # Django中的model对象保存后,自动触发
pre_delete  # Django中的model对象删除前,自动触发
post_delete  # Django中的model对象删除后,自动触发
复制代码
复制代码
复制代码

44.django缓存如何设置？
复制代码
复制代码
复制代码
jango中提供了6种缓存方式：
　　开发调试（不加缓存）
　　内存
　　文件
　　数据库
　　Memcache缓存（python-memcached模块）
　　Memcache缓存（pylibmc模块）

安装第三方组件支持redis：
　　django-redis组件


设置缓存
# 全站缓存（中间件）
MIDDLEWARE_CLASSES = (
    ‘django.middleware.cache.UpdateCacheMiddleware’, #第一
    'django.middleware.common.CommonMiddleware',
    ‘django.middleware.cache.FetchFromCacheMiddleware’, #最后
)
 
# 视图缓存
from django.views.decorators.cache import cache_page
import time
  
@cache_page(15)          #超时时间为15秒
def index(request):
   t=time.time()      #获取当前时间
   return render(request,"index.html",locals())
 
# 模板缓存
{% load cache %}
 <h3 style="color: green">不缓存:-----{{ t }}</h3>
  
{% cache 2 'name' %} # 存的key
 <h3>缓存:-----:{{ t }}</h3>
{% endcache %}
复制代码
复制代码
复制代码

45.django的缓存能使用redis吗？如果可以的话，如何配置？
复制代码
复制代码
复制代码
  pip install django-redis  
  apt-get install redis-serv

在setting添加配置文件
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache", # 缓存类型
        "LOCATION": "127.0.0.1:6379", # ip端口
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",  #
            "CONNECTION_POOL_KWARGS": {"max_connections": 100} # 连接池最大连接数
            # "PASSWORD": "密码",
        }
    }
}


使用
from django.shortcuts import render,HttpResponse
from django_redis import get_redis_connection
  
def index(request):
# 根据名字去连接池中获取连接
conn = get_redis_connection("default")
    conn.hset('n1','k1','v1') # 存数据
    return HttpResponse('...')
复制代码
复制代码
复制代码

46.django路由系统中name的作用？
复制代码
复制代码
复制代码
反向解析路由字符串
路由系统中name的作用：反向解析
url(r'^home', views.home, name='home')
在模板中使用：{ % url 'home' %}
在视图中使用：reverse(“home”）

复制代码
复制代码
复制代码

47.django的模板中filter和simple_tag的区别？
复制代码
复制代码
复制代码
filter : 类似管道,只能接受两个参数第一个参数是|前的数据

simple_tag : 类似函数
1、模板继承：{ % extends 'layouts.html' %}
2、自定义方法
    'filter'：只能传递两个参数，可以在if、for语句中使用
    'simple_tag'：可以无线传参，不能在if for中使用
    'inclusion_tags'：可以使用模板和后端数据
3、防xss攻击： '|safe'、'mark_safe'

复制代码
复制代码
复制代码

48.django-debug-toolbar的作用？
一、查看访问的速度、数据库的行为、cache命中等信息。 
二、尤其在Mysql访问等的分析上大有用处(sql查询速度)

49.django中如何实现单元测试？
对于每一个测试方法都会将setUp()和tearDown()方法执行一遍
会单独新建一个测试数据库来进行数据库的操作方面的测试，默认在测试完成后销毁。
在测试方法中对数据库进行增删操作，最后都会被清除。也就是说，在test_add中插入的数据，在test_add测试结束后插入的数据会被清除。
django单元测试时为了模拟生产环境，会修改settings中的变量，例如, 把DEBUG变量修改为True, 把ALLOWED_HOSTS修改为[*]。

50.解释orm中 db first 和 code first的含义？
db first: 先创建数据库，再更新表模型
code first：先写表模型，再更新数据库
https://www.cnblogs.com/jassin-du/p/8988897.html


51.django中如何根据数据库表生成model中的类？
1、修改seting文件，在setting里面设置要连接的数据库类型和名称、地址
2、运行下面代码可以自动生成models模型文件
       - python manage.py inspectdb
3、创建一个app执行下下面代码：
       - python manage.py inspectdb > app/models.py 

52.使用orm和原生sql的优缺点？
复制代码
复制代码
复制代码
SQL：
# 优点：
执行速度快
# 缺点：
编写复杂，开发效率不高
---------------------------------------------------------------------------
ORM：
# 优点：
让用户不再写SQL语句，提高开发效率
可以很方便地引入数据缓存之类的附加功能
# 缺点：
在处理多表联查、where条件复杂查询时，ORM的语法会变得复杂。
没有原生SQL速度快
复制代码
复制代码
复制代码

53.简述MVC和MTV
MVC：model、view(模块)、controller(视图)
MTV：model、tempalte、view 

54.django的contenttype组件的作用？
contenttype是django的一个组件(app)，它可以将django下所有app下的表记录下来
可以使用他再加上表中的两个字段,实现一张表和N张表动态创建FK关系。
   - 字段：表名称
   - 字段：数据行ID
应用：路飞表结构优惠券和专题课和学位课关联

55.谈谈你对restfull 规范的认识？
复制代码
复制代码
复制代码
restful其实就是一套编写接口的'协议'，规定如何编写以及如何设置返回值、状态码等信息。
# 最显著的特点：
# 用restful: 
    给用户一个url，根据method不同在后端做不同的处理
    比如：post创建数据、get获取数据、put和patch修改数据、delete删除数据。
# 不用restful: 
    给调用者很多url，每个url代表一个功能，比如：add_user/delte_user/edit_user/
# 当然，还有协议其他的，比如：
    '版本'来控制让程序有多个版本共存的情况，版本可以放在 url、请求头（accept/自定义）、GET参数
    '状态码'200/300/400/500
    'url中尽量使用名词'restful也可以称为“面向资源编程”
    'api标示'
        api.luffycity.com
        www.luffycity.com/api/
复制代码
复制代码
复制代码

56.接口的幂等性是什么意思？
复制代码
复制代码
复制代码
'一个接口通过1次相同的访问，再对该接口进行N次相同的访问时，对资源不造影响就认为接口具有幂等性。'
    GET，  #第一次获取结果、第二次也是获取结果对资源都不会造成影响，幂等。
    POST， #第一次新增数据，第二次也会再次新增，非幂等。
    PUT，  #第一次更新数据，第二次不会再次更新，幂等。
    PATCH，#第一次更新数据，第二次不会再次更新，非幂等。
    DELTE，#第一次删除数据，第二次不在再删除，幂等。
复制代码
复制代码
复制代码

57.什么是RPC？
'远程过程调用协议'
是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
进化的顺序: 现有的RPC,然后有的RESTful规范

58.Http和Https的区别？
复制代码
复制代码
复制代码
#Http: 80端口
#https: 443端口
# http信息是明文传输，https则是具有安全性的ssl加密传输协议。
#- 自定义证书 
    - 服务端：创建一对证书
    - 客户端：必须携带证书
#- 购买证书
    - 服务端： 创建一对证书，。。。。
    - 客户端： 去机构获取证书，数据加密后发给咱们的服务单
    - 证书机构:公钥给改机构
复制代码
复制代码
复制代码

59.为什么要使用django rest framework框架？
复制代码
复制代码
复制代码
# 在编写接口时可以不使用django rest framework框架，
# 不使用：也可以做，可以用django的CBV来实现，开发者编写的代码会更多一些。
# 使用：内部帮助我们提供了很多方便的组件，我们通过配置就可以完成相应操作，如：
    '序列化'可以做用户请求数据校验+queryset对象的序列化称为json
    '解析器'获取用户请求数据request.data，会自动根据content-type请求头的不能对数据进行解析
    '分页'将从数据库获取到的数据在页面进行分页显示。
     # 还有其他组件：
         '认证'、'权限'、'访问频率控制 
复制代码
复制代码
复制代码

60.django rest framework框架中都有那些组件？
复制代码
复制代码
复制代码
#- 路由，自动帮助开发者快速为一个视图创建4个url
        www.oldboyedu.com/api/v1/student/$
        www.oldboyedu.com/api/v1/student(?P<format>\w+)$
        www.oldboyedu.com/api/v1/student/(?P<pk>\d+)/$
        www.oldboyedu.com/api/v1/student/(?P<pk>\d+)(?P<format>\w+)$
#- 版本处理
    - 问题：版本都可以放在那里？
            - url
            - GET 
            - 请求头 
#- 认证 
    - 问题：认证流程？
#- 权限 
    - 权限是否可以放在中间件中？以及为什么？
#- 访问频率的控制
    匿名用户可以真正的防止？无法做到真正的访问频率控制，只能把小白拒之门外。
    如果要封IP，使用防火墙来做。
    登录用户可以通过用户名作为唯一标示进行控制，如果有人注册很多账号，则无法防止。
#- 视图
#- 解析器 ，根据Content-Type请求头对请求体中的数据格式进行处理。request.data 
#- 分页
#- 序列化
    - 序列化
        - source
        - 定义方法
    - 请求数据格式校验
#- 渲染器 
复制代码
复制代码
复制代码

61.django rest framework框架中的视图都可以继承哪些类
复制代码
复制代码
复制代码
a. 继承APIView（最原始）但定制性比较强
    这个类属于rest framework中的顶层类，内部帮助我们实现了只是基本功能：认证、权限、频率控制，
但凡是数据库、分页等操作都需要手动去完成，比较原始。
    class GenericAPIView(APIView)
    def post(...):
          pass 

b.继承GenericViewSet（ViewSetMixin，generics.GenericAPIView）
　　首先他的路由就发生变化
    如果继承它之后，路由中的as_view需要填写对应关系
　　在内部也帮助我们提供了一些方便的方法：
　　get_queryset
　　get_object
　　get_serializer
　　get_serializer_class
　　get_serializer_context
　　filter_queryset
注意：要设置queryset字段，否则会抛出断言的异常。

代码
只提供增加功能 只继承GenericViewSet

class TestView(GenericViewSet):
　　serialazer_class = xxx
　　def creat(self,*args,**kwargs):
　　　　pass  # 获取数据并对数据

c. 继承  modelviewset  --> 快速快发
　　　　-ModelViewSet(增删改查全有+数据库操作)
　　　　-mixins.CreateModelMixin（只有增）,GenericViewSet
　　　　-mixins.CreateModelMixin,DestroyModelMixin,GenericViewSet
　　对数据库和分页等操作不用我们在编写，只需要继承相关类即可。
　　
示例：只提供增加功能
class TestView(mixins.CreateModelMixin,GenericViewSet):
　　　　serializer_class = XXXXXXX
*** 
　　modelviewset --> 快速开发，复杂点的genericview、apiview
复制代码
复制代码
复制代码



62.简述 django rest framework框架的认证流程。
复制代码
复制代码
复制代码
- 如何编写？写类并实现authenticators
　　请求进来认证需要编写一个类，类里面有一个authenticators方法，我们可以自定义这个方法，可以定制3类返回值。
　　成功返回元组，返回none为匿名用户，抛出异常为认证失败。

源码流程：请求进来先走dispatch方法，然后封装的request对象会执行user方法，由user触发authenticators认证流程
- 方法中可以定义三种返回值：
    - （user,auth），认证成功
    - None , 匿名用户
    - 异常 ，认证失败
- 流程：
    - dispatch 
    - 再去request中进行认证处理
复制代码
复制代码
复制代码

63.django rest framework如何实现的用户访问频率控制？ 
复制代码
复制代码
复制代码
# 对匿名用户，根据用户IP或代理IP作为标识进行记录，为每个用户在redis中建一个列表
    {
        throttle_1.1.1.1:[1526868876.497521,152686885.497521...]，
        throttle_1.1.1.2:[1526868876.497521,152686885.497521...]，
        throttle_1.1.1.3:[1526868876.497521,152686885.497521...]，
    } 
 每个用户再来访问时，需先去记录中剔除过期记录，再根据列表的长度判断是否可以继续访问。
 '如何封IP'：在防火墙中进行设置
--------------------------------------------------------------------------
# 对注册用户，根据用户名或邮箱进行判断。
    {
        throttle_xxxx1:[1526868876.497521,152686885.497521...]，
        throttle_xxxx2:[1526868876.497521,152686885.497521...]，
        throttle_xxxx3:[1526868876.497521,152686885.497521...]，
    }
每个用户再来访问时，需先去记录中剔除过期记录，再根据列表的长度判断是否可以继续访问。
\如1分钟：40次，列表长度限制在40，超过40则不可访问
复制代码
复制代码
复制代码

64.Flask框架的优势？
Flask自由、灵活，可扩展性强，透明可控，第三方库的选择面广，
开发时可以结合最流行最强大的Python库，

65.Flask框架依赖组件
# 依赖jinja2模板引擎
# 依赖werkzurg协议

66.Flask蓝图的作用
# blueprint把实现不同功能的module分开.也就是把一个大的App分割成各自实现不同功能的module.
# 在一个blueprint中可以调用另一个blueprint的视图函数, 但要加相应的blueprint名.

67.列举使用的Flask第三方组件？
复制代码
复制代码
复制代码
# Flask组件
    flask-session  session放在redis
    flask-SQLAlchemy 如django里的ORM操作
    flask-migrate  数据库迁移
    flask-script  自定义命令
    blinker  信号-触发信号
# 第三方组件
    Wtforms 快速创建前端标签、文本校验
    dbutile     创建数据库连接池
    gevnet-websocket 实现websocket
# 自定义Flask组件
    自定义auth认证 
    参考flask-login组件
复制代码
复制代码
复制代码

68.简述Flask上下文管理流程?
复制代码
复制代码
复制代码
# a、简单来说，falsk上下文管理可以分为三个阶段：
　　1、'请求进来时'：将请求相关的数据放入上下问管理中
　　2、'在视图函数中'：要去上下文管理中取值
　　3、'请求响应'：要将上下文管理中的数据清除
# b、详细点来说：
　　1、'请求刚进来'：
        将request，session封装在RequestContext类中
        app，g封装在AppContext类中
        并通过LocalStack将requestcontext和appcontext放入Local类中
　　2、'视图函数中'：
        通过localproxy--->偏函数--->localstack--->local取值
　　3、'请求响应时'：
        先执行save.session()再各自执行pop(),将local中的数据清除
复制代码
复制代码
复制代码

69.Flask中的g的作用？
# g是贯穿于一次请求的全局变量，当请求进来将g和current_app封装为一个APPContext类，
# 再通过LocalStack将Appcontext放入Local中，取值时通过偏函数在LocalStack、local中取值；
# 响应时将local中的g数据删除：

Flask中上下文管理主要涉及到了那些相关的类？并描述类主要作用？
RequestContext  #封装进来的请求（赋值给ctx）
AppContext      #封装app_ctx
LocalStack      #将local对象中的数据维护成一个栈（先进后出）
Local           #保存请求上下文对象和app上下文对象

为什么要Flask把Local对象中的的值stack 维护成一个列表？
# 因为通过维护成列表，可以实现一个栈的数据结构，进栈出栈时只取一个数据，巧妙的简化了问题。
# 还有，在多app应用时，可以实现数据隔离；列表里不会加数据，而是会生成一个新的列表
# local是一个字典，字典里key（stack）是唯一标识，value是一个列表

Flask中多app应用是怎么完成？
复制代码
复制代码
复制代码
请求进来时，可以根据URL的不同，交给不同的APP处理。蓝图也可以实现。
    #app1 = Flask('app01')
    #app2 = Flask('app02')
    #@app1.route('/index')
    #@app2.route('/index2')
源码中在DispatcherMiddleware类里调用app2.__call__，
  原理其实就是URL分割，然后将请求分发给指定的app。
之后app也按单app的流程走。就是从app.__call__走。
复制代码
复制代码
复制代码

在Flask中实现WebSocket需要什么组件？
 gevent-websocket

wtforms组件的作用？
#快速创建前端标签、文本校验；如django的ModelForm

Flask框架默认session处理机制？
复制代码
复制代码
复制代码
# 前提:
    不熟的话:记不太清了,应该是……分两个阶段吧   
# 创建:
    当请求刚进来的时候,会将request和session封装成一个RequestContext()对象,
    接下来把这个对象通过LocalStack()放入内部的一个Local()对象中;
　　 因为刚开始 Local 的ctx中session是空的;
　　 所以,接着执行open_session,将cookie 里面的值拿过来,重新赋值到ctx中
    (Local实现对数据隔离,类似threading.local) 
# 销毁:
    最后返回时执行 save_session() 将ctx 中的session读出来进行序列化,写到cookie
    然后给用户,接着把 ctx pop掉
复制代码
复制代码
复制代码

解释Flask框架中的Local对象和threading.local对象的区别？
 

复制代码
复制代码
复制代码
# a.threading.local
作用：为每个线程开辟一块空间进行数据存储(数据隔离)。

问题：自己通过字典创建一个类似于threading.local的东西。
storage = {
   4740: {val: 0},
   4732: {val: 1},
   4731: {val: 3},
   }

# b.自定义Local对象
作用：为每个线程(协程)开辟一块空间进行数据存储(数据隔离)。
class Local(object):
   def __init__(self):
      object.__setattr__(self, 'storage', {})
   def __setattr__(self, k, v):
      ident = get_ident()
      if ident in self.storage:
         self.storage[ident][k] = v
      else:
         self.storage[ident] = {k: v}
   def __getattr__(self, k):
      ident = get_ident()
      return self.storage[ident][k]
obj = Local()
def task(arg):
   obj.val = arg
   obj.xxx = arg
   print(obj.val)
for i in range(10):
   t = Thread(target=task, args=(i,))
   t.start()
复制代码
复制代码
复制代码

Flask中 blinker 是什么？
复制代码
复制代码
复制代码
# flask中的信号blinker
信号主要是让开发者可是在flask请求过程中定制一些行为。
或者说flask在列表里面预留了几个空列表，在里面存东西。
简言之，信号允许某个'发送者'通知'接收者'有事情发生了
@ before_request有返回值，blinker没有返回值

# 10个信号

request_started = _signals.signal('request-started') #请求到来前执行

request_finished = _signals.signal('request-finished') #请求结束后执行

before_render_template = _signals.signal('before-render-template')#模板渲染前执行

template_rendered = _signals.signal('template-rendered')#模板渲染后执行

got_request_exception = _signals.signal('got-request-exception') #请求执行出现异常时执行

request_tearing_down = _signals.signal('request-tearing-down')#请求执行完毕后自动执行（无论成功与否）

appcontext_tearing_down = _signals.signal('appcontext-tearing-down')# 请求上下文执行完毕后自动执行（无论成功与否）

appcontext_pushed = _signals.signal('appcontext-pushed') #请求app上下文push时执行

appcontext_popped = _signals.signal('appcontext-popped') #请求上下文pop时执行

message_flashed = _signals.signal('message-flashed')#调用flask在其中添加数据时，自动触发

复制代码
复制代码
复制代码

SQLAlchemy中的 session和scoped_session 的区别？
复制代码
复制代码
复制代码
# Session：
由于无法提供线程共享功能，开发时要给每个线程都创建自己的session
打印sesion可知他是sqlalchemy.orm.session.Session的对象
# scoped_session：
为每个线程都创建一个session，实现支持线程安全
在整个程序运行的过程当中，只存在唯一的一个session对象。
创建方式:
   通过本地线程Threading.Local()
   # session=scoped_session(Session)
   创建唯一标识的方法(参考flask请求源码)
复制代码
复制代码
复制代码

SQLAlchemy如何执行原生SQL？
# 使用execute方法直接操作SQL语句(导入create_engin、sessionmaker)
engine=create_engine('mysql://root:*****@127.0.0.1/database?charset=utf8')
DB_Session = sessionmaker(bind=engine)
session = DB_Session()
session.execute('alter table mytablename drop column mycolumn ;')

ORM的实现原理？
# ORM的实现基于一下三点
映射类：描述数据库表结构，
映射文件：指定数据库表和映射类之间的关系
数据库配置文件：指定与数据库连接时需要的连接信息(数据库、登录用户名、密码or连接字符串)

DBUtils模块的作用？
复制代码
复制代码
复制代码
# 数据库连接池
使用模式：
1、为每个线程创建一个连接，连接不可控，需要控制线程数
2、创建指定数量的连接在连接池，当线程访问的时候去取，不够了线程排队，直到有人释放(推荐)
---------------------------------------------------------------------------
两种写法：
1、用静态方法装饰器，通过直接执行类的方法来连接使用数据库
2、通过实例化对象，通过对象来调用方法执行语句
https://www.cnblogs.com/ArmoredTitan/p/Flask.html
复制代码
复制代码
复制代码
以下SQLAlchemy的字段是否正确？如果不正确请更正：

fromdatetime importdatetime

 fromsqlalchemy.ext.declarative

importdeclarative_base

 fromsqlalchemy importColumn, Integer, String, DateTime

  

Base =declarative_base()  

classUserInfo(Base):    

    __tablename__ ='userinfo'    

    id=Column(Integer, primary_key=True, autoincrement=True) 

    name =Column(String(64), unique=True) 

    ctime =Column(DateTime, default=datetime.now())

复制代码
复制代码
复制代码
from datetime import datetime
from sqlalchemy.ext.declarative
import declarative_base
from sqlalchemy import Column, Integer, String, DateTime

Base = declarative_base()
class UserInfo(Base):
    __tablename__ = 'userinfo'   
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(64), unique=True)
ctime = Column(DateTime, default=datetime.now())
-----------------------------------------------------------------------
不正确：
    Ctime字段中参数应为’default=datetime.now’
    now 后面不应该加括号，加了的话，字段不会实时更新。
复制代码
复制代码
复制代码

SQLAchemy中如何为表设置引擎和字符编码？
sqlalchemy设置编码字符集，一定要在数据库访问的URL上增加'charset=utf8'
否则数据库的连接就不是'utf8'的编码格式

eng=create_engine('mysql://root:root@localhost:3306/test2?charset=utf8',echo=True)
复制代码
复制代码
复制代码
1. 设置引擎编码方式为utf8。

    engine = create_engine("mysql+pymysql://root:123456@127.0.0.1:3306/sqldb01?charset=utf8")
2. 设置数据库表编码方式为utf8

class UserType(Base):
    __tablename__ = 'usertype'
    id = Column(Integer, primary_key=True)
    caption = Column(String(50), default='管理员')
    # 添加配置设置编码
    __table_args__ = {
        'mysql_charset':'utf8'
    }

这样生成的SQL语句就自动设置数据表编码为utf8了,__table_args__还可设置存储引擎、外键约束等等信息。
复制代码
复制代码
复制代码

SQLAchemy中如何设置联合唯一索引？
通过'UniqueConstraint'字段来设置联合唯一索引
__table_args=(UniqueConstraint('h_id','username',name='_h_username_uc'))
#h_id和username组成联合唯一约束

简述Tornado框架的特点。
异步非阻塞+websocket

简述Tornado框架中Future对象的作用？
复制代码
复制代码
复制代码
# 实现异步非阻塞
视图函数yield一个futrue对象，futrue对象默认：
    self._done = False   ，请求未完成
    self._result = None  ，请求完成后返回值，用于传递给回调函数使用。

tornado就会一直去检测futrue对象的_done是否已经变成True。

如果IO请求执行完毕，自动会调用future的set_result方法：
            self._result = result
            self._done = True
参考：http://www.cnblogs.com/wupeiqi/p/6536518.html（自定义异步非阻塞web框架）
复制代码
复制代码
复制代码

Tornado框架中如何编写WebSocket程序？
复制代码
复制代码
复制代码
Tornado在websocket模块中提供了一个WebSocketHandler类。
这个类提供了和已连接的客户端通信的WebSocket事件和方法的钩子。
当一个新的WebSocket连接打开时，open方法被调用，
而on_message和on_close方法，分别在连接、接收到新的消息和客户端关闭时被调用。

此外，WebSocketHandler类还提供了write_message方法用于向客户端发送消息，close方法用于关闭连接。
复制代码
复制代码
复制代码

Tornado中静态文件是如何处理的？ 如： <link href="{{static_url("commons.css")}}" rel="stylesheet" />
复制代码
复制代码
复制代码
# settings.py
settings = {
    "static_path": os.path.join(os.path.dirname(__file__), "static"),
   # 指定了静态文件的位置在当前目录中的"static"目录下
    "cookie_secret": "61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=",
    "login_url": "/login",
    "xsrf_cookies": True,
}

经上面配置后
static_url()自动去配置的路径下找'commons.css'文件
复制代码
复制代码
复制代码

Tornado操作MySQL使用的模块？
torndb
torndb是基于mysqldb的再封装，所以使用时要先安装myqldb

Tornado操作redis使用的模块？
tornado-redis

简述Tornado框架的适用场景？
web聊天室，在线投票

git常见命令作用：
复制代码
复制代码
复制代码
# git init
    初始化，当前所在的文件夹可以被管理且以后版本相关的数据都会存储到.git文件中
# git status
    查看当前文件夹以及子目录中文件是否发生变化：
    内容修改/新增文件/删除，已经变化的文件会变成红色，已经add的文件会变成绿色
# git add .
    给发生变化的文件（贴上一个标签）或 将发生变化的文件放到某个地方，
    只写一个句点符就代表把git status中红色的文件全部打上标签
# git commit -m
    新增用户登录认证功能以及xxx功能将“绿色”文件添加到版本中
# git log
    查看所有版本提交记录，可以获取版本号
# git reset --hard 版本号   
    将最新的版本回退到更早的版本
# git reflog   
    回退到之前版本后悔了，再更新到最新或者最新之前的版本
# git reset --hard 版本 回退
复制代码
复制代码
复制代码

简述以下git中stash命令作用以及相关其他命令。
复制代码
复制代码
复制代码
'git stash'：将当前工作区所有修改过的内容存储到“某个地方”，将工作区还原到当前版本未修改过的状态
'git stash list'：查看“某个地方”存储的所有记录
'git stash clear'：清空“某个地方”
'git stash pop'：将第一个记录从“某个地方”重新拿到工作区（可能有冲突）
'git stash apply'：编号, 将指定编号记录从“某个地方”重新拿到工作区（可能有冲突） 
'git stash drop'：编号，删除指定编号的记录
复制代码
复制代码
复制代码

git 中 merge 和 rebase命令 的区别。
复制代码
复制代码
复制代码
merge：
会将不同分支的提交合并成一个新的节点，之前的提交分开显示，
注重历史信息、可以看出每个分支信息，基于时间点,遇到冲突,手动解决,再次提交
rebase：
将两个分支的提交结果融合成线性，不会产生新的节点;
注重开发过程，遇到冲突，手动解决，继续操作
复制代码
复制代码
复制代码

公司如何基于git做的协同开发？
复制代码
复制代码
复制代码
1、你们公司的代码review分支怎么做？谁来做？
答：组长创建review分支，我们小功能开发完之后，合并到review分支交给老大（小组长）来看，
1.1、你组长不开发代码吗？
        他开发代码，但是它只开发核心的东西，任务比较少。
        或者抽出时间，我们一起做这个事情
2、你们公司协同开发是怎么协同开发的？
每个人都有自己的分支，阶段性代码完成之后，合并到review，然后交给老大看
--------------------------------------------------------------------------
# 大致工作流程
公司：
    下载代码
        git clone https://gitee.com/wupeiqi/xianglong.git
        或创建目录 
        cd 目录 
        git init 
        git remote add origin https://gitee.com/wupeiqi/xianglong.git
        git pull origin maste 
    创建dev分支
        git checkout dev 
        git pull origin dev 
        继续写代码
        git add . 
        git commit -m '提交记录'
        git push origin dev 
回家： 
    拉代码：
        git pull origin dev 
    继续写：
        继续写代码
        git add . 
        git commit -m '提交记录'
        git push origin dev 
复制代码
复制代码
复制代码

如何基于git实现代码review？
https://blog.csdn.net/june_y/article/details/50817993

git如何实现v1.0 、v2.0 等版本的管理？
在命令行中，使用“git tag –a tagname –m “comment”可以快速创建一个标签。
需要注意，命令行创建的标签只存在本地Git库中，还需要使用Git push –tags指令发布到服务器的Git库中

什么是gitlab
gitlab是公司自己搭建的项目代码托管平台

github和gitlab的区别？
1、gitHub是一个面向开源及私有软件项目的托管平台
(创建私有的话，需要购买，最低级的付费为每月7刀，支持5个私有项目)
2、gitlab是公司自己搭建的项目托管平台

如何为github上牛逼的开源项目贡献代码？
复制代码
复制代码
复制代码
1、fork需要协作项目
2、克隆/关联fork的项目到本地
3、新建分支（branch）并检出（checkout）新分支
4、在新分支上完成代码开发
5、开发完成后将你的代码合并到master分支
6、添加原作者的仓库地址作为一个新的仓库地址
7、合并原作者的master分支到你自己的master分支,用于和作者仓库代码同步
8、push你的本地仓库到GitHub
9、在Github上提交 pull requests
10、等待管理员（你需要贡献的开源项目管理员）处理
复制代码
复制代码
复制代码

git中 .gitignore文件的作用
一般来说每个Git项目中都需要一个“.gitignore”文件，
这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。

实际项目中，很多文件都是不需要版本管理的，比如Python的.pyc文件和一些包含密码的配置文件等等。

什么是敏捷开发？
'敏捷开发'：是一种以人为核心、迭代、循序渐进的开发方式。

它并不是一门技术，而是一种开发方式，也就是一种软件开发的流程。
它会指导我们用规定的环节去一步一步完成项目的开发。
因为它采用的是迭代式开发，所以这种开发方式的主要驱动核心是人

简述 jenkins 工具的作用?
'Jenkins'是一个可扩展的持续集成引擎。

主要用于：
   持续、自动地构建/测试软件项目。
   监控一些定时执行的任务。

公司如何实现代码发布？
nginx+uwsgi+django

简述 RabbitMQ、Kafka、ZeroMQ的区别？
https://blog.csdn.net/zhailihua/article/details/7899006

RabbitMQ如何在消费者获取任务后未处理完前就挂掉时，保证数据不丢失？
复制代码
复制代码
复制代码
为了预防消息丢失，rabbitmq提供了ack
即工作进程在收到消息并处理后，发送ack给rabbitmq，告知rabbitmq这时候可以把该消息从队列中删除了。
如果工作进程挂掉 了，rabbitmq没有收到ack，那么会把该消息 重新分发给其他工作进程。
不需要设置timeout，即使该任务需要很长时间也可以处理。

ack默认是开启的，工作进程显示指定了no_ack=True
复制代码
复制代码
复制代码

RabbitMQ如何对消息做持久化？
复制代码
复制代码
复制代码
1、创建队列和发送消息时将设置durable=Ture，如果在接收到消息还没有存储时，消息也有可能丢失，就必须配置publisher confirm
    channel.queue_declare(queue='task_queue', durable=True)

2、返回一个ack，进程收到消息并处理完任务后，发给rabbitmq一个ack表示任务已经完成，可以删除该任务

3、镜像队列：将queue镜像到cluster中其他的节点之上。
在该实现下，如果集群中的一个节点失效了，queue能自动地切换到镜像中的另一个节点以保证服务的可用性
复制代码
复制代码
复制代码

RabbitMQ如何控制消息被消费的顺序？
默认消息队列里的数据是按照顺序被消费者拿走，
例如：消费者1 去队列中获取奇数序列的任务，消费者2去队列中获取偶数序列的任务。

channel.basic_qos(prefetch_count=1) 
表示谁来谁取，不再按照奇偶数排列（同时也保证了公平的消费分发）

以下RabbitMQ的exchange type分别代表什么意思？如：fanout、direct、topic。
复制代码
复制代码
复制代码
amqp协议中的核心思想就是生产者和消费者隔离，生产者从不直接将消息发送给队列。
生产者通常不知道是否一个消息会被发送到队列中，只是将消息发送到一个交换机。
先由Exchange来接收，然后Exchange按照特定的策略转发到Queue进行存储。
同理，消费者也是如此。Exchange 就类似于一个交换机，转发各个消息分发到相应的队列中。
--------------------------------------------------
type=fanout 类似发布者订阅者模式，会为每一个订阅者创建一个队列，而发布者发布消息时，会将消息放置在所有相关队列中
type=direct 队列绑定关键字，发送者将数据根据关键字发送到消息exchange，exchange根据 关键字 判定应该将数据发送至指定队列。
type=topic  队列绑定几个模糊的关键字，之后发送者将数据发送到exchange，exchange将传入”路由值“和 ”关键字“进行匹配，匹配成功，
则将数据发送到指定队列。
---------------------------------------------------
发送者路由值              队列中
old.boy.python          old.*  -- 不匹配    *表示匹配一个
old.boy.python          old.#  -- 匹配      #表示匹配0个或多个
复制代码
复制代码
复制代码

简述 celery 是什么以及应用场景？
# Celery是由Python开发的一个简单、灵活、可靠的处理大量任务的分发系统，
# 它不仅支持实时处理也支持任务调度。
# http://www.cnblogs.com/wupeiqi/articles/8796552.html

简述celery运行机制。
 


celery如何实现定时任务？
复制代码
复制代码
复制代码
# celery实现定时任务
启用Celery的定时任务需要设置CELERYBEAT_SCHEDULE 。 
CELERYBEAT_SCHEDULE='djcelery.schedulers.DatabaseScheduler'#定时任务
'创建定时任务'
# 通过配置CELERYBEAT_SCHEDULE：
#每30秒调用task.add
from datetime import timedelta
CELERYBEAT_SCHEDULE = {
    'add-every-30-seconds': {
        'task': 'tasks.add',
        'schedule': timedelta(seconds=30),
        'args': (16, 16)
    },
}
复制代码
复制代码
复制代码

简述 celery多任务结构目录
复制代码
复制代码
复制代码
pro_cel
    ├── celery_tasks     # celery相关文件夹
    │   ├── celery.py    # celery连接和配置相关文件
    │   └── tasks.py     #  所有任务函数
    ├── check_result.py  # 检查结果
    └── send_task.py     # 触发任务
复制代码
复制代码
复制代码

celery中装饰器 @app.task 和 @shared_task的区别？
# 一般情况使用的是从celeryapp中引入的app作为的装饰器：@app.task
# django那种在app中定义的task则需要使用@shared_task

简述 requests模块的作用及基本使用？
复制代码
复制代码
复制代码
# 作用：
使用requests可以模拟浏览器的请求
# 常用参数：
   url、headers、cookies、data
   json、params、proxy
# 常用返回值：
   content
   iter_content
   text 
   encoding="utf-8"
   cookie.get_dict()
复制代码
复制代码
复制代码

简述 beautifulsoup模块的作用及基本使用？
# BeautifulSoup
用于从HTML或XML文件中提取、过滤想要的数据形式
#常用方法
解析：html.parser 或者 lxml（需要下载安装） 
   find、find_all、text、attrs、get 

简述 seleninu模块的作用及基本使用?
Selenium是一个用于Web应用程序测试的工具，
他的测试直接运行在浏览器上，模拟真实用户，按照代码做出点击、输入、打开等操作

爬虫中使用他是为了解决requests无法解决javascript动态问题

scrapy框架中各组件的工作流程？
复制代码
复制代码
复制代码
#1、生成初始的Requests来爬取第一个URLS，并且标识一个回调函数
第一个请求定义在start_requests()方法内默认从start_urls列表中获得url地址来生成Request请求，
默认的回调函数是parse方法。回调函数在下载完成返回response时自动触发
#2、在回调函数中，解析response并且返回值
返回值可以4种：
    a、包含解析数据的字典
    b、Item对象
    c、新的Request对象（新的Requests也需要指定一个回调函数）
    d、或者是可迭代对象（包含Items或Request）
#3、在回调函数中解析页面内容
通常使用Scrapy自带的Selectors，但很明显你也可以使用Beutifulsoup，lxml或其他你爱用啥用啥。
#4、最后，针对返回的Items对象将会被持久化到数据库
    通过Item Pipeline组件存到数据库
    或者导出到不同的文件（通过Feed exports）
http://www.cnblogs.com/wupeiqi/articles/6229292.html
复制代码
复制代码
复制代码

在scrapy框架中如何设置代理（两种方法）？
复制代码
复制代码
复制代码
方式一：内置添加代理功能
# -*- coding: utf-8 -*-
import os
import scrapy
from scrapy.http import Request

class ChoutiSpider(scrapy.Spider):
    name = 'chouti'
    allowed_domains = ['chouti.com']
    start_urls = ['https://dig.chouti.com/']

    def start_requests(self):
        os.environ['HTTP_PROXY'] = "http://192.168.11.11"

        for url in self.start_urls:
            yield Request(url=url,callback=self.parse)

    def parse(self, response):
        print(response)

方式二：自定义下载中间件
import random
import base64
import six
def to_bytes(text, encoding=None, errors='strict'):
    """Return the binary representation of `text`. If `text`
    is already a bytes object, return it as-is."""
    if isinstance(text, bytes):
        return text
    if not isinstance(text, six.string_types):
        raise TypeError('to_bytes must receive a unicode, str or bytes '
                        'object, got %s' % type(text).__name__)
    if encoding is None:
        encoding = 'utf-8'
    return text.encode(encoding, errors)
    
class MyProxyDownloaderMiddleware(object):
    def process_request(self, request, spider):
        proxy_list = [
            {'ip_port': '111.11.228.75:80', 'user_pass': 'xxx:123'},
            {'ip_port': '120.198.243.22:80', 'user_pass': ''},
            {'ip_port': '111.8.60.9:8123', 'user_pass': ''},
            {'ip_port': '101.71.27.120:80', 'user_pass': ''},
            {'ip_port': '122.96.59.104:80', 'user_pass': ''},
            {'ip_port': '122.224.249.122:8088', 'user_pass': ''},
        ]
        proxy = random.choice(proxy_list)
        if proxy['user_pass'] is not None:
            request.meta['proxy'] = to_bytes("http://%s" % proxy['ip_port'])
            encoded_user_pass = base64.encodestring(to_bytes(proxy['user_pass']))
            request.headers['Proxy-Authorization'] = to_bytes('Basic ' + encoded_user_pass)
        else:
            request.meta['proxy'] = to_bytes("http://%s" % proxy['ip_port'])



配置：
    DOWNLOADER_MIDDLEWARES = {
       # 'xiaohan.middlewares.MyProxyDownloaderMiddleware': 543,
    }
复制代码
复制代码
复制代码

scrapy框架中如何实现大文件的下载？
复制代码
复制代码
复制代码
from twisted.web.client import Agent, getPage, ResponseDone, PotentialDataLoss
from twisted.internet import defer, reactor, protocol
from twisted.web._newclient import Response
from io import BytesIO

class _ResponseReader(protocol.Protocol):
    def __init__(self, finished, txresponse, file_name):
        self._finished = finished
        self._txresponse = txresponse
        self._bytes_received = 0
        self.f = open(file_name, mode='wb')
    def dataReceived(self, bodyBytes):
        self._bytes_received += len(bodyBytes)
        # 一点一点的下载
        self.f.write(bodyBytes)
        self.f.flush()
    def connectionLost(self, reason):
        if self._finished.called:
            return
        if reason.check(ResponseDone):
            # 下载完成
            self._finished.callback((self._txresponse, 'success'))
        elif reason.check(PotentialDataLoss):
            # 下载部分
            self._finished.callback((self._txresponse, 'partial'))
        else:
            # 下载异常
            self._finished.errback(reason)
        self.f.close()
复制代码
复制代码
复制代码

scrapy中如何实现限速？
http://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/autothrottle.html

scrapy中如何实现暂停爬虫？
复制代码
复制代码
复制代码
# 有些情况下，例如爬取大的站点，我们希望能暂停爬取，之后再恢复运行。
# Scrapy通过如下工具支持这个功能:
一个把调度请求保存在磁盘的调度器
一个把访问请求保存在磁盘的副本过滤器[duplicates filter]
一个能持续保持爬虫状态(键/值对)的扩展
Job 路径
要启用持久化支持，你只需要通过 JOBDIR 设置 job directory 选项。
这个路径将会存储所有的请求数据来保持一个单独任务的状态(例如：一次spider爬取(a spider run))。
必须要注意的是，这个目录不允许被不同的spider 共享，甚至是同一个spider的不同jobs/runs也不行。
也就是说，这个目录就是存储一个 单独 job的状态信息。
复制代码
复制代码
复制代码

scrapy中如何进行自定制命令？
复制代码
复制代码
复制代码
在spiders同级创建任意目录，如：commands
在其中创建'crawlall.py'文件（此处文件名就是自定义的命令）
from scrapy.commands import ScrapyCommand
    from scrapy.utils.project import get_project_settings
    class Command(ScrapyCommand):
        requires_project = True
        def syntax(self):
            return '[options]'
        def short_desc(self):
            return 'Runs all of the spiders'
        def run(self, args, opts):
            spider_list = self.crawler_process.spiders.list()
            for name in spider_list:
                self.crawler_process.crawl(name, **opts.__dict__)
            self.crawler_process.start()
在'settings.py'中添加配置'COMMANDS_MODULE = '项目名称.目录名称''
在项目目录执行命令：'scrapy crawlall' 
复制代码
复制代码
复制代码

scrapy中如何实现的记录爬虫的深度？
复制代码
复制代码
复制代码
'DepthMiddleware'是一个用于追踪每个Request在被爬取的网站的深度的中间件。 
其可以用来限制爬取深度的最大深度或类似的事情。
'DepthMiddleware'可以通过下列设置进行配置(更多内容请参考设置文档):

'DEPTH_LIMIT':爬取所允许的最大深度，如果为0，则没有限制。
'DEPTH_STATS':是否收集爬取状态。
'DEPTH_PRIORITY':是否根据其深度对requet安排优先
复制代码
复制代码
复制代码

scrapy中的pipelines工作原理？
Scrapy 提供了 pipeline 模块来执行保存数据的操作。
在创建的 Scrapy 项目中自动创建了一个 pipeline.py 文件，同时创建了一个默认的 Pipeline 类。
我们可以根据需要自定义 Pipeline 类，然后在 settings.py 文件中进行配置即可

scrapy的pipelines如何丢弃一个item对象？
通过raise DropItem()方法


简述scrapy中爬虫中间件和下载中间件的作用？1
http://www.cnblogs.com/wupeiqi/articles/6229292.html

scrapy-redis组件的作用？
实现了分布式爬虫，url去重、调度器、数据持久化
'scheduler'调度器
'dupefilter'URL去重规则（被调度器使用）
'pipeline'数据持久化

scrapy-redis组件中如何实现的任务的去重？
复制代码
复制代码
复制代码
a. 内部进行配置，连接Redis
b.去重规则通过redis的集合完成，集合的Key为：
   key = defaults.DUPEFILTER_KEY % {'timestamp': int(time.time())}
   默认配置：
      DUPEFILTER_KEY = 'dupefilter:%(timestamp)s'
c.去重规则中将url转换成唯一标示，然后在redis中检查是否已经在集合中存在
   from scrapy.utils import request
   from scrapy.http import Request
   req = Request(url='http://www.cnblogs.com/wupeiqi.html')
   result = request.request_fingerprint(req)
   print(result)  # 8ea4fd67887449313ccc12e5b6b92510cc53675c

复制代码
复制代码
复制代码
复制代码
复制代码
复制代码
scrapy和scrapy-redis的去重规则（源码）
1. scrapy中去重规则是如何实现？
class RFPDupeFilter(BaseDupeFilter):
    """Request Fingerprint duplicates filter"""

    def __init__(self, path=None, debug=False):
        self.fingerprints = set()
        

    @classmethod
    def from_settings(cls, settings):
        debug = settings.getbool('DUPEFILTER_DEBUG')
        return cls(job_dir(settings), debug)

    def request_seen(self, request):
        # 将request对象转换成唯一标识。
        fp = self.request_fingerprint(request)
        # 判断在集合中是否存在，如果存在则返回True，表示已经访问过。
        if fp in self.fingerprints:
            return True
        # 之前未访问过，将url添加到访问记录中。
        self.fingerprints.add(fp)

    def request_fingerprint(self, request):
        return request_fingerprint(request)

        
2. scrapy-redis中去重规则是如何实现？
class RFPDupeFilter(BaseDupeFilter):
    """Redis-based request duplicates filter.

    This class can also be used with default Scrapy's scheduler.

    """

    logger = logger

    def __init__(self, server, key, debug=False):
        
        # self.server = redis连接
        self.server = server
        # self.key = dupefilter:123912873234
        self.key = key
        

    @classmethod
    def from_settings(cls, settings):
        
        # 读取配置，连接redis
        server = get_redis_from_settings(settings)

        #  key = dupefilter:123912873234
        key = defaults.DUPEFILTER_KEY % {'timestamp': int(time.time())}
        debug = settings.getbool('DUPEFILTER_DEBUG')
        return cls(server, key=key, debug=debug)

    @classmethod
    def from_crawler(cls, crawler):
        
        return cls.from_settings(crawler.settings)

    def request_seen(self, request):
        
        fp = self.request_fingerprint(request)
        # This returns the number of values added, zero if already exists.
        # self.server=redis连接
        # 添加到redis集合中：1，添加工程；0，已经存在
        added = self.server.sadd(self.key, fp)
        return added == 0

    def request_fingerprint(self, request):
        
        return request_fingerprint(request)

    def close(self, reason=''):
        
        self.clear()

    def clear(self):
        """Clears fingerprints data."""
        self.server.delete(self.key)
复制代码
复制代码
复制代码

scrapy-redis的调度器如何实现任务的深度优先和广度优先？....
 

 


简述 vitualenv 及应用场景?
'vitualenv'是一个独立的python虚拟环境
如：
   当前项目依赖的是一个版本，但是另一个项目依赖的是另一个版本，这样就会造成依赖冲突，
   而virtualenv就是解决这种情况的，virtualenv通过创建一个虚拟化的python运行环境，
   将我们所需的依赖安装进去的，不同项目之间相互不干扰

简述 pipreqs 及应用场景？
可以通过对项目目录扫描，自动发现使用了那些类库，并且自动生成依赖清单。

pipreqs ./ 生成requirements.txt

在Python中使用过什么代码检查工具？
1）PyFlakes：静态检查Python代码逻辑错误的工具。
2）Pep8： 静态检查PEP8编码风格的工具。
3）NedBatchelder’s McCabe script：静态分析Python代码复杂度的工具。
Python代码分析工具：PyChecker、Pylint

简述 saltstack、ansible、fabric、puppet工具的作用？
 

 


B Tree和B+ Tree的区别？
1.B树中同一键值不会出现多次，并且有可能出现在叶结点，也有可能出现在非叶结点中。
  而B+树的键一定会出现在叶结点中，并有可能在非叶结点中重复出现，以维持B+树的平衡。
2.因为B树键位置不定，且在整个树结构中只出现一次，

请列举常见排序并通过代码实现任意三种。
冒泡/选择/插入/快排
https://www.cnblogs.com/Liqiongyu/p/5911613.html

http://www.cnblogs.com/feixuelove1009/p/6143539.html


 请列举常见查找并通过代码实现任意三种。
无序查找、二分查找、插值查找

请列举你熟悉的设计模式？
工厂模式/单例模式等

有没有刷过leetcode？
leetcode是个题库，里面有多很编程题目，可以在线编译运行。

https://leetcode-cn.com/problemset/all/

列举熟悉的的Linux命令。
复制代码
复制代码
复制代码
1创建目录
mkdir /data
cd /
mkdir data


2：查看目录
ls 
ls -l  显示详细信息
复制代码
复制代码
复制代码

公司线上服务器是什么系统？
Linux/Centos

解释 PV、UV 的含义？
PV访问量（Page View），即页面访问量，每打开一次页面PV计数+1，刷新页面也是。
UV访问数（Unique Visitor）指独立访客访问数，一台电脑终端为一个访客。

解释 QPS的含义？
'QPS(Query Per Second)'
每秒查询率，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准

uwsgi和wsgi的区别？
wsgi是一种通用的接口标准或者接口协议，实现了python web程序与服务器之间交互的通用性。

uwsgi:同WSGI一样是一种通信协议
uwsgi协议是一个'uWSGI服务器'自有的协议，它用于定义传输信息的类型，
'uWSGI'是实现了uwsgi和WSGI两种协议的Web服务器，负责响应python的web请求。

supervisor的作用？
复制代码
复制代码
复制代码
# Supervisor：
是一款基于Python的进程管理工具，可以很方便的管理服务器上部署的应用程序。
是C/S模型的程序，其服务端是supervisord服务,客户端是supervisorctl命令

# 主要功能:
1 启动、重启、关闭包括但不限于python进程。
2 查看进程的运行状态。
3 批量维护多个进程。
复制代码
复制代码
复制代码

什么是反向代理？
正向代理代理客户端(客户端找哟个代理去访问服务器，服务器不知道你的真实IP)
反向代理代理服务器(服务器找一个代理给你响应，你不知道服务器的真实IP)

简述SSH的整个过程。
SSH 为 'Secure Shell' 的缩写，是建立在应用层基础上的安全协议。
SSH 是目前较可靠，为远程登录会话和其他网络服务提供的安全性协议。
利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。

有问题都去那些找解决方案？
起初是百度，发现搜到的答案不精准，净广告
转战谷歌，但墙了；捣鼓怎么FQ

还会去知乎、stackoverfloow、必应、思否(segmentfault)

是否有关注什么技术类的公众号？
python之禅(主要专注Python相关知识，作者：刘志军)
码农翻身(主要是Java的，但不光是java，涵盖面很广，作者：刘欣)
实验楼(在线练项目)
and so on

最近在研究什么新技术？
Numpy
pandas(金融量化分析、聚宽)
百度AI
图灵API
智能玩具

是否了解过领域驱动模型？
Domain-Driven Design
 

 

回到顶部
 
 

回到顶部
二进制与十进制之间的转换
1、十进制 与 二进制之间的转换
    (1)、十进制转换为二进制，分为整数部分和小数部分


整数部分
复制代码
复制代码
复制代码
方法：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数。
这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。下面举例：

例：将十进制的168转换为二进制
得出结果 将十进制的168转换为二进制，（10101000）2
168 / 2 = 84 -- 0
84 / 2 = 42 -- 0
42 / 2 = 21 -- 0
21 / 2 = 10 -- 1
10 / 2 = 5 -- 0
 5 / 2 = 2 -- 1
2 / 2 = 1 -- 0
1 / 2 = 0 -- 1
二进制（从后往前读）： 10101000
复制代码
复制代码
复制代码
小数部分
方法：乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，
剩下的小数部分又乘以2，一直取到小数部分为零为止。如果永远不能为零，就同十进制数的四舍五入一样，
按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。
换句话说就是0舍1入。读数要从前面的整数读到后面的整数
小数部分
二进制转换为十进制 (不分整数和小数部分)
方法：按权相加法，即将二进制每位上的数乘以权，然后相加之和即是十进制数。

复制代码
复制代码
复制代码
例：将二进制数101.101转换为十进制数。 
得出结果：（101.101）2=(5.625)10 
在做二进制转换成十进制需要注意的是 
1）要知道二进制每位的权值 
2）要能求出每位的值 101.101 转换为十进制 
整数部分：2^2 + 2^0 = 5 
小数部分：2^(-1) + 2^(-3) = 1/2 + 1/8 = 0.5 + 0.125 = 0.625 
十进制： 2^2 + 2^0 + 2^(-1) + 2^(-3) = 5.625
复制代码
复制代码


一些经典的Python爬虫和网络编程面试题
1、动态加载又对及时性要求很高怎么处理？
Selenium+Phantomjs

尽量不使用 sleep 而使用 WebDriverWait

 

2、分布式爬虫主要解决什么问题？
（1）ip

（2）带宽

（3）cpu

（4）io

 

3、什么是 URL？
URL，即统一资源定位符，也就是我们说的网址，统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。

 

4、python 爬虫有哪些常用技术？
Scrapy，Beautiful Soup， urllib，urllib2，requests

 

5、简单说一下你对 scrapy 的了解？
scrapy 是一个快速(fast)、高层次(high-level)的基于 python 的 web 爬虫构架。

用来下载、并解析 web 页面, 其 parse->yield item->pipeline 流程是所有爬虫的固有模式。

构造形式主要分spider.pypipeline.py item.py decorator.py middlewares.py setting.py。

 

6、Scrapy 的优缺点?
（1）优点：scrapy 是异步的

采取可读性更强的 xpath 代替正则强大的统计和 log 系统，同时在不同的 url 上爬行支持 shell 方式，方便独立调试写 middleware,方便写一些统一的过滤器，通过管道的方式存入数据库

（2）缺点：基于 python 的爬虫框架，扩展性比较差

基于 twisted 框架，运行中的 exception 是不会干掉 reactor，并且异步框架出错后是不会停掉其他任务的，数据出错后难以察觉。

 

7、scrapy 和 request?
（1）scrapy 是封装起来的框架，他包含了下载器，解析器，日志及异常处理，基于多线程， twisted 的方式处理，对于固定单个网站的爬取开发，有优势，但是对于多网站爬取 100 个网站，并发及分布式处理方面，不够灵活，不便调整与括展。

（2）request 是一个 HTTP 库， 它只是用来，进行请求，对于 HTTP 请求，他是一个强大的库，下载，解析全部自己处理，灵活性更高，高并发与分布式部署也非常灵活，对于功能可以更好实现.

 

8、五层网络模型？
应用层—http ftp dns nfs

传输层—tcp --udp

网络层—ip icmp igmp

链路层—data link

物理层—media

设置 ip 和掩码

<pre style="-webkit-tap-highlight-color: transparent; box-sizing: border-box; font-family: Consolas, Menlo, Courier, monospace; font-size: 16px; white-space: pre-wrap; position: relative; line-height: 1.5; color: rgb(153, 153, 153); margin: 1em 0px; padding: 12px 10px; background: rgb(244, 245, 246); border: 1px solid rgb(232, 232, 232); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"> Ifconfig eth0 192.168.13.225 netmask 255.255.255.0 </pre>

设置网关

route add default gw 192.168.5.1

 

9、什么是 2MSL？
2MSL 即两倍的 MSL，TCP 的 TIME_WAIT 状态也称为 2MSL 等待状态，当 TCP 的一端发起主动关闭，在发出最后一个 ACK 包后，即第 3 次握手完成后发送了第四次握手的 ACK包后就进入了 TIME_WAIT 状态，必须在此状态上停留两倍的 MSL 时间，等待 2MSL 时间主要目的是怕最后一个 ACK 包对方没收到，那么对方在超时后将重发第三次握手的 FIN包，主动关闭端接到重发的 FIN 包后可以再发一个 ACK 应答包。在 TIME_WAIT 状态时两端的端口不能使用，要等到 2MSL 时间结束才可继续使用。当连接处于 2MSL 等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置 SO_REUSEADDR 选项达到不必等待 2MSL 时间结束再使用此端口。

 

10、创建一个简单 tcp 服务器需要的流程？
1.socket 创建一个套接字

2.bind 绑定 ip 和 port

3.listen 使套接字变为可以被动链接

4.accept 等待客户端的链接

5.recv/send 接收发送数据

 

11、TTL，MSL，RTT？
（1）MSL：报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

（2）TTL：TTL 是 time to live 的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个 ip 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。RFC 793 中规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。TTL 与 MSL 是有关系的但不是简单的相等的关系，MSL要大于等于 TTL。

（3）RTT： RTT 是客户到服务器往返所花时间（round-trip time，简称 RTT），TCP 含有动态估算 RTT 的算法。TCP 还持续估算一个给定连接的 RTT，这是因为 RTT受网络传输拥塞程序的变化而变化。

 

12、常用的反爬虫措施？
1.添加代理

2.降低访问频率

User-Agent动态 HTML 数据加载验证码处理Cookie

 

13、关于 HTTP/HTTPS 的区别
HTTPS 和 HTTP 的区别：

（1）https 协议需要到 ca 申请证书，一般免费证书很少，需要交费。

（2）http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议

（3）http 和 https 使用的是完全不同的连接方式用的端口也不一样,前者是 80,后者是 443。

（4）http 的连接很简单,是无状态的

（5）HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议 要比http 协议安全

应用场合：

（1）http:适合于对传输速度，安全性要求不是很高，且需要快速开发的应用。如 web 应用，小的手机游戏等等.

（2）https:https 应该用于任何场景！

 

14、HTTPS 有什么优点和缺点
优点：
1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
2、HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本
缺点：
1.HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用
2.HTTPS 协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。
3.SSL 证书需要钱。功能越强大的证书费用越高。个人网站、小网站没有必要一般不会用。
4.HTTPS 连接服务器端资源占用高很多，握手阶段比较费时对网站的相应速度有负面影响。
5.HTTPS 连接缓存不如 HTTP 高效。
 
15、HTTPS 是如何实现安全传输数据的
HTTPS 其实就是在 HTTP 跟 TCP 中间加多了一层加密层 TLS/SSL。SSL 是个加密套件，负责对 HTTP 的数据进行加密。TLS 是 SSL 的升级版。现在提到 HTTPS，加密套件基本指的是 TLS。原先是应用层将数据直接给到 TCP 进行传输，现在改成应用层将数据给到TLS/SSL，将数据加密后，再给到 TCP 进行传输。
 

16、HTTPS 安全证书是怎么来的
如何申请，国内和国外有哪些第三方机构提供安全证书认证。

国内：

沃通(WoSign)
中国人民银行联合 12 家银行建立的金融 CFCA
中国电信认证中心（CTCA）
海关认证中心（SCCA）
国家外贸部 EDI 中心建立的国富安 CA 安全认证中心
SHECA（上海 CA）为首的 UCA 协卡认证体系
国外：

StartSSL
GlobalSign
GoDaddy
Symantec
 

16、get 和 post 请求有什么区别
区别：

get:

从指定的服务器中获取数据。

GET 请求能够被缓存

GET 请求会保存在浏览器的浏览记录中

以 GET 请求的 URL 能够保存为浏览器书签

GET 请求有长度限制

GET 请求主要用以获取数据

post:

POST 请求不能被缓存下来

POST 请求不会保存在浏览器浏览记录中

以 POST 请求的 URL 无法保存为浏览器书签

POST 请求没有长度限制

POST 请求会把请求的数据放置在 HTTP 请求包的包体中,POST 的安全性比 GET的高.可能修改变服务器上的资源的请求.

应用场合：

post：

请求的结果有持续性的副作用（数据库内添加新的数据行）

若使用 GET 方法，则表单上收集的数据可能让 URL 过长。

要传送的数据不是采用 7 位的 ASCII 编码。

get：

请求是为了查找资源，HTML 表单数据仅用来帮助搜索。

请求结果无持续性的副作用。

收集的数据及 HTML 表单内的输入字段名称的总长不超过 1024 个字符

HTTP 请求会有哪些信息发送到后台服务器。

请求行 （请求方式、资源路径和 HTTP 协议版本）POST /demo/login HTTP/1.1

请求消息头

消息正文（也叫实体内容） username=xxxx&password=1234

 

17、描述下 scrapy 框架运行的机制？
（1）从 start_urls 里获取第一批 url 并发送请求，请求由引擎交给调度器入请求队列，获取完毕后，调度器将请求队列里的请求交给下载器去获取请求对应的响应资源，并将响应交给自己编写的解析方法做提取处理：1. 如果提取出需要的数据，则交给管道文件处理；

（2）如果提取出 url，则继续执行之前的步骤（发送 url 请求，并由引擎将请求交给调度器入队列…)，直到请求队列里没有请求，程序结束。

 

18、为什么选择redis 数据库？
①scrapy 是一个 Python 爬虫框架，爬取效率极高，具有高度定制性，但是不支持分布式。而 scrapy-redis 一套基于 redis 数据库、运行在 scrapy 框架之上的组件，可以让scrapy 支持分布式策略，Slaver 端共享 Master 端 redis 数据库里的 item 队列、请求队列和请求指纹集合。

②为什么选择 redis 数据库，因为 redis 支持主从同步，而且数据都是缓存在内存中的，所以基于 redis 的分布式爬虫，对请求和数据的高频读取效率非常高

 

19、实现模拟登录的方式有哪些？
①使用一个具有登录状态的 cookie，结合请求报头一起发送，可以直接发送 get 请求，访问登录后才能访问的页面。

②先发送登录界面的 get 请求，在登录页面 HTML 里获取登录需要的数据（如果需要的话），然后结合账户密码，再发送 post 请求，即可登录成功。然后根据获取的 cookie信息，继续访问之后的页面。

 

20、简单介绍下 scrapy 的异步处理
scrapy 框架的异步机制是基于 twisted 异步网络框架处理的，在 settings.py 文件里可以设置具体的并发量数值（默认是并发量 16）。

 

 

 

 

一.项目问题：
1.你写爬虫的时候都遇到过什么反爬虫措施，你最终是怎样解决的
①通过headers反爬虫：解决策略，伪造headers

②基于用户行为反爬虫：动态变化去爬取数据，模拟普通用户的行为， 使用IP代理池爬取或者降低抓取频率，或 通过动态更改代理ip来反爬虫

③基于动态页面的反爬虫：跟踪服务器发送的ajax请求，模拟ajax请求,selnium

和phtamjs。或 使用selenium + phantomjs 进行抓取抓取动态数据，或者找到动态数据加载的json页面。

④验证码 ：使用打码平台识别验证码

⑤数据加密：对部分数据进行加密的，可以使用selenium进行截图，使用python自带的pytesseract库进行识别，但是比较慢最直接的方法是找到加密的方法进行逆向推理。

 

2.你写爬虫的时候 使用的什么框架 选择这个框架的原因是什么？
scrapy。

优势:

可以实现高并发的爬取数据, 注意使用代理;
提供了一个爬虫任务管理界面, 可以实现爬虫的停止,启动,调试,支持定时爬取任务;
 代码简洁
劣势:

可扩展性不强。
②整体上来说: 一些结构性很强的, 定制性不高, 不需要太多自定义功能时用pyspider即可, 一些定制性高的,需要自定义一 些 功能时则使用Scrapy。

 

二.scrapy框架专题部分（很多面试都会涉及到这部分）
1.请简要介绍下scrapy框架。
scrapy 是一个快速(fast)、高层次(high-level)的基于 python 的 web 爬虫构架，用于抓取web站点并从页面中提取结构化的数据。scrapy 使用了 Twisted异步网络库来处理网络通讯

 

2.为什么要使用scrapy框架？scrapy框架有哪些优点？
它更容易构建大规模的抓取项目
它异步处理请求，速度非常快
它可以使用自动调节机制自动调整爬行速度
提供了一个爬虫任务管理界面, 可以实现爬虫的停止,启动,调试,支持定时爬取任务;
 代码简洁
 

3.scrapy框架有哪几个组件/模块？简单说一下工作流程。
Scrapy Engine:这是引擎，负责Spiders、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等等！（像不像人的身体？）

Scheduler(调度器): 它负责接受引擎发送过来的requests请求，并按照一定的方式进行整理排列，入队、并等待Scrapy Engine(引擎)来请求时，交给引擎。

Downloader（下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spiders来处理，

Spiders：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)，

Item Pipeline：它负责处理Spiders中获取到的Item，并进行处理，比如去重，持久化存储（存数据库，写入文件，总之就是保存数据用的）

Downloader Middlewares（下载中间件）：你可以当作是一个可以自定义扩展下载功能的组件

Spider Middlewares（Spider中间件）：你可以理解为是一个可以自定扩展和操作引擎和Spiders中间‘通信‘的功能组件（比如进入Spiders的Responses;和从Spiders出去的Requests）

工作流程：

数据在整个Scrapy的流向：

程序运行的时候，

引擎：Hi！Spider, 你要处理哪一个网站？

Spiders：我要处理23wx.com

引擎：你把第一个需要的处理的URL给我吧。

Spiders：给你第一个URL是XXXXXXX.com

引擎：Hi！调度器，我这有request你帮我排序入队一下。

调度器：好的，正在处理你等一下。

引擎：Hi！调度器，把你处理好的request给我，

调度器：给你，这是我处理好的request

引擎：Hi！下载器，你按照下载中间件的设置帮我下载一下这个request

下载器：好的！给你，这是下载好的东西。（如果失败：不好意思，这个request下载失败，然后引擎告诉调度器，这个request下载失败了，你记录一下，我们待会儿再下载。）

引擎：Hi！Spiders，这是下载好的东西，并且已经按照Spider中间件处理过了，你处理一下（注意！这儿responses默认是交给def parse这个函数处理的）

Spiders：（处理完毕数据之后对于需要跟进的URL），Hi！引擎，这是我需要跟进的URL，将它的responses交给函数 def xxxx(self, responses)处理。还有这是我获取到的Item。

引擎：Hi ！Item Pipeline 我这儿有个item你帮我处理一下！调度器！这是我需要的URL你帮我处理下。然后从第四步开始循环，直到获取到你需要的信息，

注意！只有当调度器中不存在任何request了，整个程序才会停止，（也就是说，对于下载失败的ＵＲＬ，Scrapy会重新下载。）

 

以上就是Scrapy整个流程了。

官方语言版本：

流程

1.引擎打开一个域名，蜘蛛处理这个域名，并让蜘蛛获取第一个爬取的URL。

2.引擎从蜘蛛那获取第一个需要爬取的URL，然后作为请求在调度中进行调度。

3.引擎从调度那获取接下来进行爬取的页面。

4.调度将下一个爬取的URL返回给引擎，引擎将他们通过下载中间件发送到下载器。

5.当网页被下载器下载完成以后，响应内容通过下载中间件被发送到引擎。

6.引擎收到下载器的响应并将它通过蜘蛛中间件发送到蜘蛛进行处理。

7.蜘蛛处理响应并返回爬取到的项目，然后给引擎发送新的请求。

8.引擎将抓取到的项目发送给项目管道，并向调度发送请求。

系统重复第二步后面的操作，直到调度中没有请求，然后断开引擎与域之间的联系

 

4.scrapy的去重原理（指纹去重到底是什么原理）
需要将dont_filter设置为False开启去重，默认是False；

对于每一个url的请求，调度器都会根据请求的相关信息加密得到一个指纹信息，并且将指纹信息和set()集合中的指纹信息进行比对，如果set()集合中已经存在这个数据，就不在将这个Request放入队列中。如果set()集合中没有，就将这个Request对象放入队列中，等待被调度。

 

5.scrapy中间件有几种类，你用过哪些中间件*
scrapy的中间件理论上有三种：

Scheduler Middleware,Spider Middleware,Downloader Middleware,

 

在应用上一般有以下两种：

 

1.爬虫中间件Spider Middleware

主要功能是在爬虫运行过程中进行一些处理.

 

2.下载器中间件Downloader Middleware

主要功能在请求到网页后,页面被下载时进行一些处理.

使用

1.Spider Middleware有以下几个函数被管理:

process_spider_input 接收一个response对象并处理，

位置是Downloader–>process_spider_input–>Spiders(Downloader和Spiders是scrapy官方结构图中的组件)

process_spider_exception spider出现的异常时被调用

process_spider_output 当Spider处理response返回result时,该方法被调用

process_start_requests 当spider发出请求时,被调用

位置是Spiders–>process_start_requests–>Scrapy Engine(Scrapy Engine是scrapy官方结构图中的组件)

 

2.Downloader Middleware有以下几个函数被管理

 - process_request  request通过下载中间件时，该方法被调

 - process_response 下载结果经过中间件时被此方法处理

 - process_exception 下载过程中出现异常时被调用

 

6.scrapy中间件在哪里起的作用
1.爬虫中间件Spider Middleware：主要功能是在爬虫运行过程中进行一些处理.爬虫发起请求request的时候调用，列如更换修改代理ip,修改UA,

2.下载器中间件Downloader Middleware：主要功能在请求到网页后,页面被下载时进行一些处理.浏览器返回响应response的时候调用，无效的数据，特殊情况进行重试

 

三.代理问题：
1.为什么会用到代理
一些网站会有相应的反爬虫措施，例如很多网站会检测某一段时间某个IP的访问次数，如果访问频率太快以至于看起来不像正常访客，它可能就会会禁止这个IP的访问。所以我们需要设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。

 

2.代理怎么使用（具体代码， 请求在什么时候添加的代理）
可以使用urllie中request的Proxy Handler来设置代理ip
一般urllib使用代理ip的步骤如下:

设置代理地址
创建Proxyhandler
创建Opener
④ 安装Opener

 

from urllib import request,error#构建两个代理Handler，一个有IP,一个没有IPproxy = {'http':'206.125.41.135:80'} httpproxy_handler = request.ProxyHandler(proxy) nullproxy_handler = request.ProxyHandler()#定义一个代理开关proxySwitch = False#通过reqest.build_opener()放法使用这些代理Handler对象，创建自定义opener对象 #根据代理开关是否打开，使用不同的代理模式if proxySwitch:     opener = request.build_opener(httpproxy_handler)else:     opener = request.build_opener(nullproxy_handler) url = "http://www.baidu.com"#安装opnerrequest.install_opener(opener) rsp = request.urlopen(url)print(rsp.status)

 

2,使用requets代理

import requests# 根据协议类型，选择不同的代理proxies = {     "http": "http://12.34.56.79:9527",     "https": "http://12.34.56.79:9527"} response = requests.get("http://www.baiodu.com",proxies=proxies)print(response.status_code)

 

3.代理失效了怎么处理
事先用检测代码检测可用的代理，每隔一段时间更换一次代理，如果出现302等状态码，

则立即更换下一个可用的IP。

from urllib import requestdef ProxySpider(url,proxy_ip,headers):     #将代理IP及其协议载入ProxyHandler赋给一个opener_support变量     opener_support = request.ProxyHandler({"http":proxy_ip})     #将opener_support载入build_opener方法，创建opener     opener = request.build_opener(opener_support)     request.install_opener(opener)     req=request.Request(url,headers=headers)     rsp = request.urlopen(req).read()     return rsp

 

 

四.验证码处理：
1.登陆验证码处理
图片验证码：先将验证码图片下载到本地，然后使用云打码识别；
滑动验证码：使用selenium模拟人工拖动，对比验证图片的像素差异，找到滑动的位置然后获取它的location和size，然后 top，bottom，left，right = location['y'] ,location['y']+size['height']+ location['x'] +size['width'] ,然后截图，最后抠图填入这四个位置就行。
 

 

2.爬取速度过快出现的验证码处理
设置setting.py中的DOWNLOAD_DELAY，降低爬取速度；

用xpath获取验证码关键字，当出现验证码时，识别验证码后再继续运行。

 

3.如何用机器识别验证码**
对接打码平台

对携带验证码的页面数据进行抓取
将页面中的验证码进行解析, 将验证码图片下载到本地
将验证码图片提交给打码平台进行识别, 返回识别后的结果
云打码平台使用：

 

在官网中进行普通用户和开发者用户注册

登录开发者用户：

a) 示例代码下载：开发文档 --> 调用示例及最新DLL --> PythonHTTP示例下载

b) 创建一个软件：我的软件 --> 添加新的软件(后期会使用该软件的秘钥和id)

使用示例代码中的示例代码对保存本地的验证码进行识别

 

五.模拟登陆问题：
1.模拟登陆流程
 1. 加载浏览器driver； 获取登录页面； 使用css选择器或者xpath找到账号和密码输入框，

       并发送账号和密码；

 2. 如果出现验证码则需要先识别验证码，在模拟输入验证码或者模拟鼠标拖动；

 3. 使用css选择器或者xpath找到登录按钮，使用click模拟点击；

 

2.cookie如何处理
 1. 采用selenium自动登录获取cookie,保存到文件；

 2. 读取cookie,比较cookie的有效期,若过期则再次执行步骤1；

 3. 在请求其他网页时,填入cookie,实现登录状态的保持；

 

3.如何处理网站传参加密的情况**
加密的三种情况：

 1. 加密+访问次数限制+每个页面相关信息的条目需要点详情进行二次请求；

 2. 复杂的加密算法进行参数+时间戳+sig值，后台进行 参数+时间限制；

 3. 定时同步cookie+每个界面一个cookie。

 

破解方法：

 1. 使用selenium模拟点击获取详情页面；

 2. 获取其相应的api接口，GET接口URL，获取它的json表格内容；

 3. 反向分析网页JS加载内容；

 

六.分布式
1.什么是分布式
需要计算的数据量大，任务多，一台机器搞不定或者效率极低，需要多台机器共同协作（而不是孤立地各做各的，所以需要通信），最后所有机器完成的任务汇总在一起，完成大量任务.

将一个项目拷贝到多台电脑上，同时爬取数据

分布式爬虫则是将多台主机组合起来，共同完成一个爬取任务，这将大大提高爬取的效率。

记住爬虫的本质是网络请求和数据处理，如何稳定地访问网页拿到数据，如何精准地提取出高质量的数据才是核心问题

 

2.分布式原理
①分布式爬虫主要由主机与从机组成，我们把自己的核心服务器（主机）称为 master，而把用于跑爬虫程序的机器（从机）称为 slave。

②我们首先给爬虫一些start_urls，spider 最先访问 start_urls 里面的 url，再根据我们的 parse 函数，对里面的元素、或者是其他的二级、三级页面进行抓取。而要实现分布式，只需要在这个starts_urls里面做文章就行了。进一步描述如下：

master 产生 start_urls，url 会被封装成 request 放到 redis 中的spider:requests，总的 scheduler 会从这里分配 request，当这里的 request 分配完后，会继续分配start_urls 里的 url。
②slave 从 master 的 redis 中取出待抓取的 request，下载完网页之后就把网页的内容发送回 master 的redis，key 是 spider:items。scrapy 可以通过 settings 来让 spider爬取结束之后不自动关闭，而是不断的去询问队列里有没有新的 url，如果有新的 url，那么继续获取 url并进行爬取，所以这一过程将不断循环。

master 里的 reids 还有一个 key 是 “spider:dupefilter” 用来存储抓取过的 url 的fingerprint（使用哈希函数将url运算后的结果），防止重复抓取，只要 redis 不清空，就可以进行断点续爬。

scrapy实现分布式抓取简单点来说可以借助scrapy_redis类库来实现。

在分布式爬取时，会有master机器和slave机器，其中，master为核心服务器，slave为具体的爬虫服务器。

我们在master服务器上搭建一个redis数据库，并将要抓取的url存放到redis数据库中，所有的slave爬虫服务器在抓取的时候从redis数据库中去链接，由于scrapy_redis自身的队列机制，slave获取的url不会相互冲突，然后抓取的结果最后都存储到数据库中。master的redis数据库中还会将抓取过的url的指纹存储起来，用来去重。相关代码在dupefilter.py文件中的request_seen()方法中可以找到。

通过重写scheduler和spider类，实现了调度、spider启动和redis的交互。实现新的dupefilter和queue类，达到了判重和调度容器和redis的交互，因为每个主机上的爬虫进程都访问同一个redis数据库，所以调度和判重都统一进行统一管理，达到了分布式爬虫的目的。

3.分布式如何判断爬虫已经停止了
1 spider.getStatus();//获取爬虫状态

2 spider.getStatus().equals(Spider.Status.Init);//运行中

 

4.分布式的去重原理
分布式去重问题：

Duplication Filter：

Scrapy中用集合实现这个request去重功能，Scrapy中把已经发送的request指纹放入到一个集合中，把下一个request的指纹拿到集合中比对，如果该指纹存在于集合中，说明这个request发送过了，如果没有则继续操作。这个核心的判重功能是这样实现的：

   def request_seen(self, request):

    # self.request_figerprints 就是一个指纹集合  

    fp = self.request_fingerprint(request)

    # 这就是判重的核心操作  

    if fp in self.fingerprints:

        return True

    self.fingerprints.add(fp)

    if self.file:

        self.file.write(fp + os.linesep)
 

在scrapy-redis中去重是由Duplication Filter组件来实现的，它通过redis的set 不重复的特性，巧妙的实现了Duplication Filter去重。scrapy-redis调度器从引擎接受request，将request的指纹存⼊redis的set检查是否重复，并将不重复的request push写⼊redis的 request queue。

引擎请求request(Spider发出的）时，调度器从redis的request queue队列⾥里根据优先级pop 出⼀个request 返回给引擎，引擎将此request发给spider处理。

 

 

5、总结
1、最后总结一下scrapy-redis的总体思路：这套组件通过重写scheduler和spider类，实现了调度、spider启动和redis的交互。

2、实现新的dupefilter和queue类，达到了判重和调度容器和redis     的交互，因为每个主机上的爬虫进程都访问同一个redis数据库，   所以调度和判重都统一进行统一管理，达到了分布式爬虫的目的。

3、当spider被初始化时，同时会初始化一个对应的scheduler对象，  这个调度器对象通过读取settings，配置好自己的调度容器queue 和判重工具dupefilter。

4、每当一个spider产出一个request的时候，scrapy引擎会把这个      reuqest递交给这个spider对应的scheduler对象进行调度，     scheduler对象通过访问redis对request进行判重，如果不重复就          把他添加进redis中的调度器队列里。当调度条件满足时，scheduler     对象就从redis的调度器队列中取出一个request发送给spider，  让他爬取。

5、当spider爬取的所有暂时可用url之后，scheduler发现这个spider           对应的redis的调度器队列空了，于是触发信号spider_idle，  spider收到这个信号之后，直接连接redis读取start_urls池，拿   去新的一批url入口，然后再次重复上边的工作。

 

七.数据存储和数据库问题：
1.关系型数据库和非关系型数据库的区别
 

详情请点击：https://blog.csdn.net/hzp666/article/details/79168675

 

2.爬下来数据你会选择什么存储方式，为什么
Redis基于内存，读写速度快，也可做持久化，但是内存空间有限，当数据量超过内存空间时，需扩充内存，但内存价格贵；

MySQL基于磁盘，读写速度没有Redis快，但是不受空间容量限制，性价比高；

大多数的应用场景是MySQL（主）+Redis（辅），MySQL做为主存储，Redis用于缓存，加快访问速度。需要高性能的地方使用Redis，不需要高性能的地方使用MySQL。存储数据在MySQL和Redis之间做同步；

MongoDB 与 MySQL 的适用场景：

MongoDB 的适用场景为：数据不是特别重要（例如通知，推送这些），数据表结构变化较为频繁，数据量特别大，数据的并发性特别高，数据结构比较特别（例如地图的位置坐标），这些情况下用 MongoDB ， 其他情况就还是用 MySQL ，这样组合使用就可以达到最大的效率。

今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。

 

3.各种数据库支持的数据类型，和特点
MongoDB

MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。

它是一个内存数据库，数据都是放在内存里面的。

对数据的操作大部分都在内存中，但 MongoDB 并不是单纯的内存数据库。

MongoDB 是由 C++ 语言编写的，是一个基于分布式文件存储的开源数据库系统。

在高负载的情况下，添加更多的节点，可以保证服务器性能。

MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。

MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。

优点：

1.性能优越:快速！在适量级的内存的 MongoDB 的性能是非常迅速的，它将热数据存储在物理内存中，使得热数据的读写变得十分快，

2.高扩展:第三方支持丰富(这是与其他的 No SQL 相比，MongoDB 也具有的优势)

3.自身的 Failover 机制！

4.弱一致性（最终一致），更能保证用户的访问速度

5.文档结构的存储方式，能够更便捷的获取数据: json 的存储格式

6.支持大容量的存储,内置 GridFS

7.内置 Sharding

8.MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。

MongoDB 缺点：

主要是无事物机制！

① MongoDB 不支持事务操作(最主要的缺点)

② MongoDB 占用空间过大

③ MongoDB 没有如 MySQL 那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方

redis

Redis 一个内存数据库，通过 Key-Value 键值对的的方式存储数据。由于 Redis 的数据都存储在内存中，所以访问速度非常快，因此 Redis 大量用于缓存系统，存储热点数据，可以极大的提高网站的响应速度。

1、Redis优点

（1）支持数据的持久化，通过配置可以将内存中的数据保存在磁盘中，Redis 重启以后再将数据加载到内存中；

（2）支持列表，哈希，有序集合等数据结构，极大的扩展了 Redis 用途；

（3）原子操作，Redis 的所有操作都是原子性的，这使得基于 Redis 实现分布式锁非常简单；

（4）支持发布/订阅功能，数据过期功能；

Redis的数据类型

Redis通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。

mysql

MySQL是关系型数据库。

MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。

MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。

系统特性

1． [2] 使用 C和 C++编写，并使用了多种编译器进行测试，保证了源代码的可移植性。

2．支持 AIX、FreeBSD、HP-UX、Linux、Mac OS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris、Windows等多种操作系统。

3．为多种编程语言提供了 API。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby,.NET和 Tcl 等。

4．支持多线程，充分利用 CPU 资源。

5．优化的 SQL查询算法，有效地提高查询速度。

6．既能够作为一个单独的应用程序应用在客户端服务器网络环境中，也能够作为一个库而嵌入到其他的软件中。

7．提供多语言支持，常见的编码如中文的 GB 2312、BIG5，日文的 Shift_JIS等都可以用作数据表名和数据列名。

8．提供 TCP/IP、ODBC 和 JDBC等多种数据库连接途径。

9．提供用于管理、检查、优化数据库操作的管理工具。

10．支持大型的数据库。可以处理拥有上千万条记录的大型数据库。

11．支持多种存储引擎。

12.MySQL 是开源的，所以你不需要支付额外的费用。

13.MySQL 使用标准的 SQL数据语言形式。

14.MySQL 对 PHP 有很好的支持，PHP是比较流行的 Web 开发语言。

15.MySQL是可以定制的，采用了 GPL协议，你可以修改源码来开发自己的 MySQL 系统。

16.在线 DDL/更改功能，数据架构支持动态应用程序和开发人员灵活性（5.6新增）

17.复制全局事务标识，可支持自我修复式集群（5.6新增）

18.复制无崩溃从机，可提高可用性（5.6新增）

19.复制多线程从机，可提高性能（5.6新增）

20.3倍更快的性能（5.7 [3] 新增）

21.新的优化器（5.7新增）

22.原生JSON支持（5.7新增）

23.多源复制（5.7新增）

24.GIS的空间扩展 [4] （5.7新增）

 

优势：

在不同的引擎上有不同 的存储方式。

查询语句是使用传统的sql语句，拥有较为成熟的体系，成熟度很高。

开源数据库的份额在不断增加，mysql的份额页在持续增长。

缺点：

在海量数据处理的时候效率会显著变慢。

4.是否支持事务…

mongo不支持

redis mysql支持

 

八.Python基础问题：
1.Python2和Python3的区别，如何实现python2代码迁移到Python3环境
区别：字符串类型、默认字符、print方法、除法的数字类型、导入方式、继承类、元类声明、异常处理、字典、模块合并、部分模块重命名（详情）

代码迁移：python3有个内部工具叫做2to3.py，位置在Python3/tool/script文件夹。

首先CD到这个文件夹，然后调用

py 2to3.py -w f:/xxxx/xxx.py

具体方法：https://blog.csdn.net/xutiantian1412/article/details/79523953

 

2.Python2和Python3的编码方式有什么差别
在python2中主要有str和unicode两种字符串类型，而到python3中改为了bytes和str,并且一个很重要的分别是，在python2中如果字符串是ascii码的话，str和unicode是可以直接进行连接和比较，但是到python3中就不行了，bytes和str是两个独立的类型。另一个重要的是python2中不管是str还是unicode都可以直接写入文件，而不需要加上它是不是str的类型写入方式，但是在python3中如果是写或者读bytes类型就必需带上’b’.

 

3.迭代器，生成器，装饰器
生成器：

创建python迭代器的过程虽然强大，但是很多时候使用不方便。生成器是一个简单的方式来完成迭代。简单来说，Python的生成器是一个返回可以迭代对象的函数。

为什么使用生成器

更容易使用，代码量较小，内存使用更加高效。比如列表是在建立的时候就分配所有的内存空间，而生成器仅仅是需要的时候才使用，更像一个记录代表了一个无限的流。如果我们要读取并使用的内容远远超过内存，但是需要对所有的流中的内容进行处理，那么生成器是一个很好的选择，比如可以让生成器返回当前的处理状态，由于它可以保存状态，那么下一次直接处理即可。

流水线生成器

最简单的生成器：

g = (x*x for x in range(10))for i in g:     print(i)

 

函数方法实现稍复杂的生成器：

def fib(max):     n,a,b=0,1,1     while n<max:         yield b         a,b=b,a+b         n +=1for n in fib(6):     print(n)

 

 

迭代器概述

可以直接作用于for循环的数据类型有以下几种：

一类是集合数据类型,如list,tuple,dict,set,str等

一类是generator ，包括生成器和带yeild的generator function

这些可以 直接作用于for循环的对象统称为可迭代对象：Iterable

可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator

def hs(n):     i=0     while i<n:         yield i         i+=1a=(hs(1000))print(next(a))print(next(a))print(next(a))print(next(a))print(next(a))

 

装饰器：

基本概念：在函数调用前后自动打印日志，又不改变原函数，在代码运行期间动态增加功能的方式称之为“装饰器”。

装饰器的语法以@开头，接下来是装饰器函数的名字和可选的参数，紧跟着装饰器声明的是被修饰的函数和装饰函数的可选参数。

**3大特征：**1,外部函数包含内部函数，2，返回一个内部函数，3，内部函数用到外部函数的变量

import timedef hs(f):#装饰器的函数，f接受被装饰的函数名     def neibu():#装饰内部函数         start=time.time()         f()#调用被装饰的函数         end=time.time()         print(end-start)     return neibu#装饰器返回内部函数，（内部代表的是包装盒）@hs#@加函数名，代表下面的函数被hs装饰def jisuan():     print('123456') jisuan()

 

4.Python的数据类型
Number（数字） 包括int,long,float,complex

String（字符串） 例如：hello,“hello”,hello

List（列表） 例如：[1,2,3],[1,2,3,[1,2,3],4]

Dictionary（字典） 例如：{1:“nihao”,2:“hello”}

Tuple（元组） 例如：(1,2,3,abc)

Bool（布尔） 包括True、False

 

九.协议问题：
1.robots协议是什么？
Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。

 

1.http协议，请求由什么组成，每个字段分别有什么用，https和http有什么差距

请求行（request line）、请求头部（header）、空行和请求数据四个部分组成（详情）；

 

请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本；
请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息；
空行，请求头部后面的空行是必须的；
④请求数据也叫主体，可以添加任意的其他数据；

　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

 

HTTPS和HTTP的区别主要如下：

 

https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
④ http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

 

2.证书问题
https://blog.csdn.net/fangqun663775/article/details/55189107

 

3.TCP，UDP各种相关问题
https://blog.csdn.net/xiaobangkuaipao/article/details/76793702

 

十.数据提取问题：
1.主要使用什么样的结构化数据提取方式，可能会写一两个例子
JSON文件

JSON Path

转化为Python类型进行操作（json类）

 

XML文件

转化为Python类型（xmltodict）

XPath

CSS选择器

正则表达式

详情：https://www.cnblogs.com/miqi1992/p/7967399.html

 

2.正则的使用
http://tool.oschina.net/uploads/apidocs/jquery/regexp.html

文本、电话号码、邮箱地址

"^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\d{8}KaTeX parse error: Can't use function '\.' in math mode at position 34: …[a-zA-Z0-9_-]+(\̲.̲[a-zA-Z0-9_-]+)…

元字符     含义

.        匹配除换行符以外的任意一个字符

^       匹配行首

$       匹配行尾

？     重复匹配0次或1 *       重复匹配0次或更多次 +     重复匹配1次或更多次

{n,}   重复n次或更多次

{n,m}         重复n~m次

[a-z] 任意字符

[abc]         a/b/c中的任意一个字符

{n}    重复n次

\b     匹配单词的开始和结束

\d     匹配数字

\w    匹配字母，数字，下划线

\s      匹配任意空白，包括空格，制表符（Tab）,换行符

\W    匹配任意不是字母，数字，下划线的字符

\S      匹配任意不是空白符的字符

\D     匹配任意非数字的字符

\B     匹配不是单词开始和结束的位置

[^a]  匹配除了a以外的任意字符

[^(123|abc)]     匹配除了123或者abc这几个字符以外的任意字符

 

3.动态加载的数据如何提取
爬取动态页面目前来说有两种方法

分析请求页面
通过Selenium模拟浏览器获取(不推荐这种,太慢)
分析很简单，我们只需要打开了浏览器Ｆ12开发者模式，获取它的js请求文件（除JS选项卡还有可能在XHR选项卡中，当然 也可以通过其它抓包工具）

我们打开第一财经网看看，发现无法获取元素的内容

打开Ｎetwork，看下它的请求，这里我们只看它的 j s 请求就够了, 找到json接口

将它的url放到浏览器看下,发现是我们要的数据,就可以获取了

一些网站所有的接口都进行了加密操作，我们无法解析ｊｓ,就必须采用selenium+phantomjs进行获取

 

4.json数据如何提取
采用正则表达式解析：获取整个json数据后，采用正则表达式匹配到关键词；

使用eval解析

json.loads() 是把Json格式字符串解码转换成Python对象，如果在json.loads的时候出错，要注意被解码的Json字符的编码，json.dumps() 是把json_obj 转换为json_str

 

十一、其他常见面试
1、Post 和 Get 区别
①GET数据传输安全性低，POST传输数据安全性高，因为参数不会被保存在浏览器历史或web服务器日志中；

②在做数据查询时，建议用GET方式；而在做数据添加、修改或删除时，建议用POST方式；

GET在url中传递数据，数据信息放在请求头中；而POST请求信息放在请求体中进行传递数据；
④GET传输数据的数据量较小，只能在请求头中发送数据，而POST传输数据信息比较大，一般不受限制；

⑤在执行效率来说，GET比POST好

 

2、Python里面如何拷贝一个对象？（赋值，浅拷贝，深拷贝的区别）
赋值：把等号右边的数据，存储到左边变量所开辟的内存空间中

浅拷贝：只拷贝引用不拷贝对象本身，一旦有一个引用修改，所有的引用都会被迫修改

深拷贝：直接拷贝对象本身，产生一个新的对象，并且产生一个新的引用；就是在内存中重新开辟一块空间，不管数据结构多么复杂，只要遇到可能发生改变的数据类型，就重新开辟一块内存空间把内容复制下来，直到最后一层，不再有复杂的数据类型，就保持其原引用。这样，不管数据结构多么的复杂，数据之间的修改都不会相互影响

 

3、什么是线程和进程?
进程：一个程序在操作系统中被执行以后就会创建一个进程，通过进程分配资源（cpu、内存、I/O设备），一个进程中会包含一到多个线程，其中有一个线程叫做主线程用于管理其他线程。一个正在运行的程序可以看做一个进程，进程拥有独立运行所需要的全部资源。（例如：打开QQ相当于开启一个进程）

线程：程序中独立运行的代码段。在一个进程执行的过程，一般会分成很多个小的执行单位，线程就是这些执行单位；在处理机调度，以线程为单位件进行，多个线程之间并发执行，线程占用的是cpu。

一个程序至少拥有一个进程，一个进程至少拥有一个线程。进程负责资源的调度和分配，线程才是程序真正的执行单元，负责代码的执行。

多线程

多线程定义：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。

多线程优点：可以提高CPU的利用率。在多线程程序中，一个线程必须等待的时候，CPU可以运行其它的线程而不是等待，这样就大大提高了程序的效率。

所以为了提高爬虫的效率，我们可以使用多线程来下载文件，在python中我们使用threading模块来创建多线程，从而实现多线程爬虫。（补充：Python3不能再使用thread模块）。

多线程使用的场合：耗时操作（访问外存，即：I/O，访问网络资源），为了不阻碍主线程或者其他的操作，一般会采用多线程。

 

4、爬虫使用多线程好？还是多进程好？为什么？
对于IO密集型代码（文件处理，网络爬虫），多线程能够有效提升效率（单线程下有IO操作会进行IO等待，会造成不必要的时间等待，而开启多线程后，A线程等待时，会自动切换到线程B，可以不浪费CPU的资源，从而提升程序执行效率）。

在实际的采集过程中，既考虑网速和相应的问题，也需要考虑自身机器硬件的情况，来设置多进程或者多线程。

 

5、什么是协程?
协程是：在一个线程执行过程中可以在一个子程序的预定或者随机位置中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。他本身是一种特殊的子程序或者称作函数。

遇到IO密集型的业务时，多线程加上协程，你磁盘在那该读读该写写，我还能去干点别的。在WEB应用中效果尤为明显。

协程的好处：

跨平台

跨体系架构

无需线程上下文切换的开销

无需原子操作锁定及同步的开销

方便切换控制流，简化编程模型

高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。

 

6、什么是并行和并发?
并行：多个进程在同一时刻同时进行

并发：多个进程在同一时间段内交替进行 （操作系统大多采用并发机制），根据一定的算法(常见的就是时间片轮询算法)

 

7，__new)_和__init__的区别
new:它是创建对象时调用，会返回当前对象的一个实例，可以用_new_来实现单例

init:它是创建对象后调用，对当前对象的一些实例初始化，无返回值

 

8，列举爬虫用到的网络数据包，解析包？
网络数据包 urllib、urllib2、requests

解析包 re、xpath、beautiful soup、lxml

 

9.如何显著提升爬虫的效率
使用性能更好的机器

使用光纤网络

多进程

多线程

分布式

 

10.如何提升scrapy的爬取效率
(1)增加并发

默认scrapy开启的并发线程为32个, 可以适当进行增加. 在settings配置文件中修改`CONCURRENT_REQUESTS = 100值为100, 并发设置成了为100.

(2)降低日志级别

在运行scrapy时, 会有大量日志信息的输出, 为了减少CPU的使用率. 可以设置log输出信息为INFO或者ERROR. 在配置文件中编写: LOG_LEVEL = ‘INFO’

(3)禁止cookie

如果不是真的需要cookie, 则在scrapy爬取数据时可以禁止cookie从而减少CPU的使用率, 提升爬取效率. 在配置文件中编写: COOKIES_ENABLED = False.

(4)禁止重试

对失败的HTTP进行重新请求(重试)会减慢爬取速度, 因此可以禁止重试. 在配置文件中编写: RETRY_ENABLED = False

(5)减少下载超时

如果对一个非常慢的链接进行爬取, 减少下载超时可以能让卡住的链接快速被放弃, 从而提升效率. 在配置文件中进行编写: DOWNLOAD_TIMEOUT = 10 超时时间为10s.

 

11，使用redis搭建分布式系统时如何处理网络延迟和网络异常？
由于网络异常的存在，分布式系统中请求结果存在“三态”的概念，即三种状态：“成功”、“失败”、“超时（未知）”

当出现“超时”时可以通过发起读取数据的操作以验证 RPC 是否成功（例如银行系统的做法）

另一种简单的做法是，设计分布式协议时将执行步骤设计为可重试的，即具有所谓的“幂等性”

 

12.你是否了解mysql数据库的几种引擎？
InnoDB：

InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。

在以下场合下，使用InnoDB是最理想的选择：

1.更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。

2.事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。

3.自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。

4.外键约束。MySQL支持外键的存储引擎只有InnoDB。

5.支持自动增加列AUTO_INCREMENT属性。

一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。

MEMORY：

使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。

虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。

获得速度的同时也带来了一些缺陷。

一般在以下几种情况下使用Memory存储引擎：

1.目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。

2.如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。

3.存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。

 

十二、 Tornado
什么是RESTful

全称：Representational State Transfer

是HTTP协议（1.0和1.1）的主要设计者Roy Thomas Fielding提出

资源（Resources） 表现层（Representational ）状态转化（State Transfer）

是实现API的一种风格

RESTful风格

Resources（资源）：使用URL指向一个实体，例如：网页是资源，媒体也是资源

Representational （表现层）：资源的表现形式，例如：图片，HTML文本等

State Transfer（状态转化）：GET, POST, PUT, DELETE HTTP动词操作资源

例如后端的增删改查，增删改查可以和http请求联系起来

常用HTTP动词

RESTful解释：

GET, POST, PUT, DELETE 分别用来 获取，新建，更新，删除资源

幂等性：GET, PUT, DELETE

幂等性是指无论一次还是多次操作都具有一样的副作用

POST不具有幂等性，因为post每次都创建一个新的，

对于幂等性操作可以我们可以放心的发多次操作

对于非幂等性我，我们需要在后台保证发送多次不会创建多次

Tornado RESTful Api示例

 

MVC框架：

M:model表示操作数据库层

V:view表示视图层

C:controller 表示业务逻辑层

我们省略视图层，来实现微服务，进行用户管理（增删改查）

 

十三、python基础代码
画三角形星号
cs = int(input('请输入层数:'))for i in range(cs):     j = 1     while j<=2*i+1:         print('*',end='')         j+=1     print()

 

求一个数的倒过来得数
i = int(input('请输入一个整数：')) j = 0while i>0:     j = j*10+i%10     i//=10print(j)

 

求一个元素在列表里出现了几次
a = [1, 1, 5, 2, 5, 2, 5, 2, 6,] b = set(a)for i in b:     print(i,a.count(i))

 

查找变量的顺序
- LEGB法则

L-----LOCAL 局部

E-------ENCLOSE------嵌套作用域

G-------GLOBLE-------全局

B---------BUILT-IN------内置

a = 100b = 2c = 10def waibu():     b=200     c=2     def neibu():         c=300         print(c)#LOCAL局部变量         print(b)#ENCLOSE嵌套         print(a)#GLOBAL全局         print(max)#BUILT-IN内置     neibu() waibu()

 

递归阶乘
def jiecheng(n):     if  n==1:         return 1     else:         return n*jiecheng(n-1) s=jiecheng(5)print(s)

 

a=[lambda x:x*i for i in range(3)]print(a[0](3)) # 6print(a[1](3)) # 6print(a[2](3)) # 6

 

 

 

class A():     def __init__(self):         print('A开始')         print('A结束')class B(A):     def __init__(self):         print('B开始')         super().__init__()         print('B结束')class C(A):     def __init__(self):         print('C开始')         super().__init__()         print('C结束')class D(B, C):     def __init__(self):         print('D开始')         super().__init__()         print('D结束') d = D()

输出结果为：

D开始

B开始

C开始

A开始

A结束

C结束

B结束

D结束

 

单例
class   Car():     def __new__(cls, *args, **kwargs):         if not hasattr(Car,'inst'):#如果Car里面没有inst属性             Car.inst=object.__new__(Car)#就建立一个Car对象，给inst属性         return Car.inst#返回一个属性inst     def __init__(self,name,cid):         print('你好')         self.name=name         self.cid=cid a=Car('宝马','京A66666') b=Car('奔驰','京B66666')print(a.name,a.cid)print(b.name,b.cid)输出： 你好 你好 奔驰 京B66666 奔驰 京B66666

 

多态
class   A():     def j(self):         print('aaa')class   B():     def j(self):         print('bbb')class   C():     def j(self):         print('ccc')def e(d):     d.j() f=A() g=B() k=C() e(f) e(g) e(k)

 

观察者模式
class   Resi():     def __init__(self):         self.obsv=[]         self.stautus=''     def attach(self,ob):         self.obsv.append(ob)     def notify(self):         for x in self.obsv:             x.update()class   Observe():     def __init__(self,name,rs):         self.name=name         self.rs=rs     def update(self):         print('%s %s 请不要打游戏了'%(self.rs.status,self.name))class   Manager():     def __init__(self,name,boss):         self.name=name         self.boss=boss     def update(self):         print('%s %s 请到北京饭店开会'%(self.boss.status,self.name))if  __name__=='__main__':     resi=Resi()     obj_zs=Observe('张三',resi)     obj_ls=Observe('李四',resi)     obj_xh=Observe('小红',resi)     m_lqd=Manager('刘强东',resi)     m_my=Manager('马云',resi)     resi.attach(obj_zs)     resi.attach(obj_ls)     resi.attach(obj_xh)     resi.attach(m_lqd)     resi.attach(m_my)     resi.status='老板来啦'resi.notify()

 

策略模式
class   CashNormal():     def accept_money(self,money):         return moneyclass   CashRate():     def __init__(self,rate):         self.rate=rate     def accept_money(self,money):         return money*self.rateclass   CashReturn():     def __init__(self,conditon,ret):         self.conditon=conditon         self.ret=ret     def accept_money(self,money):         return money-(money//self.conditon)*self.retclass   Context():     def __init__(self,cs):         self.cs=cs     def get_result(self,money):        return self.cs.accept_money(money)if __name__ == '__main__':     zd={}     zd[1]=Context(CashNormal())     zd[2]=Context(CashRate(0.8))     zd[3]=Context(CashReturn(300,50))     celue=int(input('请输入策略'))     if celue in zd.keys():         cs=zd[celue]     else:         cs=zd[1]     money=float(input('请输入金额'))print(cs.get_result(money))

 

工厂模式
class   Bmw():     def __init__(self,name):         self.name=nameclass   Benz():     def __init__(self,name):         self.name=nameclass   Carfactory:     @staticmethod     def makecar(name):         if name=='宝马':             return Bmw(name)         elif    name=='奔驰':             return Benz(name) car=Carfactory.makecar('宝马')print(car.name,type(car)) car1=Carfactory.makecar('奔驰')print(car1.name,type(car1))

 

析构函数
class   A():     count=0     def __init__(self,name):         self.name=name         A.count+=1         print('加上',self.name,'还有%d个对象'%A.count)     def __del__(self):         A.count-=1         print('删除',self.name,'还剩%d个对象'%A.count) a=A('张三') b=A('李四')del adel b

 

二分查找
# 重要前提：二分查找的前提是有序

# 例如：【2，5,1,4,1,3】

# 先排序：【1,1,2,3,4,5】

# 先拿出列表中间的那个元素，和num进行比较，如果num大于中间的那个元素，

# 则表明：应该下次在中间和末尾之间的元素查找

# 如果num小于中间的这个元素，则表明：num在开始的元素和中间元素之间

list_1=[2,5,1,4,1,3] list_1.sort()print("排序之后的列表：",list_1) num=int(input("请输入你要查找的数字：")) first=0last=len(list_1)-1while   first<last:     mid=(first+last)//2     if list_1[mid]==num:         print("找到了")         break     elif    list_1[mid]>num:         last=mid-1     elif    list_1[mid]<num:         first=mid+1else:     print("没找到") list_1.sort()print("拍完序之后的列表为：",list_1) num=int(input("请输入你要查找的数字：")) first=0last=len(list_1)-1while   first<last:     mid=(first+last)//2     if  list_1[mid]==num:         print("找到啦")         break     elif    list_1[mid]<num:         first=mid+1     elif    list_1[mid]>num:         last=mid-1else:     print("谁知道在哪")

 

冒泡排序
冒泡排序算法的运作如下：

比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。

对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

针对所有的元素重复以上的步骤，除了最后一个。

持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

 

list_1=[2,3,1,5,6,4] gs=len(list_1)for i in range(0,gs-1):     for j in range(0,gs-i-1):         if list_1[j]>list_1[j+1]:             list_1[j],list_1[j+1]=list_1[j+1],list_1[j]print(list_1)

 

空心塔型
cs = int(input("请输入要打印的层数:"))for i in range(cs):     for j in range(cs-i-1):         print(' ',end='')     for k in range(2*i+1):         if k==0 or k==2*i or i==cs-1:#条件控制输出的空心塔型             print('*',end='')         else:             print(' ',end='')     i+=1     print()

    请输出要打印的层数7

      *

     * *

    *   *

   *     *

  *       *

 *         *

*************

 

塔型
cs = int(input("请输入需要打印的层数："))for i in range(cs):     for j in range(cs-i-1):         print(' ',end='')     for k in range(2*i+1):#这里的范围取值决定了塔型每行的字符数         print('*',end='')     i+=1     print()

 

输出：

       *

      ***

     *****

    *******

   *********

  ***********

 *************

***************

 

 

 

 

十四、笔试题
1、python 常用数据结构有哪些？请简要介绍一下。
①列表：list=[val1,val2,val3,val4] ②元组:tuple=(val1,val2,val3,val4) ③字典：dict={key1:val1,key2:val2} ④集合：set={val1,val2,val3,val4}

 

简要描述 Python 中单引号、双引号、三引号的区别。

①单引号中可以使用双引号，中间的会当做字符串输出

②双引号中可以使用单引号，中间的会当做字符串输出

三单引号和三双引号中间的字符串在输出时保持原来的格式
 

2、如何在一个 function 里面设置一个全局的变量？
Global VarName

 

3、Python 里面如何拷贝一个对象？（赋值、浅拷贝、深拷贝的区别）
1.赋值: 只是复制了新对象的引用，不会开辟新的内存空间。 2.浅拷贝: 创建新对象，其内容是原对象的引用。     浅拷贝有三种形式：切片操作，工厂函数，copy模块中的copy函数。     如： lst = [1,2,3,[4,5]]     切片操作：lst1 = lst[:] 或者 lst1 = [each for each in lst]     工厂函数：lst1 = list(lst)     copy函数：lst1 = copy.copy(lst)

浅拷贝之所以称为浅拷贝，是它仅仅只拷贝了一层，在lst中有一个嵌套的list[4,5]，如果我们修改了它，情况就不一样了。

3.深拷贝：只有一种形式，copy模块中的deepcopy函数。      和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。      深拷贝出来的对象是一个全新的对象，不再与原来的对象有任何关联。

如果 custname 字符串的内容为 utf-8 的字符，如何将 custname 的内容转为 gb18030 的字符串？

custname = custname.decode(‘utf-8’).encode(‘b18030’)

 

4、请写出一段 Python 代码实现删除一个 list 里面的重复元素。
②利用集合set特性，元素是非重复的

a = [1,2,3,4,5,1,2,3]def fun1(a):     a=list(set(a))     print(a) fun1(a)

 

①利用字典的from keys来自动过滤重复值

a = [1, 2, 3, 4, 5, 1, 2, 3]def fun1(a):     b = {}     b = b.fromkeys(a)     c = list(b.keys())     print(c) fun1(a)

 

5、这两个参数是什么意思：args，*kwargs？
 首先，我想说的是*args和**kwargs并不是必须这样写，只有前面的*和**才是必须的。你可以写成*var和**vars。而写成*args和**kwargs只是约定俗称的一个命名规定。

*args和*kwargs主要用于函数定义，你可以将不定量的参数传递给一个参数。其中*args是用来发送一个非键值对的可变数量的参数列表给一个函数；**kwargs 允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函数里处理带名字的参数, 你应该使用**kwargs。

这里传递了3个参数，按位置传参，'123'为test传参，'hello'和'2019'为*args传参，这里传了2个参数。

def import_args(test, *args):     print('param1', test)     for item in args:         print('other param', item) import_args('123', 'hello', '2019')

 

注意，看下面的*args的另一种用法：用来解压数据。

 

def import_args(test, *args):

print('param1', test)    

for item in args:        

    print('other param', item)

args = ['hello', '2019']

import_args('123', *args)

 

输出结果：

1 param1 123

2 other param hello

3 other param 2019

 

这段代码和上面的效果是一样的，但是这里第8行的*args和第1行的*args可是不一样的。第一行是表示函数可以接受不定数量的非键值对的参数，用来传参使用的。第八行是用来解压列表

['hello', '2019']的每一项数据的，用来解压参数的。这是*args的两种用法，也可说是*的两种用法，因为args是可变的。

接下来说说**kwargs。

 

 def import_kwargs(test, **kwargs):

     print('param1', test)

     for key, value in kwargs.items():

         print(key, value)

 

 

 d = {'name': 'jack', 'age': 26}

 import_kwargs('123', **d)

 

**kwargs用来传递带键值对的参数，而**也是用来解压字典容器内的参数。

输出结果：

param1 123

name jack

age 26

总结：*args和**kwargs都是用于函数中传递参数的，*args传递的是非键值对的参数，**kwargs传递的是带键值对的参数，如果还有普通参数需要传递，那么应该先传递普通的参数。

 

6、统计如下 list 单词及其出现次数。
a=['apple', 'banana', 'apple', 'tomato', 'orange', 'apple', 'banana', 'watermeton']

方法一：

利用字典

1 a = ['apple', 'banana', 'apple', 'tomato', 'orange', 'apple', 'banana', 'watermeton']
2 dic = {}
3 for key in a:
4     dic[key] = dic.get(key, 0) + 1
5 print(dic)
输出结果：

1 {'apple': 3, 'banana': 2, 'tomato': 1, 'orange': 1, 'watermeton': 1}
 

方法二：

利用python的collections包。

1 from collections import Counter
2 
3 a = ['apple', 'banana', 'apple', 'tomato', 'orange', 'apple', 'banana', 'watermeton']
4 d = Counter(a)
5 print(d)
输出结果：

1 Counter({'apple': 3, 'banana': 2, 'tomato': 1, 'orange': 1, 'watermeton': 1})  # 是一个类似字典的结构
 

7、给列表中的字典排序：假设有如下 list 对象
alist=[{"name":"a", "age":20}, {"name":"b", "age":30}, {"name":"c", "age":25}]，将 alist 中的元素按照 age 从大到小排序。

利用list的内建函数，list.sort()来进行排序。

1 alist = [{"name": "a", "age": 20}, {"name": "b", "age": 30}, {"name": "c", "age": 25}]
2 alist.sort(key=lambda x: x['age'])
3 print(alist)
这是一种效率很高的排序方法。

输出结果：

1 [{'name': 'a', 'age': 20}, {'name': 'c', 'age': 25}, {'name': 'b', 'age': 30}]
 

8、写出下列代码的运行结果
1 a = 1
2 def fun(a):
3     a = 2
4 fun(a)
5 print(a)
1
分析，在函数外面定义了一个全局变量a为1，在函数内部定义了一个局部变量a为2。局部变量在离开函数后就失效了。

所以，结果为全局变量的a的值。如果在a=2之前加上global a，声明为全局变量，那么结果为2。

1 a = []
2 def fun(a):
3     a.append(1)
4 fun(a)
5 print(a)
[1]
这是因为，将a传入到function中，这相当于对a进行赋值引用。由于a是可变类型的，所以在函数内部修改a的时候，外部的全局变量a也跟着变化。
1 class Person:
2     name = 'Lily'
3  
4 p1 = Person()
5 p2 = Person()
6 p1.name = 'Bob'
7 print(p1.name)
8 print(p2.name)
9 print(Person.name)
Bob,Lily,Lily

 

9、假设有如下两个 list：a = ['a', 'b', 'c', 'd', 'e']，b = [1, 2, 3, 4, 5]，将 a 中的元素作为 key，b 中元素作为 value，将 a，b 合并为字典。
a = ['a', 'b', 'c', 'd', 'e']

b = [1, 2, 3, 4, 5]

dic=dict(zip(a,b))

print(dic)
 

使用 python 已有的数据结构，简单的实现一个栈结构。

class Stack(object):

    def __init__(self,size):

        self.size=size

        self.stack = []

        self.top = 0     # 初始化，top=0是则为空栈



    def push(self,x):

        if self.stackFull():# 进栈之前检查栈是否已满

            raise Exception("overflow")

        else:

            self.stack.append(x)

            self.top=self.top+1 #push进去的第一个元素为下标为1



    def pop(self):

        if self.stackEmpty():

            raise Exception('underflow!')

        else:

            self.top=self.top-1

            return self.stack.pop()#利用Python内建函数pop()实现弹出



    def stackEmpty(self):

        if self.top ==0:

            return True

        else:

            return False



    def stackFull(self):

        if self.top == self.size:

            return True

        else:

            return False



if __name__=='__main__':

    s=Stack(10)

    for i in range(9):

        s.push(i)

        s.pop()

    print(s.top)

    print(s.size)

    print(s.stack)
 

十五、面试官提的问题
1、项目上遇到了哪些难点？如何解决？
验证码

2、数据如何去重，清洗，存入数据库？
去重：https://www.cnblogs.com/518894-lu/p/9119559.html

清洗：https://blog.csdn.net/a13526863959/article/details/84587143，

https://blog.csdn.net/wanght89/article/details/78188591

 

3、有一个升序后又降序的数组，比如 1356742，如何查找到 2 的位置。
# _*_ coding:UTF-8 _*_

from click._compat import raw_input



def find(list,a):

    for i in range(1,len(list)):

        if list[i]==a:

            print(i)

    else:

        return None

find(raw_input('请输入列表：'),raw_input('请输入要查找的元素：'))
解决方法2： 使用python的内建函数enumerate

enumerate() 解析：同时枚举出序列的下标和值，这个是一个非常有用的函数，可以避免很多丑陋的代码

# _*_ coding:UTF-8 _*_

from click._compat import raw_input



def find(list,a):

    for i,item in enumerate(list):

        if item==a:

            print(i)

    else:

        return None

find(raw_input('请输入列表：'),raw_input('请输入要查找的元素：'))
 

十六、110道python面试笔试题汇总
1、一行代码实现1--100之和
利用sum()函数求和

print(sum(range(0,101)))

5050

 

2、如何在一个函数内部修改全局变量
利用global 修改全局变量

 a = 5

def fn():

    global a

    a=4

fn()

print(a)
4
 

3、列出5个python标准库
os：提供了不少与操作系统相关联的函数

sys:   通常用于命令行参数

re:   正则匹配

math: 数学运算

datetime:处理日期时间

 

4、字典如何删除键和合并两个字典
del和update方法

dic = {'height':'28','age':'12'}del dic['age']print(dic) {'height': '28'} dic.update({'name':'22'})print(dic) {'height': '28', 'name': '22'}

 

5、谈下python的GIL
GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。

多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大

 

6、python实现列表去重的方法
先通过集合去重，再转列表

list = [1,5,8,8,2,1,1,5,2,1,1,1] a= set(list)print(a) {8, 1, 2, 5} b = [x for x in a]print(b) [8, 1, 2, 5]

 

7、fun(*args,**kwargs)中的*args,**kwargs什么意思？
首先，我想说的是*args和**kwargs并不是必须这样写，只有前面的*和**才是必须的。你可以写成*var和**vars。而写成*args和**kwargs只是约定俗称的一个命名规定。

*args和*kwargs主要用于函数定义，你可以将不定量的参数传递给一个参数。这里的不定的意思是：预先并不知道函数使用者会传递多少个参数给你，所以在这个场景下使用者两个关键字。其中*args是用来发送一个非键值对的可变数量的参数列表给一个函数；**kwargs 允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函数里处理带名字的参数, 你应该使用**kwargs。

 

8、python2和python3的range（100）的区别
python2返回列表，python3返回迭代器，节约内存

 

9、一句话解释什么样的语言能够用装饰器?
函数可以作为参数传递的语言，可以使用装饰器

 

10、python内建数据类型有哪些
整型--int

布尔型--bool

字符串--str

列表--list

元组--tuple

字典—dict

 

11、简述面向对象中__new__和__init__区别
__init__是初始化方法，创建对象后，就立刻被默认调用了，可接收参数，如下

class Bike:

    def __init__(self,newWheelNum,NewColor):

        self.wheelNum = newWheelNum

        self.color = NewColor

    #__init__方法自动被调回，可以创建对象接受参数

    def move(self):

        print('车会跑')



#创建对象

BM = Bike(2,'green')

print('车的颜色为：%s' %BM.color)

print('车的轮子数量为：%d' %BM.wheelNum)

车的颜色为：green

车的轮子数量为：2

#只打印__init__方法执行的结果，move方法未执行
1、__new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别

2、__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类（通过super(当前类名, cls)）__new__出来的实例，或者直接是object的__new__出来的实例

3、__init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值

4、如果__new__创建的是当前类的实例，会自动调用__init__函数，通过return语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。

class A(object):     def __init__(self):         print('这是init方法',self)     def __new__(cls):         print('这是cls的ID:',id(cls))         print('这是new方法',object.__new__(cls))         return object.__new__(cls) A()print('这是类A的ID:',id(A))这是cls的ID: 47677960  #cls和类ID一样，说明指向同一个类，也就是cla就是创建的实例类这是new方法 <__main__.A object at 0x00307350>#init方法中的self和new方法返回值地址一样这是init方法 <__main__.A object at 0x00307350>#说明返回值是对象这是类A的ID: 47677960#cls和类ID一样，说明指向同一个类，也就是cla就是创建的实例类

 

12、简述with方法打开处理文件帮我我们做了什么？
打开文件在进行读写的时候可能会出现一些异常状况，如果按照常规的f.open写法，我们需要try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要执行finally f.close()关闭文件

f = open("./1.txt",'wb')try:     f.writ("hello world")except:     pass finally:     f.close()

with方法帮我们实现了finally中f.close（当然还有其他自定义功能，有兴趣可以研究with方法源码）

with open('/path/to/file', 'r') as f:     print(f.read())

 

13、列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]
map（）函数第一个参数是fun，第二个参数是一般是list，第三个参数可以写list，也可以不写，根据需求

list = [1,2,3,4,5]def fn(x):     return x**2res = map(fn,list) res = [i for i in res if i >10]print(res) [16, 25]

 

14、python中生成随机整数、随机小数、0--1之间小数方法
随机整数：random.randint(a,b),生成区间内的整数

随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数

0-1随机小数：random.random(),括号中不传参

import random

import numpy as np

result = random.randint(10,20)#区间

res = np.random.randn(5)

ret = random.random()#不能传数值

print('正整数：',result)

print('5个随机小数:',res)

print('0-1随机小数;',ret)

正整数： 14

5个随机小数: [-0.67833428  1.53692927  0.33841477 -1.24463382 -0.27630526]

0-1随机小数; 0.2925398128464497
 

15、避免转义给字符串加哪个字母表示原始字符串？
r , 表示需要原始字符串，不转义特殊字符

 

16、<div class="nam">中国</div>，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的
import re str = '<div class="nam">中国</div>'re = re.findall(r'<div class=".*">(.*?)</div>',str)#".*"中 .代表可有可无，*代表任意字符，满足类名可以变化，（.*？）提取文本print(re) ['中国']

 

17、python中断言方法举例
assert（）方法，断言成功，则程序继续执行，断言失败，则程序报错

a=3assert (a>1)print("断言成功，程序继续向下执行") b=4assert (b>7)print("断言失败，程序报错")

断言成功，程序继续向下执行

Traceback (most recent call last):

  File "F:/items/生成器.py", line 6, in <module>

    assert (b>7)

AssertionError

 

 

18、数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句
select  distinct  name  from  student

 

19、10个Linux常用命令
ls  pwd  cd  touch  rm  mkdir  tree  cp  mv  cat  more  grep  echo 

 

20、python2和python3区别？列举5个
1、Python3 使用 print 必须要以小括号包裹打印内容，比如 print('hi')

Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print 'hi'

2、python2 range(1,10)返回列表，python3中返回迭代器，节约内存

3、python2中使用ascii编码，python3中使用utf-8编码

4、python2中unicode表示字符串序列，str表示字节序列，

python3中str表示字符串序列，byte表示字节序列

5、python2中为正常显示中文，引入coding声明，python3中不需要

6、python2中是raw_input()函数，python3中是input()函数

 

21、列出python中可变数据类型和不可变数据类型，并简述原理
不可变数据类型：数值型、字符串型string和元组tuple

不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址），如下图用id()方法可以打印对象的id

a = 3b = 4print(id(a))print(id(b))2012993360 2012993376

 

可变数据类型：列表list和字典dict；

允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。

a = [3] b = {'value':'4'}print(id(a))print(id(b)) a.append(4) b.update({'key':'3'})print(a,id(a))print(b,id(b))59785944 58015056[3, 4] 59785944{'value': '4', 'key': '3'} 58015056

 

22、s = "ajldjlajfdljfddd"，去重并从小到大排序输出"adfjl"
set去重，去重转成list,利用sort方法排序，reverse=False是从小到大排

s = "ajldjlajfdljfddd"s1 = set(s)print(s1) s=list(s1)print(s) s.sort(reverse=False)print(s) res = "".join(s)print(res) {'d', 'f', 'j', 'a', 'l'} ['d', 'f', 'j', 'a', 'l'] ['a', 'd', 'f', 'j', 'l']

adfjl

 

23、用lambda函数实现两个数相乘
sum = lambda a,b:a*b #表达式print(sum(5,4))#参数20

 

24、字典根据键从小到大排序
dict={"name":"zs","age":18,"city":"深圳","tel":"1362626627"}

dict={"name":"zs","age":18,"city":"深圳","tel":"1362626627"} list = sorted(dict.items(),key=lambda i:i[0],reverse=False)#dict.items()结果是字典的键值对元组 #i[0]表示键，i[1]表示值，通过lambda函数根据键排序print("sorted根据字典键排序:",list) new_dict={}for i in list:     new_dict[i[0]]=i[1]print("新字典:",new_dict) sorted根据字典键排序: [('age', 18), ('city', '深圳'), ('name', 'zs'), ('tel', '1362626627')]新字典: {'age': 18, 'city': '深圳', 'name': 'zs', 'tel': '1362626627'}

 

25、利用collections库的Counter方法统计字符串每个单词出现的次数"kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"
from collections import Counter a = "kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"res = Counter(a)print(res) Counter({'l': 9, ';': 6, 'h': 6, 'f': 5, 'a': 4, 'j': 3, 'd': 3, 's': 2, 'k': 1, 'g': 1, 'b': 1})

 

26、字符串a = "not 404 found 张三 99 深圳"，每个词中间是空格，用正则过滤掉英文和数字，最终输出"张三  深圳"
import re a = 'not 404 found 张三 99 深圳'list = a.split(" ")print(list) res = re.findall('\d+|[a-zA-Z]+',a)#连接多个匹配方式，先匹配数字，再匹配单词print(res)for i in res:     if i in list:         list.remove(i) new_str = " ".join(list)print(new_str) ['not', '404', 'found', '张三', '99', '深圳'] ['not', '404', 'found', '99']张三 深圳

 

 

顺便贴上匹配小数的代码，虽然能匹配，但是健壮性有待进一步确认

import re a = 'not 404 50.56 found 张三 99 深圳'list = a.split(" ")print(list) res = re.findall('\d+\.?\d*|[a-zA-Z]+',a)#连接多个匹配方式，先匹配数字，再匹配小数，再匹配单词print(res)for i in res:     if i in list:         list.remove(i) new_str = " ".join(list)print(new_str) ['not', '404', '50.56', 'found', '张三', '99', '深圳'] ['not', '404', '50.56', 'found', '99']张三 深圳

 

27、filter方法求出列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表

 

28、列表推导式求列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 

29、正则re.complie作用
re.compile是将正则表达式编译成一个对象，加快速度，并重复使用

 

30、a=（1，）b=(1)，c=("1") 分别是什么类型的数据？
 

31、两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,3,6,7,8,9]
extend可以将另一个集合中的元素逐一添加到列表中，区别于append整体添加

 

32、用python删除文件和用linux命令删除文件方法
python：os.remove(文件名)

linux:       rm  文件名

 

33、log日志中，我们需要用时间戳记录error,warning等的发生时间，请用datetime模块打印当前时间戳 “2018-04-01 11:38:54”
顺便把星期的代码也贴上了

 

34、数据库优化查询方法
外键、索引、联合查询、选择特定字段等等

 

35、请列出你会的任意一种统计图（条形图、折线图等）绘制的开源库，第三方也行
pychart、matplotlib

 

36、写一段自定义异常代码
自定义异常用raise抛出异常

37、正则表达式匹配中，（.*）和（.*?）匹配区别？
（.*）是贪婪匹配，会把满足正则的尽可能多的往后匹配

（.*?）是非贪婪匹配，会把满足正则的尽可能少匹配

 

38、简述Django的orm
ORM，全拼Object-Relation Mapping，意为对象-关系映射

实现了数据模型与数据库的解耦，通过简单的配置就可以轻松更换数据库，而不需要修改代码只需要面向对象编程,orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句,所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite....，如果数据库迁移，只需要更换Django的数据库引擎即可

 

 

39、[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]
列表推导式的骚操作

运行过程：for i in a ,每个i是【1,2】，【3,4】，【5,6】，for j in i，每个j就是1,2,3,4,5,6,合并后就是结果

还有更骚的方法，将列表转成numpy矩阵，通过numpy的flatten（）方法，代码永远是只有更骚，没有最骚

 

40、x="abc",y="def",z=["d","e","f"],分别求出x.join(y)和x.join(z)返回的结果
join()括号里面的是可迭代对象，x插入可迭代对象中间，形成字符串，结果一致，有没有突然感觉字符串的常见操作都不会玩了

顺便建议大家学下os.path.join()方法，拼接路径经常用到，也用到了join,和字符串操作中的join有什么区别，该问题大家可以查阅相关文档，后期会有答案

 

41、举例说明异常模块中try except else finally的相关意义
try..except..else没有捕获到异常，执行else语句

try..except..finally不管是否捕获到异常，都执行finally语句

 

 

 

42、python中交换两个数值
43、举例说明zip（）函数用法
zip()函数在运算时，会以一个或多个序列（可迭代对象）做为参数，返回一个元组的列表。同时将这些序列中并排的元素配对。

zip()参数可以接受任何类型的序列，同时也可以有两个以上的参数;当传入参数的长度不同时，zip能自动以最短序列长度为准进行截取，获得元组。

 

44、a="张明 98分"，用re.sub，将98替换为100
 

45、写5条常用sql语句
show databases;

show tables;

desc 表名;

select * from 表名;

delete from 表名 where id=5;

update students set gender=0,hometown="北京" where id=5

 

46、a="hello"和b="你好"编码成bytes类型
47、[1,2,3]+[4,5,6]的结果是多少？
两个列表相加，等价于extend

48、提高python运行效率的方法
1、使用生成器，因为可以节约大量内存

2、循环代码优化，避免过多重复代码的执行

3、核心模块用Cython  PyPy等，提高效率

4、多进程、多线程、协程

5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率

49、简述mysql和redis区别
redis： 内存型非关系数据库，数据保存在内存中，速度快

mysql：关系型数据库，数据保存在磁盘中，检索的话，会有一定的Io操作，访问速度相对慢

50、遇到bug如何处理
1、细节上的错误，通过print（）打印，能执行到print（）说明一般上面的代码没有问题，分段检测程序是否有问题，如果是js的话可以alert或console.log

2、如果涉及一些第三方框架，会去查官方文档或者一些技术博客。

3、对于bug的管理与归类总结，一般测试将测试出的bug用teambin等bug管理工具进行记录，然后我们会一条一条进行修改，修改的过程也是理解业务逻辑和提高自己编程逻辑缜密性的方法，我也都会收藏做一些笔记记录。

4、导包问题、城市定位多音字造成的显示错误问题

51、正则匹配，匹配日期2018-03-20
url='https://sycm.taobao.com/bda/tradinganaly/overview/get_summary.json?dateRange=2018-03-20%7C2018-03-20&dateType=recent1&device=1&token=ff25b109b&_=1521595613462'

仍有同学问正则，其实匹配并不难，提取一段特征语句，用（.*?）匹配即可

52、list=[2,3,5,4,9,6]，从小到大排序，不许用sort，输出[2,3,4,5,6,9]
利用min()方法求出最小值，原列表删除最小值，新列表加入最小值，递归调用获取最小值的函数，反复操作

53、写一个单列模式
因为创建对象时__new__方法执行，并且必须return 返回实例化出来的对象所cls.__instance是否存在，不存在的话就创建对象，存在的话就返回该对象，来保证只有一个实例对象存在（单列），打印ID，值一样，说明对象同一个

54、保留两位小数
题目本身只有a="%.03f"%1.3335,让计算a的结果，为了扩充保留小数的思路，提供round方法（数值，保留位数）

55、求三个方法打印结果
fn("one",1）直接将键值对传给字典；

fn("two",2)因为字典在内存中是可变数据类型，所以指向同一个地址，传了新的额参数后，会相当于给字典增加键值对

fn("three",3,{})因为传了一个新字典，所以不再是原先默认参数的字典

56、列出常见的状态码和意义
200 OK 

请求正常处理完毕

204 No Content 

请求成功处理，没有实体的主体返回

206 Partial Content 

GET范围请求已成功处理

301 Moved Permanently 

永久重定向，资源已永久分配新URI

302 Found 

临时重定向，资源已临时分配新URI

303 See Other 

临时重定向，期望使用GET定向获取

304 Not Modified 

发送的附带条件请求未满足

307 Temporary Redirect 

临时重定向，POST不会变成GET

400 Bad Request 

请求报文语法错误或参数错误

401 Unauthorized 

需要通过HTTP认证，或认证失败

403 Forbidden 

请求资源被拒绝

404 Not Found 

无法找到请求资源（服务器无理由拒绝）

500 Internal Server Error 

服务器故障或Web应用故障

503 Service Unavailable 

服务器超负载或停机维护

57、分别从前端、后端、数据库阐述web项目的性能优化
该题目网上有很多方法，我不想截图网上的长串文字，看的头疼，按我自己的理解说几点

前端优化：

1、减少http请求、例如制作精灵图

2、html和CSS放在页面上部，javascript放在页面下面，因为js加载比HTML和Css加载慢，所以要优先加载html和css,以防页面显示不全，性能差，也影响用户体验差

 

后端优化：

1、缓存存储读写次数高，变化少的数据，比如网站首页的信息、商品的信息等。应用程序读取数据时，一般是先从缓存中读取，如果读取不到或数据已失效，再访问磁盘数据库，并将数据再次写入缓存。

2、异步方式，如果有耗时操作，可以采用异步，比如celery

3、代码优化，避免循环和判断次数太多，如果多个if else判断，优先判断最有可能先发生的情况

数据库优化：

1、如有条件，数据可以存放于redis，读取速度快

2、建立索引、外键等

58、使用pop和del删除字典中的"name"字段，dic={"name":"zs","age":18}
59、列出常见MYSQL数据存储引擎
InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 

MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。

MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。

60、计算代码运行结果，zip函数历史文章已经说了，得出[("a",1),("b",2)，("c",3),("d",4),("e",5)]
 

dict()创建字典新方法

61、简述同源策略
 同源策略需要同时满足以下三点要求： 

1）协议相同 

 2）域名相同 

3）端口相同 

 http:www.test.com与https:www.test.com 不同源——协议不同 

 http:www.test.com与http:www.admin.com 不同源——域名不同 

 http:www.test.com与http:www.test.com:8081 不同源——端口不同

 只要不满足其中任意一个要求，就不符合同源策略，就会出现“跨域”

 

62、简述cookie和session的区别
1，session 在服务器端，cookie 在客户端（浏览器）

2、session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效，存储Session时，键与Cookie中的sessionid相同，值是开发人员设置的键值对信息，进行了base64编码，过期时间由开发人员设置

3、cookie安全性比session差

 

63、简述多线程、多进程
进程：

1、操作系统进行资源分配和调度的基本单位，多个进程之间相互独立

2、稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制

 

线程：

1、CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源

2、如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃

 

应用：

IO密集的用多线程，在用户输入，sleep 时候，可以切换到其他线程执行，减少等待的时间

CPU密集的用多进程，因为假如IO操作少，用多线程的话，因为线程共享一个全局解释器锁，当前运行的线程会霸占GIL，其他线程没有GIL，就不能充分利用多核CPU的优势

 

64、简述any()和all()方法
any():只要迭代器中有一个元素为真就为真

all():迭代器中所有的判断项返回都是真，结果才为真

python中什么元素为假？

答案：（0，空字符串，空列表、空字典、空元组、None, False）

测试all()和any()方法

 

65、IOError、AttributeError、ImportError、IndentationError、IndexError、KeyError、SyntaxError、NameError分别代表什么异常
IOError：输入输出异常

AttributeError：试图访问一个对象没有的属性

ImportError：无法引入模块或包，基本是路径问题

IndentationError：语法错误，代码没有正确的对齐

IndexError：下标索引超出序列边界

KeyError:试图访问你字典里不存在的键

SyntaxError:Python代码逻辑语法出错，不能执行

NameError:使用一个还未赋予对象的变量

 

66、python中copy和deepcopy区别
1、复制不可变数据类型，不管copy还是deepcopy,都是同一个地址当浅复制的值是不可变对象（数值，字符串，元组）时和=“赋值”的情况一样，对象的id值与浅复制原来的值相同。

2、复制的值是可变对象（列表和字典）

浅拷贝copy有两种情况：

第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。

第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表）， 改变原来的值 中的复杂子对象的值  ，会影响浅复制的值。

深拷贝deepcopy：完全复制独立，包括内层列表和字典

 

67、列出几种魔法方法并简要介绍用途
__init__:对象初始化方法

__new__:创建对象时候执行的方法，单列模式会用到

__str__:当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据

__del__:删除对象执行的方法

 

68、C:\Users\ry-wu.junya\Desktop>python 1.py 22 33命令行启动程序并传参，print(sys.argv)会输出什么数据？
文件名和参数构成的列表

69、请将[i for i in range(3)]改成生成器
生成器是特殊的迭代器，

1、列表表达式的【】改为（）即可变成生成器

2、函数在返回值得时候出现yield就变成生成器，而不是函数了；

中括号换成小括号即可，有没有惊呆了

70、a = "  hehheh  ",去除收尾空格
71、举例sort和sorted对列表排序，list=[0,-1,3,-10,5,9]
72、对list排序foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4],使用lambda函数从小到大排序
73、使用lambda函数对list排序foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4]，输出结果为
[0,2,4,8,8,9,-2,-4,-4,-5,-20]，正数从小到大，负数从大到小
（传两个条件，x<0和abs(x)）

74、列表嵌套字典的排序，分别根据年龄和姓名排序
foo = [{"name":"zs","age":19},{"name":"ll","age":54},

        {"name":"wa","age":17},{"name":"df","age":23}]

 

75、列表嵌套元组，分别按字母和数字排序
 

76、列表嵌套列表排序，年龄数字相同怎么办？
 

77、根据键对字典排序（方法一，zip函数）
 

78、根据键对字典排序（方法二,不用zip)
有没有发现dic.items和zip(dic.keys(),dic.values())都是为了构造列表嵌套字典的结构，方便后面用sorted()构造排序规则

79、列表推导式、字典推导式、生成器
80、最后出一道检验题目，根据字符串长度排序，看排序是否灵活运用
81、举例说明SQL注入和解决办法
当以字符串格式化书写方式的时候，如果用户输入的有;+SQL语句，后面的SQL语句会执行，比如例子中的SQL注入会删除数据库demo

解决方式：通过传参数方式解决SQL注入

82、s="info:xiaoZhang 33 shandong",用正则切分字符串输出['info', 'xiaoZhang', '33', 'shandong']
|表示或，根据冒号或者空格切分

83、正则匹配以163.com结尾的邮箱
84、递归求和
 

85、python字典和json字符串相互转化方法
json.dumps()字典转json字符串，json.loads()json转字典

 

86、MyISAM 与 InnoDB 区别：
1、InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高

级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM

就不可以了；

2、MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到

安全性较高的应用；

3、InnoDB 支持外键，MyISAM 不支持；

4、对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM

表中可以和其他字段一起建立联合索引；

5、清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重

建表；

 

87、统计字符串中某字符出现次数
88、字符串转化大小写
89、用两种方法去空格
90、正则匹配不是以4和7结尾的手机号
91、简述python引用计数机制
python垃圾回收主要以引用计数为主，标记-清除和分代清除为辅的机制，其中标记-清除和分代回收主要是为了处理循环引用的难题。

引用计数算法

当有1个变量保存了对象的引用时，此对象的引用计数就会加1

当使用del删除变量指向的对象时，如果对象的引用计数不为1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除

 

92、int("1.4"),int(1.4)输出结果？
int("1.4")报错，int(1.4)输出1

 

93、列举3条以上PEP8编码规范
1、顶级定义之间空两行，比如函数或者类定义。

2、方法定义、类定义与第一个方法之间，都应该空一行

3、三引号进行注释

4、使用Pycharm、Eclipse一般使用4个空格来缩进代码

 

94、正则表达式匹配第一个URL
findall结果无需加group(),search需要加group()提取

95、正则匹配中文
96、简述乐观锁和悲观锁
悲观锁, 就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

乐观锁，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量

 

97、r、r+、rb、rb+文件打开模式区别
模式较多，比较下背背记记即可

98、Linux命令重定向 > 和 >>
Linux 允许将命令执行结果 重定向到一个 文件

将本应显示在终端上的内容 输出／追加 到指定文件中

> 表示输出，会覆盖文件原有的内容

>> 表示追加，会将内容追加到已有文件的末尾

用法示例：

将 echo 输出的信息保存到 1.txt 里echo Hello Python > 1.txt 将 tree 输出的信息追加到 1.txt 文件的末尾tree >> 1.txt

 

99、正则表达式匹配出<html><h1>www.itcast.cn</h1></html>
前面的<>和后面的<>是对应的，可以用此方法

 

100、python传参数是传值还是传址？
Python中函数参数是引用传递（注意不是值传递）。对于不可变类型（数值型、字符串、元组），因变量不能修改，所以运算不会影响到变量自身；而对于可变类型（列表字典）来说，函数体运算可能会更改传入的参数变量。

 

101、求两个列表的交集、差集、并集
 

102、生成0-100的随机数
random.random()生成0-1之间的随机小数，所以乘以100

103、lambda匿名函数好处
精简代码，lambda省去了定义函数，map省去了写for循环过程

 

104、常见的网络传输协议
UDP、TCP、FTP、HTTP、SMTP等等

 

105、单引号、双引号、三引号用法
1、单引号和双引号没有什么区别，不过单引号不用按shift，打字稍微快一点。表示字符串的时候，单引号里面可以用双引号，而不用转义字符,反之亦然。

'She said:"Yes." ' or  "She said: 'Yes.' "

 

2、但是如果直接用单引号扩住单引号，则需要转义，像这样：

 ' She said:\'Yes.\' '

3、三引号可以直接书写多行，通常用于大段，大篇幅的字符串

"""

hello

world

"""

106、python垃圾回收机制
python垃圾回收主要以引用计数为主，标记-清除和分代清除为辅的机制，其中标记-清除和分代回收主要是为了处理循环引用的难题。

 

引用计数算法

当有1个变量保存了对象的引用时，此对象的引用计数就会加1

当使用del删除变量指向的对象时，如果对象的引用计数不为1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除

 

107、HTTP请求中get和post区别
1、GET请求是通过URL直接请求数据，数据信息可以在URL中直接看到，比如浏览器访问；而POST请求是放在请求头中的，我们是无法直接看到的；

2、GET提交有数据大小的限制，一般是不超过1024个字节，而这种说法也不完全准确，HTTP协议并没有设定URL字节长度的上限，而是浏览器做了些处理，所以长度依据浏览器的不同有所不同；POST请求在HTTP协议中也没有做说明，一般来说是没有设置限制的，但是实际上浏览器也有默认值。总体来说，少量的数据使用GET，大量的数据使用POST。

3、GET请求因为数据参数是暴露在URL中的，所以安全性比较低，比如密码是不能暴露的，就不能使用GET请求；POST请求中，请求参数信息是放在请求头的，所以安全性较高，可以使用。在实际中，涉及到登录操作的时候，尽量使用HTTPS请求，安全性更好。

 

108、python中读取Excel文件的方法
应用数据分析库pandas

 

109、简述多线程、多进程
进程：

1、操作系统进行资源分配和调度的基本单位，多个进程之间相互独立

2、稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制

线程：

1、CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源

2、如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃

 

应用：

IO密集的用多线程，在用户输入，sleep 时候，可以切换到其他线程执行，减少等待的时间

CPU密集的用多进程，因为假如IO操作少，用多线程的话，因为线程共享一个全局解释器锁，当前运行的线程会霸占GIL，其他线程没有GIL，就不能充分利用多核CPU的优势

 

110、python正则中search和match


python自测100题
2020-01-08阅读 580
如果你在寻找python工作，那你的面试可能会涉及Python相关的问题。

通过对网络资料的收集整理，本文列出了100道python的面试题以及答案，你可以根据需求阅读测试。

python基础

Q1.什么是Python？

Python是一种面向对象的，交互式的，解释型的计算机程序设计语言。Python的设计具有高可读性，它使用英语关键词而非标点符号，语法结构也比其他语言简单。

Q2.Python的主要功能是什么？

1）python是一种解释型语言，因此在使用python时不需要进行编译

2）声明变量和类似变量时，不需要重复声明变量的类型；

3）Python非常适合面向对象的编程，因为它允许类的定义以及组合和继承；

4）函数是第一类对象，这意味着它们可以分配给变量，从其他函数返回并传递给函数，类也是第一类对象；

5）用于许多领域，包括Web应用程序，自动化，科学建模，大数据应用程序等等。

Q3.Python中支持的数据类型有哪些？

Python支持5种数据类型：

1）Numbers（数字）——用于保存数值；

a=7.0

2）Strings（字符串）——字符串是一个字符序列，我们用单引号或双引号来声明字符串；

title="Data123"

3）Lists（列表）——列表就是一些值的有序集合，我们用方括号声明列表；

colors=['red','green','blue']

type(colors)

<class 'list'>

4）tuples（元组）——元组和列表一样，也是一些值的有序集合，区别是元组是不可变的，意味着我们无法改变元组内的值。

(1,2,3,abc)

5）Dictionary（字典）——字典(dictionary)是除列表以外Python之中最灵活的内置数据结构类型。

列表是有序的对象结合，字典是无序的对象集合。

两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。

字典用"{ }"标识。字典由索引(key)和它对应的值value组成。

dict = {}

dict['one'] = 'This is one'

dict[2] = 'This is two'

tinydict = {'name':'john','code':5762,'dept':'sales'}

print(dict['one']) #输出键为'one'的值

print(dict[2]) #输出键为2的值

print(tinydict) #输出完整的字典

print(tinydict.keys()) #输出所有键

print(tinydict.values()) #输出所有值

Q4.列表和元组有什么区别？


Q5.什么是Python模块？

模块是一个Python脚本，通常包含import语句，函数，类和变量定义，以及Python可运行代码，文件的扩展名为“.py”。

Q6.python解释器种类以及特点？

CPython：这个解释器是用C语言开发的，所以叫 CPython，在命名行下运行python，就是启动CPython解释器，CPython是使用最广的Python解释器；

IPython：IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强；

PyPy：PyPy是另一个Python解释器，它的目标是执行速度，PyPy采用JIT技术，对Python代进行动态编译，所以可以显著提高Python代码的执行速度；

Jython：Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。

IronPython：IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。

Q7.什么是Python切片？

Python中符合序列的有序序列都支持切片(slice)，如:列表,字符,元祖

Python中切片的格式：[start : end : step]

Start:起始索引,从0开始,-1表示结束；End:结束索引；Step:步长

end-start=正数时,从左向右取值,=负数时反向取值

注意:切片结果不包含结束索引,即不包含最后一位,-1代表最后一个位置索引

str1 = 'abcdefghijklmnopqrstuvwxyz'

str1[2:6]

'cdef'

Q8.Python中的％S是什么？

Python支持将值格式化为字符串。虽然这可以包括非常复杂的表达式，但最基本的用法是将值插入到%s 占位符的字符串中 。

name = raw_input("who are you?")

print "hello %s" % (name,)

Q9.Python编程中的函数是什么？

函数是表示代码块并且是可重用实体的对象。

它为程序带来了模块化，并提供了更高程度的代码可重用性。

Python为我们提供了许多内置函数，例如print（）等，并提供了创建用户定义函数的能力。

Q10.Python中有多少基本类型的函数可用？

Python为我们提供了两种基本类型的函数：内置和用户定义。

内置函数是Python语言的一部分，比如print（），dir（），len（）和abs（）等。

Q11.我们如何用Python编写函数？

我们可以通过以下方式创建Python函数。

1）用def定义函数并链接功能名称；

2）传递参数并使用括号将它们括起来，使用冒号来表示结尾；

3）添加所需的Python语句以供执行。

Q12.深拷贝和浅拷贝有什么区别？

深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。

在Python中，我们使用函数deepcopy()执行深拷贝，导入模块copy，如下所示：

import copy

b=copy.deepcopy(a)

而浅拷贝则是将一个对象的引用拷贝到另一个对象上，所以如果我们在拷贝中改动，会影响到原对象。我们使用函数function()执行浅拷贝，使用如下所示：

b=copy.copy(a)

Q13.Python中的函数调用或可调用对象是什么？

Python中的函数被视为可调用对象。它可以允许一些参数，并以元组的形式返回一个值或多个值。除了函数之外，Python还有其他构造，例如类或适合同一类别的类实例。

Q14.Python中Pass和Continue有什么区别？

continue语句使循环从下一次迭代中恢复。pass语句指示什么都不做，代码的其余部分像往常一样执行。

Q15. PYTHONPATH环境变量的目的是什么？

PYTHONPATH - 它的作用类似于PATH。此变量告诉Python解释器在何处找到导入程序的模块文件。它应该包括Python源库目录和包含Python源代码的目录。PYTHONPATH有时由Python安装程序预设。

Q16.PYTHONSTARTUP，PYTHONCASEOK，PYTHONHOME，PYTHONSTARTUP环境变量的目的是什么？

PYTHONSTARTUP - 它包含一个包含Python源代码的初始化文件的路径。每次启动解释器时都会执行它。它在Unix中命名为.pythonrc.py，它包含加载实用程序或修改PYTHONPATH的命令。

PYTHONCASEOK - 在Windows中用于指示Python在import语句中查找第一个不区分大小写的匹配项。将此变量设置为任何值以激活它。

PYTHONHOME - 它是另一种模块搜索路径。它通常嵌入在PYTHONSTARTUP或PYTHONPATH目录中，以便于切换模块库。

Q17.如何在Python中实现多线程？

python主要是通过thread和threading这两个模块来实现多线程支持。

python的thread模块是比较底层的模块，python的threading模块是对thread做了一些封装，可以更加方便的被使用。但是python（cpython）由于GIL的存在无法使用threading充分利用CPU资源，如果想充分发挥多核CPU的计算能力需要使用multiprocessing模块(Windows下使用会有诸多问题)。

python3.x中已经摒弃了Python2.x中采用函数式thread模块中的start_new_thread()函数来产生新线程方式。python3.x中通过threading模块创建新的线程有两种方法：

1）通过threading.Thread(Target=executable Method)-即传递给Thread对象一个可执行方法（或对象）

2）继承threading.Thread定义子类并重写run()方法。第二种方法中，唯一必须重写的方法是run()。

Q18.如何在python中使用三元运算符？

Ternary运算符是用于显示条件语句的运算符。这包含true或false值，并且必须为其评估语句。

三元运算符将被给出为：

[on_true] if [expression] else [on_false] x，y = 25,50big =x if x <y else y

表达式的计算方式与x <y else y一样，在这种情况下，如果x <y为真，则返回值为big = x，如果不正确则返回big = y作为结果。

Q19.什么是Tkinter ？

TKinter是一款很知名的Python库，用它我们可以制作图形用户界面。其支持不同的GUI工具和窗口构件，比如按钮、标签、文本框等等。这些工具和构件均有不同的属性，比如维度、颜色、字体等。

Q20.Python中的继承

继承允许一个类获得另一个类的所有成员（比如属性和方法）。继承提供代码可重用性，使创建和维护应用程序更容易。

Python支持的不同类型的继承：

1）单一继承 - 派生类获取单个超类的成员；

2）多级继承 - 从基类base1继承的派生类d1，d2继承自base2；

3）分层继承 - 从一个基类可以继承任意数量的子类；

4）多重继承 - 派生类从多个基类继承。

Q21.请谈谈.pyc文件和.py文件的不同之处

虽然这两种文件均保存字节代码，但.pyc文件是Python文件的编译版本，它有平台无关的字节代码，因此我们可以在任何支持.pyc格式文件的平台上执行它。

Q22.什么是酸洗和去除？

Pickle模块接受任何Python对象并将其转换为字符串表示形式，并使用dump函数将其转储到文件中，此过程称为pickling。从存储的字符串表示中检索原始Python对象的过程称为unpickling。

Q23.在Python中命名与文件相关的模块？

Python为库/模块提供了一些函数，你可以在文件系统上操作文本文件和二进制文件。使用它们完成创建文件，更新内容，复制和删除文件的操作。这些库是：os，os.path和shutil。

Q24.解释使用with声明？

在python中，通常“with”语句用于打开文件，处理文件中存在的数据，还可以在不调用close（）方法的情况下关闭文件。

Q25.解释Python支持的所有文件处理模式？

Python中可以使用三种方法打开文件。他们是：

1)通过分别指定标志“r”，“w”，“rw”，“a”，只读模式，只写模式，读写模式和附加模式;

2)通过指定选项“t”，可以在上述任何一种模式中打开文本文件;

3)“r”，“w”，“rw”和“a”，以便前面的模式变为“rt”，“wt”，“rwt”和“at”。二进制文件可以在任何一个中打开上述模式通过指定选项“b”以及“r”，“w”，“rw”和“a”使得前面的模式为“rb”，“wb”，“rwb”，“ab”。

Q26. Python支持多少种序列？

Python支持7种序列类型。它们是str，list，tuple，unicode，byte array，xrange和buffer。其中xrange在python 3.5.X中已弃用。

Q27.如何在Python中执行模式匹配？

正则表达式（RE）使我们能够指定匹配给定字符串的特定“部分”的表达式。例如，我们可以定义一个正则表达式来匹配单个字符或数字，电话号码或电子邮件地址等.Python的“re”模块提供正则表达式模式，并从Python 2.5的更高版本中引入。“re”模块提供搜索文本字符串的方法，或者替换文本字符串以及基于定义的模式拆分文本字符串的方法。

Q28.Python如何处理内存管理？

Python内存由Python私有堆空间管理。所有Python对象和数据结构都位于私有堆中。程序员无权访问此私有堆，解释器负责处理此私有堆。Python对象的Python堆空间分配由Python内存管理器完成。核心API提供了一些程序员编写代码的工具。Python还有一个内置的垃圾收集器，它可以回收所有未使用的内存并释放内存并使其可用于堆空间。

Q29.如何以相反的顺序显示文本文件的内容？

1)将给定文件转换为列表

2)使用reverse（）反转列表例如：

for reverse in reverse（list（open（“file-name”，“r”）））：

print（）

Q30.什么是负索引

Python序列可以是正数和负数的索引。对于正索引，0是第一个索引，1是第二个索引，依此类推。对于负索引，（ - 1）是最后一个索引，（ - 2）是倒数第二个索引，依此类推。

Q31.解释Python中“re”模块的split（），sub（），subn（）方法。

为了修改字符串，Python的“re”模块提供了3种方法。

1）split（） - 使用正则表达式模式将给定字符串“拆分”到列表中；

2）sub（） - 查找正则表达式模式匹配的所有子字符串，然后用不同的字符串替换它们；

3）subn（） - 它类似于sub（），并且还返回新字符串和no。替换。

Q32.解释Python Flask中的数据库连接

Flask支持数据库驱动的应用程序（RDBS）。Flask允许以三种方式请求数据库

1)before_request（）：在请求之前调用它们并且不传递任何参数

2)after_request（）：在请求后调用它们并传递将发送到客户端的响应

3)teardown_request（）：在引发异常时调用它们，并且不保证响应。它们在响应构建后被调用。不允许他们修改请求，并忽略它们的值。

Q33. range和xrange有什么区别？

在大多数情况下，xrange和range在功能方面完全相同，它们都提供了一种生成整数列表的方法。唯一的区别是range返回一个Python列表对象，x range返回一个xrange对象。

Q34.Python中的“按值调用”是什么？

在call-by-value中，表达式或值是否绑定到函数中的相应变量的参数。Python会将该变量视为函数级范围中的本地变量。对该变量所做的任何更改都将保留在本地，并且不会反映在该函数之外。

Q35.什么是Python中的“按引用调用”？

我们可以互换地使用“引用调用”和“引用传递”。当我们通过引用传递参数时，它可以作为函数的隐式引用，而不是简单的副本。在这种情况下，对参数的任何修改也将对调用者可见。

该方案还具有带来更多时间和空间效率的优点，因为它留下了创建本地副本的需要。相反，缺点可能是函数调用期间变量可能会意外更改。

Q36.Lambda和Def之间的主要区别是什么？

当lambda是uni-expression函数时，Def可以包含多个表达式。Def生成一个函数并指定一个名称以便稍后调用它。Lambda形成一个函数对象并返回。Def可以有一个return语句。Lambda不能有return语句。Lambda支持在列表和字典中使用。

Q37.ascii、unicode、utf-8、gbk 区别？

ASCII码：使用一个字节编码，所以它的范围基本是只有英文字母、数字和一些特殊符号 ，只有256个字符;

Unicode：能够表示全世界所有的字节;

GBK：是只用来编码汉字的，GBK全称《汉字内码扩展规范》，使用双字节编码;

UTF-8：是一种针对Unicode的可变长度字符编码，又称万国码。

Q38.每当Python退出时，为什么不是所有的内存都被解除分配？

每当python退出时，尤其是那些对其他对象具有循环引用的Python模块或者从全局名称空间引用的对象并不总是被解除分配或释放。由于python拥有自己的高效清理机制，无法解除分配保留的那些内存部分会在退出时尝试取消分配/销毁其他所有对象。

Q 39.解释Python的参数传递机制

Python使用按引用传递（pass-by-reference）将参数传递到函数中。如果你改变一个函数内的参数，会影响到函数的调用。这是Python的默认操作。不过，如果我们传递字面参数，比如字符串、数字或元组，它们是按值传递，这是因为它们是不可变的。

Q40.什么是猴子补丁？

在运行期间动态修改一个类或模块。

class A:

  def func(self):

      print("Hi")

def monkey(self):

print "Hi, monkey"

m.A.func = monkey

a = m.A()

a.func()

Hi, Monkey

Q41.大数据的文件读取

1）利用生成器generator

2）迭代器进行迭代遍历：for line in file

Q42.find和grep

grep命令是一种强大的文本搜索工具，grep搜索内容串可以是正则表达式，允许对文本文件进行模式查找。如果找到匹配模式，grep打印包含模式的所有行。find通常用来再特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。

Q43.线上服务可能因为种种原因导致挂掉怎么办？

linux下的后台进程管理利器 supervisor

每次文件修改后再linux执行 service supervisord restart

Q44.如何提高python的运行效率

使用生成器；关键代码使用外部功能包（Cython，pylnlne，pypy，pyrex）；针对循环的优化--尽量避免在循环中访问变量的属性

Q45.常用Linux命令

ls,help,cd,more,clear,mkdir,pwd,rm,grep,find,mv,su,date

Q46.Python中的yield用法

yield简单说来就是一个生成器，这样函数它记住上次返 回时在函数体中的位置。对生成器第 二次（或n 次）调用跳转至该函 次）调用跳转至该函数。

Q47.描述数组、链表、队列、堆栈的区别？

数组与链表是数据存储方式的概念，数组在连续的空间中存储数据，而链表可以在非连续的空间中存储数据；队列和堆栈是描述数据存取方式的概念，队列是先进先出，而堆栈是后进先出；队列和堆栈可以用数组来实现，也可以用链表实现。

Q48.如何使用我已经知道的URL地址本地保存图像？

将使用以下代码从URL地址本地保存图像:

import urllib.request

urllib.request.urlretrieve("URL", "local-filename.jpg")

Q49.如何获取任何网址或网页的Google缓存时限？

使用以下URL格式：

http://webcache.googleusercontent.com/search?q=cache:URLGOESHERE请务必将“URLGOESHERE”替换为您要检索其缓存的页面或网站的正确网址，并查看时间。

例如，要查看http://edureka.co的Google Webcache时代，您需要使用以下网址：

http://webcache.googleusercontent.com/search?q=cache:edureka.co

Q50.您需要从IMDb前250电影页面中删除数据,只有字段电影名称，年份和评级

from bs4 import BeautifulSoup

import requests

import sys

url ='http://www.imdb.com/chart/top'

response =requests.get(url)

soup =BeautifulSoup(response.text)

tr =soup.findChildren("tr")

tr =iter(tr)

next(tr)

formovie intr:

title =movie.find('td', {'class': 'titleColumn'} ).find('a').contents[0]

year =movie.find('td', {'class': 'titleColumn'} ).find('span', {'class': 'secondaryInfo'}).contents[0]

rating =movie.find('td', {'class': 'ratingColumn imdbRating'} ).find('strong').contents[0]

row =title +' - '+year +' '+' '+rating

print(row)

上述代码将有助于从IMDb的前250名列表中删除数据。

Q51.请解释使用*args和*kwargs的含义

当我们不知道向函数传递多少参数时，比如我们向传递一个列表或元组，我们就使用*args：

def func(*args):

  for i in args:

      print(i) 

func(3,2,1,4,7)

3

2

1

4

7

在我们不知道该传递多少关键字参数时，使用**kwargs来收集关键字参数：

def func(**kwargs):

  for i in kwargs:

      print(i,kwargs[i])

func(a=1,b=2,c=7)

a.1

b.2

c.7

Q52.如何在Python中删除文件？

使用命令os.remove（filename）或os.unlink（filename）

Q53.解释如何从C访问用Python编写的模块？

您可以通过以下方法访问C中用Python编写的模块：

Module = = PyImport_ImportModule（“<modulename>”）

Q54.在Python中使用//运算符？

它是一个Floor Divisionoperator，用于分割两个操作数，结果为商，只显示小数点前的数字。例如，10 // 5 = 2和10.0 // 5.0 = 2.0。

Q55.怎么移除一个字符串中的前导空格？

字符串中的前导空格就是出现在字符串中第一个非空格字符前的空格。我们使用方法Istrip()可以将它从字符串中移除。

'  Data123  '.lstrip()

结果：

'Data123 '

最初的字符串当中既有前导字符也有后缀字符，调用Istrip()去除了前导空格，如果我们想去除后缀空格，可以使用rstrip()方法。

'Data123    '.rstrip()

'Data123'

Q56.如何用Python输出一个Fibonacci数列?

a,b = 0, 1

　　while b<100:

　　print (b)

　　a, b = b, a+b

Q57.在Python中怎样将字符串转换为整型变量？

如果字符串只含有数字字符，可以用函数int()将其转换为整数。

int('22')

我们检查一下变量类型：

type('22')

<class'str'>

type(int('22'))

<class'int'>

Q58.在Python中如何生成一个随机数？

要想生成随机数，我们可以从random模块中导入函数random()。

from random import random

random()

0.013501571090371978

我们还可以使用函数randint()，它会用两个参数表示一个区间，返回该区间内的一个随机整数。

from random import randint

randint(2,7)

4

Q59.怎样将字符串中第一个字母大写？

最简单的方法就是用capitalize()方法。

'daxie'.capitalize()

'Daxie'

Q60.如何检查字符串中所有的字符都为字母数字？

对于这个问题，我们可以使用isalnum()方法。

'DATA123'.isalnum()

True

'DATA123!'.isalnum()

False

我们还可以用其它一些方法：

'123'.isdigit()#检测字符串是否只由数字组成

True

'123'.isnumeric()#只针对unicode对象

True

'data'.islower()#是否都为小写

True

'Data'.isupper()#是否都为大写

False

Q61.什么是Python中的连接（concatenation）？

Python中的连接就是将两个序列连在一起，我们使用+运算符完成：

'22'+'33'

‘2233’

[1,2,3]+[4,5,6]

[1, 2,3, 4, 5, 6]

(2,3)+(4)

TypeError  Traceback (most recent call last)

<ipython-input-7-69a1660f2fc5> in <module>

----> 1 (2,3)+(4)

TypeError: can only concatenate tuple (not "int") to tuple

这里运行出错，因为（4）被看作是一个整数，修改一下再重新运行：

(2,3)+(4,)

(2, 3,4)

Q62.什么是递归？

在调用一个函数的过程中，直接或间接地调用了函数本身这个就叫递归。但为了避免出现死循环，必须要有一个结束条件，举个例子：

def facto(n):

  if n==1: return 1

  return n*facto(n-1)

facto(5)

120

Q63.什么是生成器？

生成器会生成一系列的值用于迭代，这样看它又是一种可迭代对象。它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。我们定义一个能逐个“yield”值的函数，然后用一个for循环来迭代它。

def squares(n):

  i=1

  while(i<=n):

      yield i**2

      i+=1

for i in squares(5):

  print(i)

1

4

9

16

25

Q64.什么是迭代器？

迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。我们使用inter()函数创建迭代器。

odds=iter([1,2,3,4,5])

#每次想获取一个对象时，我们就调用next()函数

next (odds)

1

next (odds)

2

next (odds)

3

next (odds)

4

next (odds)

5

Q65.请说说生成器和迭代器之间的区别

1）在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()；

2）在生成器中，我们使用关键字‘yield’来每次生成/返回一个对象；

3）生成器中有多少‘yield’语句，你可以自定义；

4）每次‘yield’暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代；

5）使用类可以实现你自己的迭代器，但无法实现生成器；

6）生成器运行速度快，语法简洁，更简单；

7）迭代器更能节约内存。

Q66.函数zip()的是干嘛的？

Python新手可能对这个函数不是很熟悉，zip()可以返回元组的迭代器。

list(zip(['a','b','c'],[1,2,3]))

[(‘a’,1), (‘b’, 2), (‘c’, 3)]

在这里zip()函数对两个列表中的数据项进行了配对，并用它们创建了元组。

Q67.如何用Python找出你目前在哪个目录？

我们可以使用函数/方法getcwd()，从模块os中将其导入。

import os

os.getcwd()

'C:\\Users\\37410\\Desktop\\代码'

Q68.如何计算一个字符串的长度？

这个也比较简单，在我们想计算长度的字符串上调用函数len()即可。

len('Data 123')

8

Q69.如何从列表中删除最后一个对象？

从列表中删除并返回最后一个对象或obj。

list.pop（obj = list [-1]）

Q70.解释一些在Python中实现面向功能的编程的方法

有时，当我们想要遍历列表时，一些方法会派上用场。

1）filter（）

过滤器允许我们根据条件逻辑过滤一些值。

list（filter（lambda x：x> 5，range（8）））

[6,7]

2）map（）

Map将函数应用于iterable中的每个元素。

list（map（lambda x：x ** 2，range（8）））

[0,1,4,9,16,25,36,49]

3）reduce（）

在我们达到单个值之前，Reduce会反复减少序列顺序。

from functools import reduce

reduce（lambda x，y：xy，[1,2,3,4,5]）

-13

Q71.编写一个Python程序来计算数字列表的总和

def list_sum（num_List）：如果len（num_List）== 1：

return num_List [0]

else：

return num_List [0] + list_sum（num_List [1：]）

print（list_sum（[3,4,5,6,11]））

29

Q72.编写一个Python程序来读取文件中的随机行

import random

def random_line（fname）：

lines = open（fname）.read（）.splitlines（）

return random.choice（lines）

print（random_line（'test.txt'））

Q73.编写一个Python程序来计算文本文件中的行数

def file_lengthy（fname）：

open（fname）as f：

for i，l in enumerate（f）：

pass

return i + 1

print（“file of lines：”，file_lengthy（“test.txt”））

Q74.请写一个Python逻辑，计算一个文件中的大写字母数量

import os

os.chdir('C:\Users\lifei\Desktop')

with open('Today.txt') as today:

count=0

for i in today.read():

if i.isupper():

count+=1

print(count)

Q75.在Python中为数值数据集编写排序算法

以下代码可用于在Python中对列表进行排序：

list = ["1", "4", "0", "6", "9"]

list = [int(i) for i in list]

list.sort()

print (list)

Django有关

Q76.请解释或描述一下Django的架构

对于Django框架遵循MVC设计，并且有一个专有名词：MVT，M全拼为Model，与MVC中的M功能相同，负责数据处理，内嵌了ORM框架；V全拼为View，与MVC中的C功能相同，接收HttpRequest，业务处理，返回HttpResponse；T全拼为Template，与MVC中的V功能相同，负责封装构造要返回的html，内嵌了模板引擎

Q77.Django，Pyramid和Flask之间的差异

Flask是一个“微框架”，主要用于具有更简单要求的小型应用程序。Pyramid适用于大型应用程序，具有灵活性，允许开发人员为他们的项目使用数据库，URL结构，模板样式等正确的工具。Django也可以像Pyramid一样用于更大的应用程序。它包括一个ORM。

Q78.讨论Django架构

Django架构

开发人员提供模型，视图和模板，然后将其映射到URL，Django可以为用户提供服务。

Q79.解释如何在Django中设置数据库

Django使用SQLite作为默认数据库，它将数据作为单个文件存储在文件系统中。

如过你有数据库服务器-PostgreSQL，MySQL，Oracle，MSSQL-并且想要使用它而不是SQLite，那么使用数据库的管理工具为你的Django项目创建一个新的数据库。

无论哪种方式，在您的（空）数据库到位的情况下，剩下的就是告诉Django如何使用它。这是项目的settings.py文件的来源。

我们将以下代码行添加到setting.py文件中：

DATABASES ={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),

Q80.举例说明如何在Django中编写VIEW？

这是我们在Django中使用write一个视图的方法：

from django.http import HttpResponse

import datetime

def Current_datetime(request):

now =datetime.datetime.now()

html ="<html><body>It is now %s</body></html>"%now

return HttpResponse(html)

返回当前日期和时间，作为HTML文档。

Q81.提到Django模板的组成部分。

模板是一个简单的文本文件。它可以创建任何基于文本的格式，如XML，CSV，HTML等。模板包含在评估模板时替换为值的变量和控制模板逻辑的标记（％tag％）。

Q82.在Django框架中解释会话的使用？

Django提供的会话允许您基于每个站点访问者存储和检索数据。Django通过在客户端放置会话ID cookie并在服务器端存储所有相关数据来抽象发送和接收cookie的过程。

所以数据本身并不存储在客户端。从安全角度来看，这很好。

Q83.列出Django中的继承样式

在Django中，有三种可能的继承样式：

抽象基类：当你只希望父类包含而你不想为每个子模型键入的信息时使用；

多表继承：对现有模型进行子类化，并且需要每个模型都有自己的数据库表。

代理模型：只想修改模型的Python级别行为，而无需更改模型的字段。

数据分析

Q84.什么是Python中的map函数？

map函数执行作为第一个参数给出的函数，该函数作为第二个参数给出的iterable的所有元素。如果给定的函数接受多于1个参数，则给出了许多迭代。

Q85.如何在NumPy数组中获得N个最大值的索引？

我们可以使用下面的代码在NumPy数组中获得N个最大值的索引：

importnumpy as np

arr =np.array([1, 3, 2, 4, 5])

print(arr.argsort()[-3:][::-1])

4 3 1

Q86.如何用Python/ NumPy计算百分位数？

importnumpy as np

a =np.array([1,2,3,4,5]

p =np.percentile(a, 50) #Returns 50th percentile, e.g. median

print(p)

3

Q87.NumPy阵列在（嵌套）Python列表中提供了哪些优势？

1）Python的列表是高效的通用容器。

它们支持（相当）有效的插入，删除，追加和连接，Python的列表推导使它们易于构造和操作。

2）有一定的局限性

它们不支持元素化加法和乘法等“向量化”操作，可以包含不同类型的对象这一事实意味着Python必须存储每个元素的类型信息，并且必须在操作时执行类型调度代码在每个元素上。

3）NumPy不仅效率更高，也更方便

你可以获得大量的矢量和矩阵运算，这有时可以避免不必要的工作。

4）NumPy数组更快

你可以使用NumPy，FFT，卷积，快速搜索，基本统计，线性代数，直方图等内置。

Q88.解释装饰器的用法

Python中的装饰器用于修改或注入函数或类中的代码。使用装饰器，您可以包装类或函数方法调用，以便在执行原始代码之前或之后执行一段代码。装饰器可用于检查权限，修改或跟踪传递给方法的参数，将调用记录到特定方法等

Q89.NumPy和SciPy有什么区别？

1）在理想的世界中，NumPy只包含数组数据类型和最基本的操作：索引，排序，重新×××，基本元素函数等。

2）所有数字代码都将驻留在SciPy中。然而，NumPy的一个重要目标是兼容性，因此NumPy试图保留其前任任何一个支持的所有功能。

3）因此，NumPy包含一些线性代数函数，即使它们更恰当地属于SciPy。无论如何，SciPy包含更多全功能的线性代数模块版本，以及许多其他数值算法。

4）如果你使用python进行科学计算，你应该安装NumPy和SciPy。大多数新功能属于SciPy而非NumPy。

Q90.如何使用NumPy / SciPy制作3D绘图/可视化？

与2D绘图一样，3D图形超出了NumPy和SciPy的范围，但就像2D情况一样，存在与NumPy集成的包。Matplotlib在mplot3d子包中提供基本的3D绘图，而Mayavi使用功能强大的VTK引擎提供各种高质量的3D可视化功能。

爬虫和scary框架

Q91.scrapy和scrapy-redis有什么区别？为什么选择redis数据库？

1) scrapy是一个Python爬虫框架，爬取效率极高，具有高度定制性，但是不支持分布式。

而scrapy-redis一套基于redis数据库、运行在scrapy框架之上的组件，可以让scrapy支持分布式策略，Slaver端共享Master端redis数据库里的item队列、请求队列和请求指纹集合。

2) 因为redis支持主从同步，而且数据都是缓存在内存中的，所以基于redis的分布式爬虫，对请求和数据的高频读取效率非常高。

Q92.你用过的爬虫框架或者模块有哪些？

Python自带：urllib，urllib2

第 三 方：requests

框 架：Scrapy

urllib和urllib2模块都做与请求URL相关的操作，但他们提供不同的功能。

urllib2.：urllib2.urlopen可以接受一个Request对象或者url，（在接受Request对象时候，并以此可以来设置一个URL 的headers），urllib.urlopen只接收一个url

urllib 有urlencode,urllib2没有，因此总是urllib，urllib2常会一起使用的原因

scrapy是封装起来的框架，他包含了下载器，解析器，日志及异常处理，基于多线程， twisted的方式处理，对于固定单个网站的爬取开发，有优势；但是对于多网站爬取 100个网站，并发及分布式处理方面，不够灵活，不便调整与括展。

request 是一个HTTP库， 它只是用来，进行请求，对于HTTP请求，他是一个强大的库，下载，解析全部自己处理，灵活性更高，高并发与分布式部署也非常灵活，对于功能可以更好实现。

Q93.你常用的mysql引擎有哪些？各引擎间有什么区别？

主要 MyISAM 与 InnoDB 两个引擎，其主要区别如下：

1）InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高

级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM

就不可以了；

2)MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到

安全性较高的应用；

3)InnoDB 支持外键，MyISAM 不支持；

4)MyISAM 是默认引擎，InnoDB 需要指定；

5)InnoDB 不支持 FULLTEXT 类型的索引；

6)InnoDB 中不保存表的行数，如 select count(*) from table 时，InnoDB；需要

扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即

可。注意的是，当 count(*)语句包含 where 条件时 MyISAM 也需要扫描整个表；

7)对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM

表中可以和其他字段一起建立联合索引；

8)清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重

建表；

9)InnoDB 支持行锁（某些情况下还是锁整表，如 update table set a=1 where

user like '%lee%'

Q94.描述下scrapy框架运行的机制？

从start_urls里获取第一批url并发送请求，请求由引擎交给调度器入请求队列，获取完毕后，

调度器将请求队列里的请求交给下载器去获取请求对应的响应资源，并将响应交给自己编写的解析方法做提取处理：

1) 如果提取出需要的数据，则交给管道文件处理；

2)如果提取出url，则继续执行之前的步骤（发送url请求，并由引擎将请求交给调度器入队列...)，直到请求队列里没有请求，程序结束。

Q95.什么是关联查询，有哪些？

将多个表联合起来进行查询，主要有内连接、左连接、右连接、全连接（外连接）

Q96.写爬虫是用多进程好？还是多线程好？ 为什么？

IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，

而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。

在实际的数据采集过程中，既考虑网速和响应的问题，也需要考虑自身机器的硬件情况来设置多进程或多线程。

Q97.数据库的优化？

1)优化索引、SQL 语句、分析慢查询；

2)优化硬件；采用SSD，使用磁盘队列技术(RAID0,RAID1,RDID5)等；

3)采用MySQL 内部自带的表分区技术，把数据分层不同的文件，能够提高磁

盘的读取效率；

4)选择合适的表引擎，参数上的优化；

5)进行架构级别的缓存，静态化和分布式；

6)采用更快的存储方式，例如 NoSQL存储经常访问的数据

Q98.分布式爬虫主要解决什么问题？

1)ip

2)带宽

3）cpu

4）io

Q99.爬虫过程中验证码怎么处理？

1)scrapy自带

2)付费接口

Q100.常见的反爬虫和应对方法？

1）通过Headers反爬虫

从用户请求的Headers反爬虫是最常见的反爬虫策略。可以直接在爬虫中添加Headers，将浏览器的User-Agent复制到爬虫的Headers中；或者将Referer值修改为目标网站域名。

2）基于用户行为反爬虫

通过检测用户行为，例如同一IP短时间内多次访问同一页面，或者同一账户短时间内多次进行相同操作。

大多数网站都是前一种情况，对于这种情况，使用IP代理就可以解决。

可以专门写一个爬虫，爬取网上公开的代理ip，检测后全部保存起来。

有了大量代理ip后可以每请求几次更换一个ip，这在requests或者urllib2中很容易做到，这样就能很容易的绕过第一种反爬虫。

对于第二种情况，可以在每次请求后随机间隔几秒再进行下一次请求。

有些有逻辑漏洞的网站，可以通过请求几次，退出登录，重新登录，继续请求来绕过同一账号短时间内不能多次进行相同请求的限制。

3）动态页面的反爬虫

首先用Fiddler对网络请求进行分析，如果能够找到ajax请求，也能分析出具体的参数和响应的具体含义，我们就能采用上面的方法。

直接利用requests或者urllib2模拟ajax请求，对响应的json进行分析得到需要的数据。

但是有些网站把ajax请求的所有参数全部加密了，没办法构造自己所需要的数据的请求。

这种情况下就用selenium+phantomJS，调用浏览器内核，并利用phantomJS执行js来模拟人为操作以及触发页面中的js脚本。

